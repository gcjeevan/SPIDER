head	1.37;
access;
symbols
	pre_mrcs:1.25
	healthdept_2018:1.25
	pre_getangas:1.13
	GPL2010:1.6
	pre_GPL2010:1.5
	pre_var_equation:1.4
	pre_fftwrings:1.3
	pre_opfiles:1.1
	src:1.1;
locks; strict;
comment	@c @;


1.37
date	2020.02.06.15.18.23;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2020.01.16.18.37.26;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2020.01.15.19.43.38;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2020.01.14.19.05.28;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2020.01.13.19.21.24;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2020.01.09.19.41.23;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2020.01.08.19.19.53;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2020.01.08.18.25.30;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2020.01.07.19.43.08;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2019.12.31.19.59.24;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2019.11.06.18.49.57;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2019.11.04.17.36.09;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2018.10.03.14.34.11;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2014.10.02.13.29.54;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2014.09.15.15.36.42;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2014.06.02.11.59.23;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.22.14.18.29;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.18.13.43.32;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.05.16.22.23;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.01.18.55.16;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2012.04.11.18.17.27;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.29.11.45.55;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.18.17.50.11;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.29.15.21.56;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.10.15.39.27;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.08.17.03.39;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.12.18.34.42;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.03.19.26.45;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.03.18.24.01;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.03.17.03.17;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.03.16.21.22;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.24.13.26.25;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.01.11.15.31;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.22.10.57.10;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.06.21.27.49;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.12.13.45.19;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.11.17.53.19;	author leith;	state Exp;
branches;
next	;


desc
@@


1.37
log
@nextfile(s)  bare and series numbering 
cosmetic
@
text
@ 
C++*********************************************************************
C                                                                      
C  OPFILES.F   NEW                              12/15/06  ArDean Leith    
C              BAD NUMBRT() TRAP                05/21/09  ArDean Leith  
C              ASKNAM, PROMPTEX                 12/06/10  ArDean Leith 
C              NX...                            03/26/12  ArDean Leith 
C              COPY NON SPIDER INPUT            05/26/14  ArDean Leith 
C              COPY NON SPIDER INPUT            05/26/14  ArDean Leith 
C              LOCAST, ASKLIST FOR ILIST        10/02/14  ArDean Leith
C              DO NOT CHECK .MRC FOR XMIPP       7/25/19  ArDean Leith
C              MRC SUPPORT                       8/05/19  ArDean Leith
C              COMMENTS                          2/06/20  ArDean Leith
C
C ********************************************************************** 
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2020  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C ********************************************************************** 
C 
C  CONTAINS:  OPFILES, GETOLDIMG, GETNEWIMG, NEXTFILE, NEXTFILES 
C
C  OPFILES(LUNCP,LUNIMG,LUNDOC,LUNXM,  ASKNAM,FILPAT,NLET, DISP,
C          ITYPE,NX,NY,NZ,MAXIM, PROMPT,
C          FOUROK, ILIST,NIMAXT, UNUSED
C          NTOT,IMGNUM, IRTFLG)
C 
C  PURPOSE: SOLICITS FILE NAME(S) AND OPENS FILE(S)
C           SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C           WORK ON WHOLE STACK OR WITH A SELECTION DOC FILE.
C           ONLY USED IN A FEW OPERATIONS.  RAN OUT OF YEARS TO
C           COMPLETE THE IMPLEMENTATION IN MORE OPERATIONS
C           ALSO WORKS FOR MRC FILES NOW
C
C  PARAMETERS:
C        LUNCP      UNIT TO COPY HEADER VALUES FROM               (SENT)
C        LUNIMG     UNIT TO OPEN FILE ON                          (SENT)
C        LUNDOC     UNIT TO OPEN LIST DOC FILES ON                (SENT)
C        LUNXM      UNIT TO OPEN XMIPP SELFILE ON                 (SENT)
C        ASKNAM     FLAG TO ASK FOR FILE NAME                     (SENT)
C        FILPAT     FILE NAME PATTERN                             (RET)
C        NLET       CHARS IN FILE NAME PATTERN                    (RET)
C        DISP       CHARACTER CONTAINING ONE OF THE               (SENT) 
C                   FOLLOWING DISPOSITION SPECIFICATIONS:
C                   'O'   -  FILE IS ASSUMED TO EXIST.  DIMENSIONS,
C                            ITYPE AND HEADER INFO (IN COMMON) ARE 
C                            RETURNED TO THE CALLING PROGRAM. 
C                   'B'   -  SAME AS OLD BUT NO LIMIT ON BUFFER LENGTH
C                            FOR OPENCHK. 
C                   'Z/E' -  THE FILE IS ASSUMED TO EXIST.
C                            IF FILE DOES NOT EXIST, THEN BATCH DOES
C                            NOT STOP. (ONLY DIFFERENCE FROM 'O'). 
C                   'N'  -   WANT NEW FILE. SEND NX, NY, NZ & ITYPE.
C                   'U'  -   IT IS NOT KNOWN IF THE FILE EXISTS.  
C                            SEND NX, NY, NZ & ITYPE. IF FILE 
C                            ALREADY EXISTS, IT WILL BE REPLACED.
C        ITYPE      IFORM FOR FILE                        (SENT OR RET) 
C        NX,NY,NZ   IMAGE SIZE                            (SENT OR RET)
C
C        MAXIM      STACK INDICATOR                          (SENT/RET)
C                   ON INPUT: STACK INDICATOR IF DISP == 'I'     (SENT)
C                   ON OUTPUT:                                    (RET)
C                       -2 A NON-STACK IMAGE                
C                       -1 A SINGLE STACKED IMAGE                  
C                     >= 0 CURRENT MAX. IMAGE NO. IN STACK             
C        PROMPT     PROMPT FOR FILNAME                           (SENT)
C                     IF NOT (ASKNAM) THIS IS FILE NAME          (SENT)
C                     ~ (TILDE) IN LAST CHAR. SAYS SKIP
C                       "FILE" AT END OF PROMPT
C                     ~9 IN NEXT TO LAST OR
C                        NEXT-TO-NEXT-TO LAST
C                        ACCEPTS AN EXTENSION
C                        (OTHERWISE DISCARDED!)
C                     ~6 KEEPS OLD DATE/TIME
C        FOUROK     CAN USE EXISTING FOURIER FILES?              (SENT)
C        ILIST      IMAGE NUMBER LIST                             (RET)
C                     IF NIMAXT < 0 MUST BE SENT
C                     NOT USED IF SINGLE IMAGE/SELFILE 
C        NIMAXT     MAX LENGTH OF IMAGE NUMBER LIST              (SENT)
C                     <0 MEANS DO NOT ASK FOR LIST
C        NTOT:      # OF IMAGES IN IMAGE NUMBER LIST              (RET)
C                   ZERO FOR SINGLE IMAGE AND NO * 
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN      (SENT/RET)
C                   ON INPUT:   IF (BARESTACK) IS # WANTED
C                   ON OUTPUT:  <0 IS SELFILE IN USE 
C        ILIST      IMAGE NUMBER LIST                             (RET)
C                     IF NIMAXT < 0 MUST BE SENT
C                     UNUSED IF SINGLE IMAGE/SELFILE 
C        UNUSED     UNUSED PARAMETER                                (?)
C        NTOT       # OF IMAGES IN IMAGE NUMBER LIST              (RET)
C                     ZERO FOR SINGLE IMAGE AND NO * 
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                      (RET)
C                      -1 GOTO PREVIOUS QUESTION
C                      -5 NOT A SPIDER OR MRC FILE
C 
C  CALL TREE:
C
C     OPFILES 
C        v
C     FILERD
C        v 
C     FILELIST
C        |  Templated stack: STK@@*** 
C        ` ---> FILNAMANDEXT --> OPFILEC --> GETOLDIMG
C        |                               --> GETNEWIMG
C        |
C        |  Whole barestack: STK@@     
C        ` ---> FILNAMANDEXT --> OPFILEC --> GETOLDIMG
C        |                               --> GETNEWIMG
C        | 
C        |  File template:   IMG***  
C        ` ---> FILGET       --> OPFILEC  
C        | 
C        |  Simple file:    IMG001
C        ` --------------------> OPFILEC  
C        | 
C        |  MRC file:       *.MRC or *.MRCS
C        ` -> OPFILES_MRC
C           |
C           |  Templated stack:  **@@STK.MRC
C           ` ---> FILGET_AT --> OPFILEC --> OPENFIL_MRC --> OPENFIL_O_MRC 
C           |                                            --> OPENFIL_N_MRC
C           |
C           |  Whole barestack:  @@STK.MRC 
C           ` ---> FILGET_AT --> OPFILEC --> OPENFIL_MRC --> OPENFIL_O_MRC
C           |                                            --> OPENFIL_N_MRC
C           | 
C           |  File template:    IMG***.MRC
C           ` ---> FILGET_AT --> OPFILEC --> OPENFIL_MRC --> OPENFIL_O_MRC
C           |                                            --> OPENFIL_N_MRC
C           | 
C           |  Simple file:      IMG001.MRC
C           ` -----------------> OPFILEC --> OPENFIL_MRC --> OPENFIL_O_MRC  
C                                                        --> OPENFIL_N_MRC
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12 
C--********************************************************************* 

       SUBROUTINE OPFILES(LUNCP,LUNIMG,LUNDOC,LUNXM,
     &                    ASKNAM,FILPAT,NLET, DISP,
     &                    ITYPE,NX,NY,NZ,MAXIM,
     &                    PROMPT,
     &                    FOUROK,ILIST,NIMAXT, 
     &                    UNUSED,NTOT,IMGNUM, IRTFLG) 
 
       IMPLICIT NONE
       INCLUDE 'CMBLOCK.INC' 
       INCLUDE 'CMLIMIT.INC' 
 
       INTEGER                   :: LUNCP,LUNIMG,LUNDOC
       LOGICAL                   :: ASKNAM
       CHARACTER(LEN=*)          :: FILPAT 
       INTEGER                   :: NLET
       CHARACTER(LEN=1)          :: DISP
       INTEGER                   :: ITYPE,NX,NY,NZ,MAXIM
       CHARACTER(LEN=*)          :: PROMPT 
       LOGICAL                   :: FOUROK
       INTEGER                   :: ILIST(*)
       INTEGER                   :: NIMAXT,UNUSED,NTOT,IMGNUM, IRTFLG

       INTEGER                   :: LUNOP,NLETT,LOCTILDE,LOCAT,LOCAST
       INTEGER                   :: IMGWANT,IMGNUMIN,LENE,I
       INTEGER                   :: NIMAXP,LUNXM,NDUM
       LOGICAL                   :: ISOPEN,GOTFILE
       LOGICAL                   :: SAYIT,ASKLIST

       CHARACTER (LEN=MAXNAM)    :: FILNAMT,FILNAM 
       CHARACTER (LEN=2*MAXNAM)  :: MESG 
       CHARACTER (LEN=100)       :: PROMPTEX
       CHARACTER (LEN=1)         :: CDUM 
       CHARACTER (LEN=1)         :: DISPT 
       CHARACTER (LEN=1)         :: NULL = CHAR(0)

       LOGICAL                   :: IS_MRC,IS_BARE
       LOGICAL                   :: ISMRCFILE    ! FUNCTION 

       INTEGER                   :: LNBLNKN      ! FUNCTION

       LOCTILDE = INDEX(PROMPT,'~') ! unfinished

       !write(3,*)' In opfiles, imgnum: ',imgnum

       IF (ASKNAM .AND. PROMPT == NULL) THEN
C         ASK FOR FILE NAME, CAN ACCEPT EXTENSION

          IF (DISP == 'N' .OR. 
     &        DISP == 'I' .OR.
     &        DISP == 'U') THEN
C            NEW FILE, USE DEFAULT PROMPT
             PROMPTEX = 
     &          'OUTPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
          ELSE
C            OLD FILE, USE DEFAULT PROMPT
             PROMPTEX = 
     &          'INPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
          ENDIF
       
          CALL FILERD(FILPAT,NLET,NULL,PROMPTEX,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN 

       ELSEIF (ASKNAM) THEN
C         ASK FOR FILE NAME USING PROMPT
      
          CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN 

       ELSE
C         USE FILENAME SENT IN: PROMPT
          FILPAT = PROMPT
          NLET   = LNBLNKN(FILPAT)
       ENDIF
 
       LOCAT    = INDEX(FILPAT(1:NLET),'@@')   
       LOCAST   = INDEX(FILPAT(1:NLET),'*')
       
       !write(3,*)' locast,locat:',locast,locat,filpat(1:nlet)
       !write(6,*)' ilist:',ilist(1)
       !write(6,*)' locast,locat,nstack:',locast,locat,maxim
       !write(3,*)' in opfiles, nimaxt:',nimaxt

       ASKLIST = (NIMAXT > 0)   ! ASK FOR IMAGE NUMBER(S)
       NIMAXP  = ABS(NIMAXT)    ! ILIST DIMENSION, IF ILIST IN USE
 
       !write(3,*)' in opfiles, nimaxt: ',nimaxt
       !write(3,*)' in opfiles, asklist: ',asklist
       !write(3,*)' In opfiles, imgnum: ',imgnum

       IMGWANT = MAX(1,IMGNUM)   ! DEFAULT IMAGE NUMBER               
       
       IF (LOCAST > 0 .AND. ASKLIST) THEN
C         GET LIST OF IMAGES FROM DOC. FILE OR INPUT LINE
          NTOT   = 0 
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,ILIST,NIMAXP,
     &                  NTOT,' ',IRTFLG)
          IF (IRTFLG .NE. 0) RETURN

C         START WITH FIRST FILE IN SERIES
          IMGWANT = ILIST(1)
          !write(3,*)' In opfiles, imgwant aa: ',imgwant

       ELSEIF (LOCAST > 0 .AND. NIMAXT < 0) THEN

C         ILIST CONTAINS TEMPLATED SERIES, 
C         START WITH FIRST FILE IN THIS SERIES
          IMGWANT = ILIST(1)
          NTOT    = NIMAXP
          !write(3,*)' In opfiles, imgwant bb: ',imgwant

       ELSEIF (.NOT. ASKLIST) THEN
          NTOT = NIMAXP
       ENDIF

       IF (IMGWANT < 0 .OR. IMGWANT > 10000000) THEN
          CALL ERRT(102,'INVALID IMAGE NUMBER',IMGWANT)
          IRTFLG = 1
          RETURN
       ENDIF

       !write(3,*)' In opfiles, nimaxt: ',nimaxt
       !write(3,*)' In opfiles, ilist: ',ilist(1:5)
       !write(3,*)' In opfiles, asklist,nimaxp: ',asklist,nimaxp
       !write(3,*)' In opfiles, maxim,ntot,imgwant: ',maxim,ntot,imgwant

C      SEE IF THIS IS A MRC FILE
       IS_MRC = ISMRCFILE(FILPAT)

       !write(3,*)' In opfiles, imgwant cc: ',imgwant
       IF (IS_MRC) THEN
C         OPEN MRC FILE
          CALL OPFILES_MRC(LUNCP,LUNIMG,LUNDOC,
     &                     FILPAT,NLET, DISP,
     &                     ITYPE,NX,NY,NZ,MAXIM,
     &                     IMGWANT, IRTFLG) 
          
          IMGNUM = IMGWANT

          RETURN
       ENDIF

       IMGNUMIN = IMGNUM
       IMGNUM   = 0 
       !write(3,*) ' In opfiles - imgnum 0: ',imgnum

       IF (LOCAT > 0 .AND. LOCAST > LOCAT) THEN
C         TEMPLATED STACKED FILE: STK@@**** -------------- _9@@* or STK@@**

          FILNAM = FILPAT(1:LOCAT)
            
          IF (FILNAM(1:1) .NE. '_') THEN
C            CONCATENATE EXTENSION ONTO FILNAM
             CALL FILNAMANDEXT(FILNAM(1:LOCAT-1),DATEXC,
     &                         FILNAMT,NLET,.TRUE.,IRTFLG)
             INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
             MESG = '  FILE: ' // FILNAMT(1:NLET) //
     &              '  ALREADY OPENED ON' // NULL
             LENE = LNBLNKN(MESG)
             IF (ISOPEN .AND. LUNOP .NE. LUNIMG) THEN
                WRITE(NOUT,'(A,I3)') MESG(1:LENE),LUNOP 
                IRTFLG = -2
                GOTO 9000
             ENDIF
          ENDIF

          !write(6,*) ' In opfiles - imgwant,imgnum1: ',imgwant,imgnum

C         OPEN THE STACK FILE HEADER 
          MAXIM  = 1  
	  CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000 

          !write(6,*) ' In opfiles - locast: ',locat,locast,filnam
          !write(6,*) ' In opfiles - imgwant,imgnum2: ',imgwant,imgnum


C         OPEN FIRST FILE IN STACK SERIES
          IMGWANT  = ILIST(1)
          IF (IMGWANT < 0 .OR. IMGWANT > 10000000) THEN
              CALL ERRT(102,'INVALID IMAGE NUMBER',IMGWANT)
              IRTFLG = 1
              GOTO 9000
          ENDIF


C         THIS IS NOT A BARE STACK FILE
          CALL LUNSETISBARE(LUNIMG,.FALSE.,IRTFLG)

          SAYIT    = .TRUE.
          IF (DISP == 'U' .OR. DISP == 'N') THEN
C            WANT A NEW SPIDER STACK FILE FOR OUTPUT

             !write(6,*) ' In opfiles - imgwant,imgnum: ',imgwant,imgnum

             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)

             !write(6,*) ' In opfiles - imgwant,imgnum3: ',imgwant,imgnum

          ELSE
C            WANT TO USE EXISTING SPIDER STACK FILE
             CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGWANT,SAYIT,
     &                         FOUROK,IMGNUM,IRTFLG)
          ENDIF
          IF (IRTFLG .NE. 0) GOTO 9000

C         RETRIEVE CURRENT MAXIMUM IMAGE NUMBER FROM OVERALL HEADER
          CALL LUNGETMAXIM(LUNIMG,MAXIM,IRTFLG)

          !write(6,'(a,a,a,i6,a,i6,a,i6)')' opened templated stack: ',
!     &          filpat(1:nlet),' at image: ',imgnum, 
!     &          '  maxim: ',maxim

       ELSEIF (LOCAT == NLET) THEN
C         WHOLE BARESTACK:  STK@@  --------------------------_9@@ or STK@@
          DISPT = DISP
          IF (DISP == 'I') THEN
C             OPEN NEW BARE INDEXED STACK 
              DISPT = 'N'
              MAXIM = -MAXIM  ! FLAG FOR INDEXED STACK
          ELSE
              MAXIM = 1
          ENDIF

          IF (FILNAM(1:1) .NE. '_') THEN
             CALL FILNAMANDEXT(FILPAT(1:LOCAT-1),DATEXC,
     &                         FILNAMT,NLET,.TRUE.,IRTFLG)
             INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
             MESG = '  FILE: ' // FILNAMT(1:NLET) //
     &              '  ALREADY OPENED ON' // NULL
             LENE = LNBLNKN(MESG)
             IF (ISOPEN .AND. LUNOP .NE. LUNIMG) THEN
                WRITE(NOUT,'(A,I3)') MESG(1:LENE),LUNOP 
                !CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -2
                GOTO 9000
             ENDIF
          ENDIF

          CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISPT,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,'INPUT',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000

C         OPEN FIRST FILE IN STACK, UNLESS SPECIFIED FOR NEW BARE STACK
          IMGWANT = 1
          SAYIT   = .TRUE.

          IF (DISP == 'U' .OR. 
     &        DISP == 'I' .OR.
     &        DISP == 'N') THEN
C            NEW BARE STACK, OPEN REQUESTED FILE IN STACK

             IF (IMGNUMIN > 0) IMGWANT = IMGNUMIN
             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9000
         
          ELSE
C            EXISTING BARE STACK, OPEN FIRST FILE IN STACK
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGWANT,
     &                      SAYIT,FOUROK,IMGNUM,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9000

C            CREATE IMAGE NUMBER LIST IN: ILIST
             NTOT = 0
             DO I= 1,MAXIM
                NTOT = NTOT + 1
                IF (NTOT > NIMAXP) THEN
                   CALL ERRT(102,'IMAGE # LIST OVERFLOW AT IMAGE',NTOT)
                   GOTO 9000
                ENDIF
                ILIST(NTOT) = I
             ENDDO
          ENDIF

          !write(3,*)' Opened bare stack:',filpat(1:nlet),' img:',imgnum
          !write(6,*)' Opened imgnum, stack:',imgnum,filpat(1:nlet)
          !write(3,*)' Opened imgwant,ntot:',imgwant,imgnum,ntot

       ELSEIF (LOCAST > 0) THEN
C         A SIMPLE FILE TEMPLATE: IMG*** ----------------------- IMG***

C         FIND IMGNUM FOR FIRST FILE IN THE SERIES
          IMGNUM = ILIST(1)
          IF (IMGNUM < 0 .OR. IMGNUM > 10000000) THEN
              CALL ERRT(102,'INVALID IMAGE NUMBER',IMGNUM)
              IRTFLG = 1
              GOTO 9000
          ENDIF

C         SUBSTITUTE IMGNUM INTO FILPAT 
          CALL  FILGET(FILPAT,FILNAM,NLET,IMGNUM,IRTFLG)
	  IF (IRTFLG .NE. 0) GOTO 9000 

C         OPEN FIRST FILE IN THE SERIES
          MAXIM = 0 
	  CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000 

          !write(6,*)' Opened templated file: ',filpat(1:nlet),
          !&              '  for:',ntot,' images.'

       ELSE
C         SINGLE SIMPLE INPUT FILE: IMG001 -------------------- IMG001
C         OR XMIPP SELFILE LISTING FILE: SELX ----------------- SELFILE
C         OR TRYING TO COPY NON-SPIDER FILE   ----------------- NONSPIFILE
               
C         CHECK FOR XMIPP SELFILE LIST
          IF (LUNXM > 0 .AND. .NOT. ISMRCFILE(FILPAT) ) THEN
             !write(6,*)' Filpat for openxmsel: ',filpat(:nlet) 
             CALL OPENXMSELFILE(FILPAT,LUNXM,FILNAM,NLET,NTOT,IRTFLG)
             !write(6,*)' Filnam from openxmsel: ',ntot,':',filnam(:nlet) 

             INQUIRE(FILE=FILNAM(:NLET),EXIST=GOTFILE)
           
             IF (NTOT > 0 .AND. GOTFILE) THEN
C               OPEN FIRST FILE IN XMIPP SELFILE LIST
                MAXIM = 0  
	        CALL OPFILEC(LUNCP,.FALSE.,FILNAM(:NLET),LUNIMG,DISP,
     &                       ITYPE,NX,NY,NZ, 
     & 		             MAXIM,'dum~9',FOUROK,IRTFLG) 
	        IF (IRTFLG .NE. 0) GOTO 9000 

                IMGNUM     = -1
                !write(6,*)' Opened selfile image: ',filnam(1:nlet) 
                RETURN

             ENDIF
          ENDIF

C         SINGLE SIMPLE INPUT FILE: IMG001 ------------------ IMG001

          !write(3,*)' In opfiles, simple file: ',filpat(1:nlet),itype,nx 
          MAXIM = 0  
	  CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,PROMPT,FOUROK,IRTFLG) 

C         RETURN FILENAME WITH ANY EXTENSION IF NOT SPIDER IMAGE
          IF (IRTFLG == 5) NLET = lnblnkn(FILPAT)
	  IF (IRTFLG .NE. 0) GOTO 9000 

          NTOT       = 0
          IMGNUM     = 1

          !write(3,*)' In opfiles, Opened simple: ',filpat(1:nlet)
       ENDIF

9000   RETURN

       END 
 





C++*********************************************************************
C
C GETOLDIMG.F   FROM GETNXTSTK                     JAN 02 ArDean Leith
C
C **********************************************************************
C
C    GETOLDIMG(LUN,LUNXM,FILPAT,NWANT, SAYIT,FOUROK,NGOT,IRTFLG)
C
C    PURPOSE:       TO OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
C                   ACCESS READING/WRITING.
C
C    PARAMETERS:
C        LUN        LUN NUMBER FOR FILNAM                         (SENT)
C        LUNXM      LUN FOR XM SELFILE                            (SENT) 
C        FILPAT     FILENAME PATTERN                              (SENT)
C        NWANT      IMAGE NUMBER WANTED (<0 IS SELFILE)           (SENT) 
C        SAYIT      SAY FILE OPENING INFO.                        (SENT)
C        FOUROK     FOURIER INPUT OK FLAG                         (SENT) 
C        NGOT       IMAGE NUMBER FOUND                            (RET.) 
C        IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                   IRTFLG = -1    END OF FILE BEFORE NWANT
C                   IRTFLG =  0    NORMAL RETURN, IMAGE IS STACK
C                   IRTFLG =  2    IMAGE NOT IN USE
C
C
C  CALL TREE:
C
C       GETOLDIMG 
C          |
C          |  Templated simple image:  IMG*** 
C          ` ---> FILGET --> OPFILEC  
C          |                         
C          |  Templated stacked image: STK@@*(**     
C          ` ---> LUN***
C          | 
C          |  Whole image stack: STK@@  
C          ` ---> LUNS***
C          | 
C          |  Templated stacked MRC: *@@MRC or *@@.MRCS
C          ` ---> GETOLDIMG_MRC --> OPFILEC  
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************
 
	SUBROUTINE GETOLDIMG(LUN,LUNXM,FILPAT,NWANT, SAYIT,
     &                       FOUROK,NGOT,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        INTEGER                :: LUN     
        INTEGER                :: LUNXM     
        CHARACTER(LEN=*)       :: FILPAT
        INTEGER                :: NWANT     
        LOGICAL                :: SAYIT
        LOGICAL                :: FOUROK
        INTEGER                :: NGOT     
        INTEGER                :: IRTFLG     

        CHARACTER(LEN=MAXNAM)  :: FILNAM
        CHARACTER(LEN=1)       :: NULL = CHAR(0)

        INTEGER                :: NLET,LOCAST,LOCAT
        LOGICAL                :: IS_MRC

        NLET   = lnblnkn(FILPAT)

        LOCAST = INDEX(FILPAT(1:NLET),'*')
        LOCAT  = INDEX(FILPAT(1:NLET),'@@')

C       IS THIS A MRC FILE SET
        CALL LUNGETIS_MRC(LUN,IS_MRC,IRTFLG)


        !write(6,*)' locast,locat:',locast,locat,nlet,filpat(1:nlet)
        !write(6,*)' getoldimg, nwant,: ',nwant,':',filpat(1:nlet)
        
        IF (NWANT < 0) THEN
C          XMIPP SELFILE SIMPLE IMAGE ------------------------- SELAAA

C          RECOVER EXISTING IMAGE SIZE & TYPE
           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)    ! USUALLY STILL OPEN
 
C          LOAD FILNAM FROM SELFILE
           CALL GETNEXT_XMSEL(LUNXM,.TRUE.,FILNAM,NLET,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

C          OPEN EXISTING FILE: FILNAM  (HAS EXTENSION)
           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM(:NLET),LUN,'O',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,'~9',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

C          NEW IMAGE SIZE SHOULD BE SAME AS PREVIOUS FILE
           CALL SIZCHK(NULL,NX1,NY1,NZ1,ITYPE1,
     &                      NX ,NY, NZ, ITYPE, IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 
 
           !write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (LOCAST > 0 .AND. LOCAT <= 0) THEN 
C          TEMPLATED SIMPLE IMAGE --------------------------- IMG***

           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)    ! USUALLY STILL OPEN
 
           CALL  FILGET(FILPAT,FILNAM,NLET,NWANT,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM,LUN,'O',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

C          IMAGE SIZE SHOULD BE SAME
           CALL SIZCHK(NULL,NX1,NY1,NZ1,ITYPE1,
     &                      NX ,NY, NZ, ITYPE, IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (IS_MRC .AND. LOCAT > 0 .AND. LOCAST < LOCAT) THEN

C          TEMPLATED STACKED MRC IMAGE ---------------------- **@@STK.mrc
C          BARE STACKED MRC IMAGE      ----------------------   @@STK.mrc
           
          !write(3,*) ' In getoldimg, nwant: ',nwant,locat,locast,filpat
           CALL GETOLDIMG_MRC(LUN,FILPAT,NWANT,SAYIT,
     &                        FILNAM,NGOT,IRTFLG)
           RETURN

        ELSEIF (LOCAT  > 0 .AND. LOCAST > LOCAT) THEN
C          TEMPLATED STACKED SPIDER IMAGE --------------------- STK@@***

C          MUST LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              !write(6,*) ' lunredhed,lun,NX,irtflg:',lun,NX,irtflg
              CALL ERRT(102,'REDHED FAILED ON LUN',LUN) 
              IRTFLG = 2
              RETURN
           ENDIF

C          LOAD SPECIFIED IMAGE HEADER
           CALL LUNREDHED(LUN,NX,NWANT,.FALSE.,IRTFLG)
           IF (IRTFLG == 0) THEN
C             NEED IMUSED FROM THIS STACKED IMAGE
              CALL LUNGETINUSE(LUN,IMUSED,IRTFLG)
           ENDIF
           IF (IRTFLG .NE. 0 .OR. IMUSED == 0) THEN
              CALL ERRT(102,'IMAGE NOT IN STACK',NWANT) 
              IRTFLG = 2
              RETURN
           ENDIF
           NGOT = NWANT

           FILNAM = FILPAT
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
           NLET = lnblnkn(FILNAM)

           !write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)

        ELSEIF (LOCAT == NLET) THEN
C          WHOLE IMAGE STACK ------------------------------ STK@@ or _1@@
C          GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION
C          DO NOT CALL ERRT IF RUNS OFF END OF FILE

           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)

           NGOT = NWANT
           DO
C             LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
              CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)

C             LOAD SPECIFIED IMAGE HEADER
              CALL LUNREDHED(LUN,NX,NGOT,.FALSE.,IRTFLG)
              IF (IRTFLG > 0) THEN
C                PROBABLY RAN OFF END OF STACK FILE
                 IRTFLG = -1
                 NGOT   = 0
                 RETURN
              ENDIF

C             NEED IMUSED FROM THIS STACKED IMAGE
              CALL LUNGETINUSE(LUN,IMUSED,IRTFLG)
              IF (IMUSED > 0) EXIT     ! FOUND NEXT IMAGE

C             THIS IMAGE NOT AN EXISTING IMAGE WITHIN STACK!
C             INCREMENT NGOT AND TRY AGAIN
              NGOT  = NGOT + 1

           ENDDO

           FILNAM = FILPAT
           CALL LUNSETIMNUM(LUN,FILNAM,NGOT,'O',IRTFLG)

           NLET = lnblnkn(FILNAM)

           !write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
           !write(6,*)' ngot,NX:',ngot,NX,lun,imused,irtflg
        ENDIF

C       SET OFFSETS FOR REDLIN/WRTLIN ON THIS LUN
        CALL LUNSETIMGOFF(LUN,NGOT,NX,IRTFLG)

C       WRITE OUT FILE OPENING INFO 
        CALL LUNSAYINFO(LUN,IRTFLG)

C       SET COMMON BLOCK VARIABLES
        CALL LUNSETCOMMON(LUN,IRTFLG)


	END


C **********************************************************************
C
C  GETNEWIMG(LUNCP,LUN,LUNXM,FILPAT,NWANTT, SAYIT,NGOT,IRTFLG)
C
C  PURPOSE:       OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
C                 ACCESS READING/WRITING.
C
C  PARAMETERS:
C       LUNCP      UNIT NUMBER FOR HEADER TXT COPY               (SENT)
C       LUN        UNIT NUMBER FOR FILNAM.                       (SENT)
C       LUNXM      UNIT NUMBER FOR XM SELFILE                    (SENT)
C       FILPAT     FILENAME PATTERN                              (SENT)
C       NWANT      IMAGE NUMBER WANTED                           (SENT) 
C       SAYIT      SAY FILE OPENING INFO                         (SENT)
C       NGOT       IMAGE NUMBER FOUND                            (RET.) 
C       IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                  IRTFLG = -1    END OF FILE BEFORE NWANT
C                  IRTFLG =  0    NORMAL RETURN, IMAGE IS STACK
C                  IRTFLG =  2    IMAGE NOT IN USE
C
C  CALL TREE:
C
C       GETNEWIMG 
C          |
C          |  Templated simple image:  IMG*** 
C          ` ---> FILGET --> OPFILEC  
C          |                         
C          |  Templated stacked image: STK@@*     
C          ` ---> LUN***
C          | 
C          |  Whole image stack: STK@@  
C          ` ---> LUNS***  
C          | 
C          |  Templated stacked MRC image: *@@MRC or *@@.MRCS
C          ` ---> GETNEWIMG_MRC    --> OPFILEC  
C
C **********************************************************************

	SUBROUTINE GETNEWIMG(LUNCP,LUN,LUNXM,FILPAT,NWANTT, 
     &                       SAYIT,NGOT,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'

        INTEGER                :: LUNCP,LUN,LUNXM
        CHARACTER(LEN=*)       :: FILPAT
        INTEGER                :: NWANTT
        LOGICAL                :: SAYIT
        INTEGER                :: NGOT
        INTEGER                :: IRTFLG

        CHARACTER(LEN=MAXNAM)  :: FILNAM
        CHARACTER(LEN=1)       :: DSP
        LOGICAL                :: FOUROK,ISBARE,IS_MRC
        INTEGER                :: NWANT,NLET,LOCAST,LOCAT,NX1,NY1,NZ1
        INTEGER                :: ITYPE1,NX,NY,NZ,ITYPE,ISTACK,IRTFLGT
        INTEGER                :: MAXIM

        LOGICAL                :: ISMRCFILE   ! FUNCTION

        INTEGER                :: lnblnkn     ! FUNCTION


        NWANT  = NWANTT          ! NWANTT MAY NOT BE WRITABLE
        NLET   = lnblnkn(FILPAT)
        LOCAST = INDEX(FILPAT(1:NLET),'*')
        LOCAT  = INDEX(FILPAT(1:NLET),'@@')
        IS_MRC = ISMRCFILE(FILPAT)

        !write(3,*)' In getnewimg - nwant,locat:',nwant,locat,filpat

        IF (NWANT < 0) THEN
C          XMIPP SELFILE SIMPLE IMAGE ----------------------- SELAAA

C          GET PREVIOUS FILE SIZE AND TYPE (SHOULD BE SAME)
           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)           ! USUALLY STILL OPEN
 
C          LOAD FILE NAME FROM SELFILE
           CALL GETNEXT_XMSEL(LUNXM,.TRUE.,FILNAM,NLET,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

C          OPEN FILNAM
           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM(1:NLET),LUN,'U',ITYPE1,
     &                 NX1,NY1,NZ1, 
     & 		       MAXIM,'~9',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)

           NGOT = NWANT   
           RETURN

        ELSEIF (LOCAT <= 0 .AND. LOCAST > 1) THEN
C          TEMPLATED SIMPLE IMAGE --------------------------- IMG***

C          NEW IMAGE, NEEDS TO KNOW: ITYPE,NX,NY,NZ!
C          GET IT FROM OPFILES OR PREVIOUS CALL
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE,IRTFLG)
           CLOSE(LUN)   ! GET RID OF ANY OPEN IMAGE
 
C          CREATE FILE NAME
           CALL FILGET(FILPAT,FILNAM,NLET,NWANT,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           MAXIM = 0
           CLOSE(LUN)    ! MAY BE STILL OPEN FROM FIRST CALL  
	   CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUN,'U',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened new templated file: ',filnam(1:nlet)

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (IS_MRC .AND. LOCAT > 0 .AND. LOCAST < LOCAT) THEN

C          TEMPLATED STACKED MRC IMAGE ---------------------- **@@STK.mrc
C          BARE MRC IMAGE ------------------------------------ @@STK.mrc
           
           CALL GETNEWIMG_MRC(LUN,FILPAT,NWANT,SAYIT,
     &                        FILNAM,NGOT,IRTFLG)
           RETURN


        ELSEIF (LOCAT > 0) THEN
C          STACKED IMAGE ------------------------------- STK@@*  or STK@@

           CALL LUNGETISBARE(LUN,ISBARE,IRTFLG)

C          LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)
 
C          RETRIEVE CURRENT MAXIMUM IMAGE NUMBER FROM OVERALL HEADER
           CALL LUNGETMAXIM(LUN,MAXIM,IRTFLG)


           IF (NWANT > MAXIM) THEN
C             UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER
              CALL LUNSETMAXIM(LUN,NWANT,IRTFLG)
              CALL LUNSETMAXALL(LUN,NWANT,IRTFLG)
           ENDIF

C          NEED ISTACK 
           CALL LUNCOPYSTK(LUN,ISTACK,IRTFLGT)

           !write(6,*)' In getnewimg - isbare,filpat: ',isbare, filpat
           !write(6,*)' In getnewimg -nwant,maxim,istak: ',nwant,maxim,istack


          IF (ISTACK < 0) THEN
C             MAKING A NEW INDEXED STACKED FILE, UPDATE INDX LOCATION
              CALL LUNWRTINDX(LUN,NWANT,NX,IRTFLGT)
              IF (IRTFLGT .NE. 0) RETURN
           ENDIF

           IF (NWANT > MAXIM .OR. ISTACK > 2) THEN
C             SAVE OVERALL HEADER NOW TO PRESERVE MAXIM & LASTINDX
              CALL LUNWRTHED(LUN,NX,0,IRTFLGT)
              CALL LUNGETMAXIM(LUN,MAXIM,IRTFLG)
           ENDIF

C          GET FILENAM FROM CURRENT HEADER OBJECT
           CALL LUNGETFILE(LUN,FILNAM,NLET,DSP,IRTFLG)

C          SET NEW FILENAME IN HEADER OBJECT AND GET FILENAME
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'N',IRTFLG)
           NLET = lnblnkn(FILNAM)    ! MAY HAVE BEEN ALTERED

C          SET IMGNUM IN HEADER OBJECT
           CALL LUNSETINUSE(LUN,NWANT,IRTFLG)

C          PUT IMAGE ISTACK
           CALL LUNSETISTACK(LUN,0,IRTFLG)

C          PUT COMMON VALUES INTO COMMON AREA (NOT NEEDED IN FUTURE?)
           CALL LUNSETCOMMON(LUN,IRTFLG)

C          PUSH HEADER OBJECT INFO INTO NEW STACKED FILE
           CALL LUNWRTHED(LUN,NX,NWANT,IRTFLG)

C          SET OFFSETS FOR REDLIN/WRTLIN ON THIS LUN
           CALL LUNSETIMGOFF(LUN,NWANT,NX,IRTFLGT)

C          WRITE OUT FILE OPENING INFO TO SCREEN
           CALL LUNSAYINFO(LUN,IRTFLG)

           NGOT = NWANT

           !write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)

        ENDIF

	END


C++*********************************************************************
C
C  NEXTFILES.F  NEW                              12/15/06 ArDean Leith
C               OVERUN OUTPUT LIST = -99          1/15/12 ArDean Leith
C **********************************************************************
C
C NEXTFILES(NINDX1, NINDX2, INUMBR1,INUMBR2, 
C           FOUROK,NLIST1,NLIST2,   
C           NSTACK1,NSTACK2,   
C           LUN1,LUNCP,LUN2, FILPAT1,FILPAT2,
C           IMGNUM1,IMGNUM2,IRTFLG) 
C
C PURPOSE:  GETS NEXT INPUT AND OUTPUT FILES FOR A STACK ORIENTED 
C           OPERATION.  STACKS MUST BE OPENED WITH OPFILES!!!
C
C PARAMETERS: NINDX1,NINDX2    LIST INDICES                 (SENT/RET.)
C             INUMBR1,INUMR2   IMAGE NUMBER LISTS                (SENT)
C             FOUROK           FOURIER INPUT IS OK               (SENT)
C             LUNXM1,LUNXM2    LUN FOR SELFILE INPUT             (SENT)
C             NLIST1,NLIST2    NUMBER OF IMAGES                  (SENT)
C             NSTACK1,NSTACK2  MAX IMAGE IN STACK                (SENT)
C             LUN1             LUN FOR INPUT  (0 = NO FILE IN)   (SENT)
C             LUNCP            LUN FOR OUTPUT HEADER COPY        (SENT)
C             LUN2             LUN FOR OUTPUT (0 = NO FILE OUT)  (SENT)
C             FILPAT,FILPAT2   FILE NAME PATTERNS                (SENT)
C             IMGNUM1,IMGNUM2  IMAGE NUMBERS                (SENT/RET.)
C             IRTFLG           ERROR (0 IS OK, -1 IS END STACK)  (RET.)
C
C  CALL TREE:
C     AFTER OPFILES HAVE BEEN CALLED:
C
C       NEXTFILES 
C          |      
C          |      Old image
C          ` ---> GETOLDIMG    
C          |      
C          |      New image                         
C          ` ---> GETNEWIMG
C
C--*********************************************************************
 
      SUBROUTINE NEXTFILES(NINDX1, NINDX2, INUMBR1,INUMBR2, 
     &                     FOUROK,LUNXM1,LUNXM2,
     &                     NLIST1,NLIST2,   NSTACK1,NSTACK2,   
     &                     LUN1,LUNCP,LUN2, FILPAT1,FILPAT2,
     &                     IMGNUM1,IMGNUM2, IRTFLG) 
 
      IMPLICIT NONE

      INTEGER           :: NINDX1,NINDX2
      INTEGER           :: INUMBR1(NLIST1),INUMBR2(NLIST2)
      LOGICAL           :: FOUROK
      INTEGER           :: LUNXM1,LUNXM2
      INTEGER           :: NLIST1,NLIST2
      INTEGER           :: NSTACK1,NSTACK2,LUN1,LUNCP,LUN2
      CHARACTER(LEN=*)  :: FILPAT1,FILPAT2
      INTEGER           :: IMGNUM1,IMGNUM2,IRTFLG

      INTEGER           :: NWANT1,NWANT2, it
      LOGICAL           :: SAYIT = .TRUE.
      LOGICAL           :: GOTAST1, GOTAST2
      LOGICAL           :: IS_BARE1,IS_BARE2    

      NINDX1 = NINDX2 + 1
      NINDX2 = NINDX2 + 1

      IF (LUN1 > 0) THEN  
C        OPEN NEXT INPUT FILE 
         GOTAST1 = (INDEX(FILPAT1,'*') > 0)

C        IS THIS A BARE STACK OPERATION?  (OK FOR SPIDER & MRC)
         CALL LUNGETISBARE(LUN1,IS_BARE1,IRTFLG)

         IF (IMGNUM1 == -1 .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF ( IS_BARE1 ) THEN
C           MRC OR SPIDER BARE STACK INPUT   (NO LIST)

            IF (IMGNUM1 < 0) IMGNUM1 = 1
            NWANT1 = IMGNUM1 + 1
            IF (NWANT1 > NSTACK1) THEN
C              FINISHED THE WHOLE STACK
               IRTFLG = -1
               RETURN
            ENDIF

         ELSEIF (NSTACK1 == -2  .OR.
     &           NSTACK1 == -1  .OR.
     &           NSTACK1  >    0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED     IMAGE WITH/WITHOUT LIST         

            IF (NINDX1 > NLIST1) THEN
C              OVERUN INPUT LIST
               IRTFLG = -1
               RETURN
            ENDIF

C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)

         ENDIF

         !write(3,*)' In nextfiles, nwant1: ',nwant1
         !write(6,'(a,8i5)')' In nextfiles, nwant1: ',
         !                                  nwant1,lun1,nwant1,imgnum1
         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
     &                  FOUROK,IMGNUM1,IRTFLG)

         !write(3,*)' gotoldimg, nstacki1,gotast1: ',nstack1,gotast1

         IF (IRTFLG < 0)    RETURN    ! END OF WHOLE-STACK
         IF (IRTFLG .NE. 0) RETURN    ! ERROR

         IF (IS_BARE1) THEN
C           INPUT FROM A BARE STACK 
            NINDX1 = IMGNUM1
            NINDX2 = IMGNUM1
         ENDIF
      ENDIF
      ! write(6,*) 'In nextfiles1: l1,l2,irtflg:',lun1,lun2,irtflg


      IF (LUN2 > 0) THEN  
C        OPEN NEXT OUTPUT FILE 
         GOTAST2 = (INDEX(FILPAT2,'*') > 0)

C        IS THIS IS A BARE STACK OPERATION?  (OK FOR SPIDER & MRC)
         CALL LUNGETISBARE(LUN2,IS_BARE2,IRTFLG)


!        !write(6,'(a,8i5)')'  out: nindx2,ngot2,nstack2,imgnum2: ',
!     &                             nindx2,ngot2,nstack2,imgnum2
!         write(6,*) 'nextfiles2: l2,imgnum2,gotast2:',
!     &                         lun2,imgnum2,gotast2
         IF (IMGNUM2 == -1 .AND. LUNXM2 > 0  ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT2 = -1

         ELSEIF (LUN1 > 0 .AND. IS_BARE1 ) THEN
C           NON-STACK IMAGE WITH/WITHOUT TEMPLATE LIST 
C           MRC OR SPIDER BARE STACK INPUT   (NO LIST AVAILABLE)
C           BARE STACK INPUT , USE SAME  OUTPUT IMAGE NUMBER
            NWANT2 = IMGNUM1

            !write(3,*)'In nextfiles, :',isbare,nstack2,nwant2

         ELSEIF (IS_BARE2 ) THEN
C           MRC OR SPIDER BARE STACK OUTPUT   (NO LIST)
            IF (IMGNUM2 < 0) IMGNUM2 = 1
            NWANT2 = IMGNUM2 + 1

            IF (LUN1 > 0 .AND. IS_BARE1) THEN
C              BARE STACK INPUT , USE SAME  OUTPUT IMAGE NUMBER
                NWANT2 = IMGNUM1
            ENDIF

            !write(3,*)'In nextfiles, :',isbare,nstack2,nwant2


         ELSEIF (NSTACK2 == -2  .OR.
     &           NSTACK2 == -1  .OR.
     &           NSTACK2  >  0 ) THEN

C           NON-STACK IMAGE WITH/WITHOUT TEMPLATE LIST 
            IF (NINDX2 > NLIST2) THEN
C               OVERUN OUTPUT LIST
                !write(6,*) 'nindx2 > nlist2',nindx2,nlist2
                IRTFLG = -99
                RETURN
            ENDIF
C           OPEN NEXT OUTPUT FILE 
            NWANT2 = INUMBR2(NINDX2)
         ENDIF

         !write(3,*)' In nextfiles, nwant2,nindx2:',nwant2,nindx2
         !write(6,'(a,8i5)') 
         !& ' Calling getnew,nwant2,imgnum2,nstack2:',
         !                   nwant2,imgnum2,nstack2

         CALL GETNEWIMG(LUNCP,LUN2,LUNXM2,FILPAT2,NWANT2,
     &                  SAYIT,IMGNUM2,IRTFLG)

         !write(3,'(a,8i5)') ' Getnew,nwant2,imgnum2,nstack2,irtflg:',
      !&                              nwant2,imgnum2,nstack2,irtflg

         IF (IRTFLG .NE. 0) RETURN     ! ERROR

      ENDIF
      !write(3,'(a,5i5)')' In nextfiles, nlist1,nstack1,imgnum1:',
      !&                                 nlist1,nstack1,imgnum1
      !write(3,'(a,5i5)')' In nextfiles, ngot2,nstack2,imgnum2:',
      !&                                 ngot2,nstack2,imgnum2

      END


C++*********************************************************************
C
C NEXTFILE.F    NEW                              12/15/06 ArDean Leith
C               OVERUN OUTPUT LIST = -99          1/15/12 ArDean Leith
C               MRC SUPPORT                       8/22/19 ArDean Leith
C
C **********************************************************************
C
C NEXTFILE(NINDX1, INUMBR1, FOUROK, LUNXM1, NLIST1,   NSTACK1,   
C          LUN1,   LUNCP,   FILPAT1,  DISP, IMGNUM1, IRTFLG)  
C
C PURPOSE:  GETS NEXT INPUT OR OUTPUT FILE FOR BARE STACK INPUT,
C           A NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST, 
C           OR A  STACKED IMAGE WITH/WITHOUT LIST
C           STACKS MUST BE OPENED WITH OPFILES!!!
C
C PARAMETERS: NINDX1         LIST INDEX                    (SENT/RET.)
C             INUMBR1        IMAGE NUMBER LIST                  (SENT)
C             FOUROK         FOURIER INPUT IS OK                (SENT)
C             LUNXM1         LUN FOR SELFILE INPUT              (SENT)
C             NLIST1         NUMBER OF IMAGES IN LIST           (SENT)
C             NSTACK1        HIGHEST IMAGE IN STACK             (SENT)
C             LUN1           LUN FOR I/0                        (SENT)
C             LUNCP          LUN FOR OUTPUT HEADER COPY         (SENT)
C             FILPAT1        FILE NAME PATTERN                  (SENT)
C             DISP           IMAGE EXISTANCE                    (SENT)
C             IMGNUM1        IMAGE NUMBER                  (SENT/RET.)
C             IRTFLG         ERROR (0 IS OK, -1 IS END STACK)   (RET.)
C
C  CALL TREE:
C     AFTER OPFILES HAVE BEEN CALLED:
C
C       NEXTFILE 
C          |      
C          |      Old image
C          ` ---> GETOLDIMG    
C          |        |
C          |        |  Templated simple image:  IMG*** 
C          |        ` ---> FILGET --> OPFILEC  
C          |        |                         
C          |        |  Templated stacked image: STK@@*(**     
C          |        ` ---> LUN***
C          |        | 
C          |        |  Whole image stack:       STK@@  
C          |        ` ---> LUNS***
C          |        | 
C          |        |  Templated stacked MRC:  *@@MRC or *@@.MRCS
C          |        ` ---> GETOLDIMG_MRC --> OPFILEC  
C          |      
C          |      
C          |      New image                         
C          ` ---> GETNEWIMG
C                   |
C                   |  Templated simple image:  IMG*** 
C                   ` ---> FILGET --> OPFILEC  
C                   |                         
C                   |  Templated stacked image: STK@@*(**     
C                   ` ---> LUN***
C                   | 
C                   |  Whole image stack:       STK@@  
C                   ` ---> LUNS***  
C                   | 
C                   |  Templated stacked MRC:  *@@MRC or *@@.MRCS
C                   ` ---> GETNEWIMG_MRC --> OPFILEC  
C
C--*********************************************************************
 
      SUBROUTINE NEXTFILE(NINDX1,   INUMBR1, 
     &                    FOUROK,   LUNXM1,
     &                    NLIST1,   NSTACK1,   
     &                    LUN1,     LUNCP, 
     &                    FILPAT1,  DISP,
     &                    IMGNUM1,  IRTFLG) 
 
      IMPLICIT NONE

      INTEGER           :: NINDX1 
      INTEGER           :: INUMBR1(NLIST1) 
      LOGICAL           :: FOUROK
      INTEGER           :: LUNXM1 
      INTEGER           :: NLIST1 
      INTEGER           :: NSTACK1, LUN1,LUNCP 
      CHARACTER(LEN=*)  :: FILPAT1
      CHARACTER(LEN=1)  :: DISP
      INTEGER           :: IMGNUM1
      INTEGER           :: IRTFLG

      INTEGER           :: NWANT1, it
      LOGICAL           :: SAYIT = .TRUE.
      LOGICAL           :: GOTAST,IS_BARE1

      LOGICAL           :: ISMRCFILE    ! FUNCTION
      
      NINDX1 = NINDX1 + 1

      GOTAST = (INDEX(FILPAT1,'*') > 0)

C     IS THIS IS A BARE STACK OPERATION?
      CALL LUNGETISBARE(LUN1,IS_BARE1,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

C      write(3,*)' In nextfile, gotast, filpat1:  ', gotast,filpat1
C      write(6,*)' In nextfile, nindx1,isbare:    ',nindx1,is_bare1
C      write(3,*)' In nextfile, ----------------------: '
C      write(3,'(A,5i6)')
C     &         '  In nextfile, num1,nindx1,nlist1,nwant1,nstack1: ',
C     &                      imgnum1,nindx1,nlist1,nwant1,nstack1

      IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C        XMIPP SELFILE LISTED IMAGE
         NWANT1 = -1

      ELSEIF ( IS_BARE1 ) THEN
C        MRC OR SPIDER BARE STACK INPUT   (NO LIST)

         IF (IMGNUM1 < 0) IMGNUM1 = 1
         NWANT1 = IMGNUM1 + 1

C        write(3,'(A,5i6)')'  In nextfile, nwant1,nstack1: ',
C       &                                  nwant1,nstack1

        IF (NWANT1 > NSTACK1) THEN
C           FINISHED THE WHOLE STACK
            IRTFLG = -1
            RETURN
         ENDIF
          
      ELSEIF (NSTACK1 == -2  .OR.
     &        NSTACK1 == -1  .OR.
     &        NSTACK1  >    0 ) THEN
C        NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C        STACKED     IMAGE WITH/WITHOUT LIST
         IF (NINDX1 > NLIST1) THEN
C           OVERUN I/O LIST
            IRTFLG = -1
            RETURN
         ENDIF

C        OPEN NEXT I/O FILE 
         NWANT1 = INUMBR1(NINDX1)

      ENDIF

      !write(3,*)' In nextfile, nindx1,nlist1,nstack1,imgnum1: ',
      !     &                   nindx1,nlist1,nstack1,imgnum1
      !write(3,*)'  In nextfile, calling get, nwant1,imgnum1,nstack1:',
      !&                                      nwant1,imgnum1,nstack1

      IF (DISP == 'O' .OR. DISP == 'B' .OR. 
     &    DISP == 'Z' .OR. DISP == 'E') THEN 
  
C        OPEN NEXT INPUT FILE
         !write(3,*) ' Call gotoldimg, nwant1: ',nwant1,imgnum1
         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
     &                  FOUROK,IMGNUM1,IRTFLG)

         !write(3,*)' Gotoldimg, nlist1,nwant1,imgnum1: ',
         !&                      nlist1,nwant1,imgnum1,irtflg,nstack1

         IF (IRTFLG    < 0) RETURN    ! END OF WHOLE-STACK
         IF (IRTFLG .NE. 0) RETURN    ! ERROR

      ELSE   

C        OPEN NEXT OUTPUT FILE 
         !write(3,*) ' Call gotnewimg, nwant1: ',nwant1,imgnum1
         CALL GETNEWIMG(LUNCP,LUN1,LUNXM1,FILPAT1,NWANT1,
     &                  SAYIT,IMGNUM1,IRTFLG)

         !write(3,*) ' Getnewimg, nwant1,imgnum1,nstack1,irtflg:',
         !     &                  nwant1,imgnum1,nstack1,irtflg
         IF (IRTFLG .NE. 0) RETURN   ! ERROR

      ENDIF

      IF (IS_BARE1) THEN
C        BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
         NINDX1 = IMGNUM1
      ENDIF

      !   write(3,'(a,5i5)')' In nextfile, nlist1,nstack1,imgnum1:',
      !&                                   nlist1,nstack1,imgnum1
      END


@


1.36
log
@removed debug output
@
text
@d13 1
d40 3
a42 2
C          ITYPE,NX,NY,NZ,MAXIM, PROMPT,FOUROK,
C          ILIST,NIMAXT, NTOT,IMGNUM, IRTFLG)
d79 3
a81 4
C                       -2 NON-STACK IMAGE                
C                       -1 STACKED IMAGE                  
C                     >= 0 IS CURRENT MAX. IMAGE NO. FOR STACK             
C
d97 9
a105 1
C        UNUSED     UNUSED                                          (?)
a107 3
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN      (SENT/RET)
C                   ON INPUT: IF (BARESTACK) IS # WANTED
C                   ON OUTPUT:   <0 IS SELFILE IN USE 
d190 1
a190 1
       LOGICAL                   :: IS_MRC
d197 2
d235 1
d237 2
a238 2
       ASKLIST = (NIMAXT >= 0)
       NIMAXP  = ABS(NIMAXT)
d240 6
d253 11
a263 7
C         START WITH FIRST FILE IN STACK SERIES
          IMGWANT  = ILIST(1)
          IF (IMGWANT < 0 .OR. IMGWANT > 10000000) THEN
             CALL ERRT(102,'INVALID IMAGE NUMBER',IMGWANT)
             IRTFLG = 1
             RETURN
          ENDIF
d269 10
a278 3
       IMGNUMIN = IMGNUM
       IMGNUM   = 0 
       !write(6,*) ' In opfiles - imgnum 0: ',imgnum
d283 1
d289 1
a289 2
     &                     FOUROK,ILIST,NIMAXT, 
     &                     NTOT,IMGWANT, IRTFLG) 
a290 1
          !write(3,*)' In opfiles, maxim,ntot,imgwant: ',maxim,ntot,imgwant
d296 4
d956 2
a957 2
C           FOUROK,NGOT1,NGOT2,   
C           MAXIM1,MAXIM2,   
d968 2
a969 2
C             NGOT1,NGOT2      # OF IMAGES                       (SENT)
C             MAXIM1,MAXIM2    MAXIM VALUES                      (SENT)
d992 1
a992 1
     &                     NGOT1,NGOT2,     MAXIM1,MAXIM2,   
d994 1
a994 1
     &                     IMGNUM1,IMGNUM2,IRTFLG) 
d999 1
a999 1
      INTEGER           :: INUMBR1(NGOT1),INUMBR2(NGOT2)
d1002 2
a1003 2
      INTEGER           :: NGOT1,NGOT2
      INTEGER           :: MAXIM1,MAXIM2,LUN1,LUNCP,LUN2
d1009 2
a1010 3
      LOGICAL           :: GOTAST1,GOTAST2,IS_MRC1,IS_MRC2,IS_BARE1    

      LOGICAL           :: ISMRCFILE    ! FUNCTION
a1017 1
         IS_MRC1 = ISMRCFILE(FILPAT1)
d1019 1
a1019 1
C        IS THIS IS A BARE STACK OPERATION?  (OK FOR SPIDER & MRC)
d1026 2
a1027 14
         ELSEIF (IS_MRC1 .AND. IS_BARE1 .AND. MAXIM1 >= 0 .AND. 
     &           .NOT. GOTAST1 ) THEN
C           MRC BARE STACK INPUT   (NO LIST)
            NWANT1 = IMGNUM1 + 1
            !write(3,*) 'In nextfiles, :',is_mrc1,isbare,maxim1,nwant1

            IF (NWANT1 > MAXIM1) THEN
C              FINISHED THE WHOLE MRC BARE STACK
               IRTFLG = -1
               RETURN
            ENDIF

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST1 ) THEN
C           BARE STACK INPUT (NO LIST)
d1029 1
d1031 1
a1031 1
            IF (NWANT1 > NGOT1) THEN
d1037 3
a1039 3
         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >    0 ) THEN
d1043 1
a1043 1
            IF (NINDX1 > NGOT1) THEN
d1055 2
a1056 2
         !write(6,'(a,8i5)')' In nextfiles, nwant1: ',nwant1
         !&                                   lun1,nwant1,imgnum1
d1060 1
a1060 1
         !write(3,*)' gotoldimg, maximi1,gotast1: ',maxim1,gotast1
d1065 1
a1065 1
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST1) THEN
d1071 2
a1072 1
           ! write(6,*) 'nextfiles1: l1,l2,irtflg:',lun1,lun2,irtflg
a1076 1
         IS_MRC2 = ISMRCFILE(FILPAT2)
d1078 6
a1083 2
!        !write(6,'(a,8i5)')'  out: nindx2,ngot2,maxim2,imgnum2: ',
!     &                             nindx2,ngot2,maxim2,imgnum2
d1090 9
a1098 1
         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST2 ) THEN
d1100 2
a1101 1
            NWANT2 = NINDX2
d1103 3
a1105 5
            IF (LUN1 > 0) THEN
C              BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
               !NWANT2 = IMGNUM1
C              BARE STACK, INCREMENT OUTPUT IMAGE NUMBER
               NWANT2 = IMGNUM2 + 1
d1108 2
a1109 1
            !write(3,*)'In nextfiles, :',isbare,maxim2,nwant2
d1111 3
a1113 3
         ELSEIF (MAXIM2 == -2  .OR.
     &           MAXIM2 == -1  .OR.
     &           MAXIM2  >  0 ) THEN
d1116 1
a1116 1
            IF (NINDX2 > NGOT2) THEN
d1118 1
a1118 1
                !write(6,*) 'NINDX2 > NGOT2',NINDX2,NGOT2
d1128 2
a1129 1
         !& ' Calling getnew,nwant2,imgnum2,maxim2:',nwant2,imgnum2,maxim2
d1134 2
a1135 2
         !write(3,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
      !&                               nwant2,imgnum2,maxim2,irtflg
d1140 4
a1143 4
      !write(3,'(a,5i5)')' In nextfiles, ngot1,maxim1,imgnum1:',
      !&                                     ngot1,maxim1,imgnum1
      !   write(3,'(a,5i5)')' In nextfiles, ngot2,maxim2,imgnum2:',
      !&                                     ngot2,maxim2,imgnum2
d1156 1
a1156 1
C NEXTFILE(NINDX1, INUMBR1, FOUROK, LUNXM1, NGOT1,   MAXIM1,   
d1164 2
a1165 2
C PARAMETERS: NINDX1         LIST INDICES                  (SENT/RET.)
C             INUMBR1        IMAGE NUMBER LISTS                 (SENT)
d1168 2
a1169 2
C             NGOT1          # OF IMAGES WANTED                 (SENT)
C             MAXIM1         MAXIM VALUES                       (SENT)
d1217 1
a1217 1
     &                    NGOT1,    MAXIM1,   
d1225 1
a1225 1
      INTEGER           :: INUMBR1(NGOT1) 
d1228 2
a1229 2
      INTEGER           :: NGOT1 
      INTEGER           :: MAXIM1, LUN1,LUNCP 
d1237 1
a1237 1
      LOGICAL           :: GOTAT,GOTAST,IS_MRC,IS_BARE
a1242 1
      GOTAT  = (INDEX(FILPAT1,'@@') > 0)
a1243 1
      IS_MRC = ISMRCFILE(FILPAT1)
d1246 1
a1246 1
      CALL LUNGETISBARE(LUN1,IS_BARE,IRTFLG)
d1249 6
a1254 5
      !write(3,*)' In nextfile, gotast, filpat1:  ', gotast,filpat1
      !write(6,*)' In nextfile, nindx1,isbare:    ',nindx1,is_bare
      !write(6,*)' In nextfile, ngot1,imgnum1,nwant1,maxim1 1: ',
      !&                        ngot1,imgnum1,nwant1,maxim1
      !write(3,*)' In nextfile, nindx1,ngot1: ', nindx1,ngot1
d1260 4
a1263 8
      ELSEIF (IS_MRC .AND. .NOT. IS_BARE .AND. NINDX1 > NGOT1) THEN
C        MRC STACKED IMAGE I/O , OVERUN I/O LIST
         IRTFLG = -1
         RETURN
          
      ELSEIF (IS_MRC .AND. IS_BARE .AND. MAXIM1 >= 0 .AND.
     &        .NOT. GOTAST ) THEN
C        MRC BARE STACK I/O   (NO LIST)
a1264 6
          
         IF (NWANT1 > MAXIM1) THEN
C           FINISHED THE WHOLE MRC BARE STACK
            IRTFLG = -1
            RETURN
         ENDIF
d1266 2
a1267 2
      ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C        BARE STACK I/O (NO LIST)
d1269 1
a1269 2
         NWANT1 = IMGNUM1 + 1
         IF (NWANT1 > NGOT1) THEN
d1274 4
a1277 5
         !write(3,*' In nextfile, nindx1,nwant1: ', nindx1,nwant1

      ELSEIF (MAXIM1 == -2  .OR.
     &        MAXIM1 == -1  .OR.
     &        MAXIM1  >    0 ) THEN
d1279 2
a1280 2
C        STACKED IMAGE WITH/WITHOUT LIST
         IF (NINDX1 > NGOT1) THEN
d1291 4
a1294 4
      !write(3,*)' In nextfile, nindx1,ngot1,maxim1,imgnum1: ',
      !     &                   nindx1,ngot1,maxim1,imgnum1
      !write(3,*) 'In nextfile, Calling Get, nwant1,imgnum1,maxim1:',
      ! &                                    nwant1,imgnum1,maxim1
d1304 2
a1305 2
         !write(3,*)' Gotoldimg, ngot1,nwant1,imgnum1: ',
         !&                      ngot1,nwant1,imgnum1,irtflg,maxim1
d1307 1
a1307 1
         IF (IRTFLG .LT. 0) RETURN    ! END OF WHOLE-STACK
d1317 2
a1318 2
         !write(3,*) ' Getnewimg, nwant1,imgnum1,maxim1,irtflg:',
         !     &                  nwant1,imgnum1,maxim1,irtflg
d1323 1
a1323 1
      IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
d1328 2
a1329 2
      !   write(3,'(a,5i5)')' In nextfile, ngot1,maxim1,imgnum1:',
      !&                                    ngot1,maxim1,imgnum1
@


1.35
log
@removed debug output
@
text
@d1111 4
a1114 4
         write(3,'(a,5i5)')' In nextfiles, ngot1,maxim1,imgnum1:',
     &                                     ngot1,maxim1,imgnum1
         write(3,'(a,5i5)')' In nextfiles, ngot2,maxim2,imgnum2:',
     &                                     ngot2,maxim2,imgnum2
d1312 2
a1313 2
         write(3,'(a,5i5)')' In nextfile, ngot1,maxim1,imgnum1:',
     &                                    ngot1,maxim1,imgnum1
@


1.34
log
@reverted to pre nextfile bug
@
text
@d404 1
a404 3
        write(3,*)' Opened bare stack:',filpat(1:nlet),' img:',imgnum
        write(3,*)' Opened bare stack, maxim,imgnum',maxim,imgnum

d980 1
a980 2
      LOGICAL           :: GOTAST1,GOTAST2,IS_MRC1,IS_MRC2     
      LOGICAL           :: IS_BARE1,IS_BARE2    
a993 4
         IF (IRTFLG .NE. 0) RETURN

         !write(3,'(a,8i5)')' In nextfiles: nindx1,ngot1,maxim1,imgnum1: ',
         !&                                 nindx1,ngot1,maxim1,imgnum1
d999 3
a1001 2
         ELSEIF (IS_BARE1) THEN
C           BARE STACK INPUT   (NO LIST)
d1006 11
a1016 1
C              FINISHED THE WHOLE BARE STACK
d1049 1
a1049 1
         IF (IS_BARE1) THEN
a1061 4
C        IS THIS IS A BARE STACK OPERATION?  (OK FOR SPIDER & MRC)
         CALL LUNGETISBARE(LUN2,IS_BARE2,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

d1070 1
a1070 1
         ELSEIF (IS_BARE2) THEN
d1072 8
d1081 1
a1081 2
            NWANT2 = IMGNUM2 + 1
            !write(3,*)'In nextfiles, :',is_bare2,maxim2,nwant2
d1111 4
a1114 4
      !   write(3,'(a,5i5)')' In nextfiles, ngot1,maxim1,imgnum1:',
      !&                                     ngot1,maxim1,imgnum1
      !   write(3,'(a,5i5)')' In nextfiles, ngot2,maxim2,imgnum2:',
      !&                                     ngot2,maxim2,imgnum2
d1223 1
d1226 5
a1230 3
      !write(3,*)' In nextfile, nindx1,ngot1: ',  nindx1,ngot1
      !write(3,*)' In nextfile, nindx1,isbare: ', nindx1,is_bare
 
d1232 1
a1232 2
C     HANDLE MRC IO
      IF (IS_MRC .AND. .NOT. IS_BARE .AND. NINDX1 > NGOT1) THEN
d1236 37
d1281 2
a1282 36
     &    DISP == 'Z' .OR. DISP == 'E') THEN    ! --------INPUT ------- 

C        SET FOR NEXT INPUT FILE 
         !write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
c     &                              nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK INPUT (NO LIST)
             IF (NINDX1 > NGOT1) THEN
C              FINISHED THE WHOLE STACK
               IRTFLG = -1
               RETURN
            ENDIF
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >    0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C              OVERUN INPUT LIST
               IRTFLG = -1
               RETURN
            ENDIF

C           SET FOR NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)

         ENDIF
         !write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1

d1284 1
d1294 1
a1294 32
      ELSE    ! -------------------- OUTPUT ---------------------- 

C        SET FOR NEXT OUTPUT FILE 
         !write(6,'(a,8i5)')'  out: nindx1,ngot1,maxim1,imgnum1: ',
c     &                            nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK OUTPUT (NO LIST)
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >  0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C               OVERUN OUTPUT LIST
                !write(6,*) 'NINDX1 > NGOT1',NINDX1,NGOT1
                IRTFLG = -99
                RETURN
            ENDIF
            NWANT1 = INUMBR1(NINDX1)

         ENDIF

         !write(6,*) ' Nextfiles, nwant1,nindx1:',nwant1,nindx1
         !write(6,'(a,8i5)') 
c     &   ' calling Getnew,nwant1,imgnum1,maxim1:',nwant1,imgnum1,maxim1
d1307 2
a1308 2
      IF (IS_BARE) THEN
C        BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT 
d1312 2
a1313 3
      !  write(3,'(a,5i5)')' In nextfile, ngot1,maxim1,imgnum1:',
      !&                                  ngot1,maxim1,imgnum1

@


1.33
log
@comments
@
text
@d404 3
a406 1
          !write(3,*)' Opened bare stack:',filpat(1:nlet),' img:',imgnum
a1215 1
      !write(6,*)' In nextfile, nindx1,isbare:    ',nindx1,is_bare
d1218 3
a1220 1
      !write(3,*)' In nextfile, nindx1,ngot1: ', nindx1,ngot1
d1222 2
a1223 5
      IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C        XMIPP SELFILE LISTED IMAGE
         NWANT1 = -1

      ELSEIF (IS_MRC .AND. .NOT. IS_BARE .AND. NINDX1 > NGOT1) THEN
a1226 27
          
      ELSEIF (IS_BARE) THEN
C        BARE STACK I/O   (NO LIST)
         NWANT1 = IMGNUM1 + 1
          
         IF (NWANT1 > MAXIM1) THEN
C           FINISHED WHOLE BARE STACK
            IRTFLG = -1
            RETURN
         ENDIF

         !write(3,*' In nextfile, nindx1,nwant1: ', nindx1,nwant1

      ELSEIF (MAXIM1 == -2  .OR.
     &        MAXIM1 == -1  .OR.
     &        MAXIM1  >    0 ) THEN
C        NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C        STACKED IMAGE WITH/WITHOUT LIST
         IF (NINDX1 > NGOT1) THEN
C           OVERUN I/O LIST
            IRTFLG = -1
            RETURN
         ENDIF

C        OPEN NEXT I/O FILE 
         NWANT1 = INUMBR1(NINDX1)

d1235 36
a1270 2
     &    DISP == 'Z' .OR. DISP == 'E') THEN 
  
d1281 32
a1312 1
      ELSE   
d1332 1
@


1.32
log
@simplified nextfile, nextfiles for whole stack code
@
text
@d1233 1
a1233 1
C           FINISHED THE WHOLE MRC BARE STACK
a1264 1
         !write(3,*) ' Call gotoldimg, nwant1: ',nwant1,imgnum1
@


1.31
log
@date
@
text
@a852 7
!           IF (ISBARE) THEN
!C             WANT NEXT IMAGE IN STACK, GET CURRENT FILE NUMBER 
!              CALL LUNGETINUSE(LUN,NWANT,IRTFLG)
!              NWANT = NWANT + 1
!              IF (NWANT <= 0) NWANT = 1
!           ENDIF

d980 2
a981 1
      LOGICAL           :: GOTAST1,GOTAST2,IS_MRC1,IS_MRC2,ISBARE    
a987 2
      CALL LUNGETISBARE(LUN1,ISBARE,IRTFLG)

d993 6
a998 2
c         write(3,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
c     &                              nindx1,ngot1,maxim1,imgnum1
d1004 2
a1005 3
         ELSEIF (IS_MRC1 .AND. ISBARE .AND. MAXIM1 >= 0 .AND. 
     &           .NOT. GOTAST1 ) THEN
C           MRC BARE STACK INPUT   (NO LIST)
d1010 1
a1010 11
C              FINISHED THE WHOLE MRC BARE STACK
               IRTFLG = -1
               RETURN
            ENDIF

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST1 ) THEN
C           BARE STACK INPUT (NO LIST)

            NWANT1 = IMGNUM1 + 1
            IF (NWANT1 > NGOT1) THEN
C              FINISHED THE WHOLE STACK
d1043 1
a1043 1
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST1) THEN
d1056 4
d1068 1
a1068 1
         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST2 ) THEN
a1069 1
            NWANT2 = NINDX2
d1071 2
a1072 8
            IF (LUN1 > 0) THEN
C              BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
               !NWANT2 = IMGNUM1
C              BARE STACK, INCREMENT OUTPUT IMAGE NUMBER
               NWANT2 = IMGNUM2 + 1
            ENDIF

            !write(3,*)'In nextfiles, :',isbare,maxim2,nwant2
d1102 5
a1106 1
 
d1228 2
a1229 3
      ELSEIF (IS_MRC .AND. IS_BARE .AND. MAXIM1 >= 0 .AND.
     &        .NOT. GOTAST ) THEN
C        MRC BARE STACK I/O   (NO LIST)
a1237 9
      ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C        BARE STACK I/O (NO LIST)

         NWANT1 = IMGNUM1 + 1
         IF (NWANT1 > NGOT1) THEN
C           FINISHED THE WHOLE STACK
            IRTFLG = -1
            RETURN
         ENDIF
d1288 2
a1289 2
      IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C        BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
d1293 2
@


1.30
log
@bare stacks starting img bug fix
@
text
@d18 1
a18 1
C=* Copyright 1985-2019  Health Research Inc.,                         *
@


1.29
log
@MRC OR SPIDER BARE STACK OUTPUT   (NO LIST)
@
text
@d404 1
a404 1
          !write(6,*)' Opened bare stack:',filpat(1:nlet),' img:',imgnum
d406 1
a406 1
          !write(3,*)' Opened imgwant,ntot:',imgwant,ntot
d419 1
a419 1
C         SUBSTITUE IMGNUM INTO FILPAT 
d1023 2
a1024 1
            IF (NINDX1 > NGOT1) THEN
a1028 1
            NWANT1 = NINDX1
d1242 2
a1243 1
      ELSEIF (IS_MRC .AND. GOTAT .AND. .NOT. GOTAST ) THEN
d1256 2
a1257 1
         IF (NINDX1 > NGOT1) THEN
a1261 1
         NWANT1 = NINDX1
@


1.28
log
@more changes for mrc support
@
text
@d1012 1
a1022 1
 
d1079 2
a1080 2
         ELSEIF (IS_MRC2 .AND. MAXIM2 >= 0 .AND. .NOT. GOTAST2 ) THEN
C           MRC BARE STACK OUTPUT   (NO LIST)
d1085 3
a1087 1
               NWANT2 = IMGNUM1
d1090 1
a1090 8
         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST2 ) THEN
C           SPIDER BARE STACK OUTPUT (NO LIST)
            NWANT2 = NINDX2

            IF (LUN1 > 0) THEN
C              BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
               NWANT2 = IMGNUM1
            ENDIF
@


1.27
log
@replaced 'OPEN FIRST FILE IN STACK SERIES' clause that got lost somehow
@
text
@d44 4
a47 1
C           WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
d71 12
a82 6
C        ITYPE      IFORM FOR FILE                         (SENT OR RET) 
C        NX,NY,NZ   IMAGE SIZE                             (SENT OR RET)
C        MAXIM      STACK INDICATOR IF DISP == 'I'                (SENT)
C                   STACK INDICATOR                               (RET)
C        PROMPT     PROMPT FOR FILNAME                            (SENT)
C                     IF NOT (ASKNAM) THIS IS FILE NAME           (SENT)
d90 1
a90 1
C        FOUROK     CAN USE EXISTING FOURIER FILES?               (SENT)
d94 1
a94 1
C        NIMAXT     MAX LENGTH OF IMAGE NUMBER LIST               (SENT)
d99 1
a99 1
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN       (SENT/RET)
d104 1
d224 1
a224 1
       !write(3,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d757 2
d770 9
a778 1
        LOGICAL                :: FOUROK,ISBARE
d784 1
d786 1
a786 1
        !write(6,*)' In getnewimg - nwantt:',nwantt
d841 1
d847 1
d999 1
a999 1
         IS_MRC1  = ISMRCFILE(FILPAT1)
d1021 2
d1047 1
a1047 2
         !write(3,*)' In nextfiles, nwant1!!!!!!!: ',nwant1

d1053 1
a1053 2
         !write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
         !     &                         lun1,nwant1,imgnum1
d1080 2
a1081 2
C           MRC BARE STACK INPUT   (NO LIST)
            NWANT2 = IMGNUM2 + 1
d1083 3
a1085 4
            IF (NWANT2 > MAXIM2) THEN
C              FINISHED THE WHOLE MRC BARE STACK
               IRTFLG = -1
               RETURN
d1089 1
a1089 1
C           BARE STACK OUTPUT (NO LIST)
d1119 3
a1121 2
         ! write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
         !     &         nwant2,imgnum2,maxim2,irtflg
@


1.26
log
@mrc_support
@
text
@d242 1
d281 2
d290 13
d309 3
d314 3
d375 1
a375 1

d395 1
a395 1
          !write(3,*)' Opened imgnum, stack:',imgnum,filpat(1:nlet)
d397 1
a397 1
         
d605 1
a605 2
           !write(6,*)' Opened old templated file: ',
           !           filnam(1:nlet),maxim
d710 1
a710 1
C  PURPOSE:       TO OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
d730 1
a730 1
C          |  Templated simple image: IMG*** 
d733 1
a733 1
C          |  Templated stacked image: STK@@*(**     
d765 1
a765 1
        !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d811 1
a811 1
           !write(6,*)' Opened new templated file: ',FILNAM(1:NLET)
d829 1
d844 1
d854 4
d1024 2
a1025 2
!         write(6,'(a,8i5)')' In nextfiles, nwant1: ',nwant1
!     &                                   lun1,nwant1,imgnum1
d1030 1
a1030 1
!     &                                   lun1,nwant1,imgnum1
d1092 1
a1092 1
!     &   ' Calling getnew,nwant2,imgnum2,maxim2:',nwant2,imgnum2,maxim2
d1098 1
a1098 1
!     &                                nwant2,imgnum2,maxim2,irtflg
@


1.25
log
@email_health_dept
@
text
@d3 10
a12 8
C                                                                      *
C  OPFILES.F   NEW                            12/15/06  ARDEAN LEITH    
C              BAD NUMBRT() TRAP              05/21/09  ARDEAN LEITH  
C              ASKNAM, PROMPTEX               12/06/10  ARDEAN LEITH 
C              NX...                          03/26/12  ARDEAN LEITH 
C              COPY NON SPIDER INPUT          05/26/14  ARDEAN LEITH 
C              COPY NON SPIDER INPUT          05/26/14  ARDEAN LEITH 
C              LOCAST, ASKLIST FOR ILIST      10/02/14  ARDEAN LEITH
d18 1
a18 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d96 40
d146 1
d154 1
a154 1
       CHARACTER(LEN=1)          :: DISP 
d159 1
a159 1
       INTEGER                   :: NIMAXT,NDUM,NTOT,IMGNUM, IRTFLG
d161 4
a164 1
       INTEGER                   :: NIMAXP
d166 2
a167 2
       CHARACTER (LEN=1)         :: CDUM 
       CHARACTER (LEN=MAXNAM)    :: FILNAM 
d170 1
d174 2
a175 1
       INTEGER                   :: LUNOP,NLETT
d177 1
a177 2
       LOGICAL                   :: ISOPEN,GOTFILE
       CHARACTER (LEN=MAXNAM)    :: FILNAMT 
a210 3
       IMGNUMIN = IMGNUM
       IMGNUM   = 0 
     
d214 2
a215 2
       !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
       !write(6,*)' ILIST:',ILIST(1)
a220 1
       !!IF (ASKNAM .AND. LOCAST > 0 .AND. ASKLIST) THEN
d227 9
d240 20
a262 1
C         OPEN STACK HEADER
d264 1
a264 2
          MAXIM  = 1  
             
d266 1
a274 1
                !CALL ERRT(102,MESG(1:LENE),LUNOP) 
d280 2
d286 2
a289 8
C         OPEN FIRST FILE IN STACK SERIES
          IMGWANT  = ILIST(1)
          IF (IMGWANT < 0 .OR. IMGWANT > 10000000) THEN
              CALL ERRT(102,'INVALID IMAGE NUMBER',IMGWANT)
              IRTFLG = 1
              GOTO 9000
          ENDIF

d292 1
d296 3
a298 2
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGWANT,SAYIT,
     &                      FOUROK,IMGNUM,IRTFLG)
d305 3
a307 3
          !write(6,'(A,A,A,i6,a,i6,a,i6)')' Opened templated stack: ',
!     &          FILPAT(1:nlet),' At image: ',IMGNUM, 
!     &          '  Maxim: ',maxim
d372 3
a374 1
         !write(6,*)' Opened bare stack:',FILPAT(1:NLET),' Img:',IMGNUM
d379 1
a379 1
C         OPEN FIRST FILE IN THE SERIES
d386 2
d391 1
d398 2
a399 2
          !write(6,*)' Opened templated file: ',FILPAT(1:NLET),
      !&              '  for:',NTOT,' images.'
d402 1
a402 1
C         SINGLE SIMPLE INPUT FILE: IMG001 --------------------- IMG001
d407 1
a407 1
          IF (LUNXM > 0) THEN
d430 2
d444 1
a444 1
          !write(6,*)' Opened simple file: ',FILPAT(1:nlet) 
d452 4
d458 1
a458 1
C GETOLDIMG.F   FROM GETNXTSTK                     JAN 02 ARDEAN LEITH
d481 16
d518 1
d525 4
d583 2
a584 1
           !write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim
d590 10
d601 1
a601 1
C          TEMPLATED STACKED IMAGE ---------------------------- STK@@***
d687 1
a687 1
C    GETNEWIMG(LUNCP,LUN,LUNXM,FILPAT,NWANTT, SAYIT,NGOT,IRTFLG)
d689 2
a690 2
C    PURPOSE:       TO OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
C                   ACCESS READING/WRITING.
d692 28
a719 12
C    PARAMETERS:
C        LUNCP      UNIT NUMBER FOR HEADER TXT COPY               (SENT)
C        LUN        UNIT NUMBER FOR FILNAM.                       (SENT)
C        LUNXM      UNIT NUMBER FOR XM SELFILE                    (SENT)
C        FILPAT     FILENAME PATTERN                              (SENT)
C        NWANT      IMAGE NUMBER WANTED                           (SENT) 
C        SAYIT      SAY FILE OPENING INFO                         (SENT)
C        NGOT       IMAGE NUMBER FOUND                            (RET.) 
C        IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                   IRTFLG = -1    END OF FILE BEFORE NWANT
C                   IRTFLG =  0    NORMAL RETURN, IMAGE IS STACK
C                   IRTFLG =  2    IMAGE NOT IN USE
d796 8
a876 2


d879 2
a880 2
C  NEXTFILES.F  NEW                              12/15/06 ARDEAN LEITH
C               OVERUN OUTPUT LIST = -99          1/15/12 ARDEAN LEITH
d889 2
a890 2
C PURPOSE:  GETS NEXT FILES FOR A STACK ORIENTED OPERATION
C           STACKS MUST BE OPENED WITH OPFILES!!!
d892 1
a892 1
C PARAMETERS: NINDX1,NINDX2    LIST INDICES                   (SENT/RET)
d902 1
a902 1
C             IMGNUM1,IMGNUM2  IMAGE NUMBERS                  (SENT/RET)
d904 12
d937 3
a939 2
      LOGICAL           :: GOTAST1,GOTAST2
      
d944 2
a945 1
      !write(6,*) 'nextfiles0  : l1,l2:',lun1,lun2
d949 1
d951 2
a952 2
         !write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
!     &                              nindx1,ngot1,maxim1,imgnum1
d958 11
d971 1
a971 1
             IF (NINDX1 > NGOT1) THEN
d982 2
a983 1
C           STACKED IMAGE WITH/WITHOUT LIST
d995 4
d1005 1
a1005 1
         IF (IRTFLG .LT. 0) RETURN    ! END OF WHOLE-STACK
d1019 1
d1021 1
a1021 1
         !write(6,'(a,8i5)')'  out: nindx2,ngot2,maxim2,imgnum2: ',
d1023 2
a1024 3

!            write(6,*) 'nextfiles2: l2,imgnum2,gotast2:',
!     &                              lun2,imgnum2,gotast2
d1029 10
d1063 1
a1063 1
         !write(6,*) ' nextfiles, nwant2,nindx2:',nwant2,nindx2
d1070 1
a1070 1
          !write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
d1075 1
a1075 1

d1081 3
a1083 2
C NEXTFILE.F    NEW                              12/15/06 ARDEAN LEITH
C               OVERUN OUTPUT LIST = -99          1/15/12 ARDEAN LEITH
d1087 2
a1088 1
C NEXTFILE  
d1090 3
a1092 1
C PURPOSE:  GETS NEXT FILE FOR A STACK ORIENTED OPERATION
d1095 49
a1143 12
C PARAMETERS: NINDX1           LIST INDICES                   (SENT/RET)
C             INUMBR1          IMAGE NUMBER LISTS                (SENT)
C             FOUROK           FOURIER INPUT IS OK               (SENT)
C             LUNXM1           LUN FOR SELFILE INPUT             (SENT)
C             NGOT1            # OF IMAGES                       (SENT)
C             MAXIM1           MAXIM VALUES                      (SENT)
C             LUN1             LUN FOR I/0                       (SENT)
C             LUNCP            LUN FOR OUTPUT HEADER COPY        (SENT)
C             FILPAT1          FILE NAME PATTERN                 (SENT)
C             DISP             IMAGE EXISTANCE                   (SENT)
C             IMGNUM1          IMAGE NUMBER                   (SENT/RET)
C             IRTFLG           ERROR (0 IS OK, -1 IS END STACK)  (RET.)
a1154 1
      LOGICAL           :: ISIN
d1162 1
a1163 1
      CHARACTER(LEN=1)  :: DISP
d1168 3
a1170 1
      LOGICAL           :: GOTAST
d1172 1
d1174 1
a1174 1
      NINDX1 = NINDX1 + 1
d1176 33
d1210 7
a1216 6
      IF (DISP == 'O' .OR. DISP == 'B' .OR. 
     &    DISP == 'Z' .OR. DISP == 'E') THEN 
 
C        OPEN INPUT FILE 
         !write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
c     &                              nindx1,ngot1,maxim1,imgnum1
d1218 10
a1227 3
         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1
d1229 2
a1230 8
         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK INPUT (NO LIST)
             IF (NINDX1 > NGOT1) THEN
C              FINISHED THE WHOLE STACK
               IRTFLG = -1
               RETURN
            ENDIF
            NWANT1 = NINDX1
d1232 1
a1232 10
         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >    0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C              OVERUN INPUT LIST
               IRTFLG = -1
               RETURN
            ENDIF
d1234 4
a1237 2
C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)
d1239 5
a1243 3
         ENDIF
         !write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
 
d1247 2
a1248 2
         !write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
c     &                           ngot1,nwant1,imgnum1,irtflg,maxim1
d1253 1
a1253 4
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK 
            NINDX1 = IMGNUM1
         ENDIF
a1254 1
      ELSE   
d1256 1
a1256 30
         !write(6,'(a,8i5)')'  out: nindx1,ngot1,maxim1,imgnum1: ',
c     &                            nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK OUTPUT (NO LIST)
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >  0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C               OVERUN OUTPUT LIST
                !write(6,*) 'NINDX1 > NGOT1',NINDX1,NGOT1
                IRTFLG = -99
                RETURN
            ENDIF
C           OPEN NEXT OUTPUT FILE 
            NWANT1 = INUMBR1(NINDX1)
         ENDIF

         !write(6,*) ' Nextfiles, nwant1,nindx1:',nwant1,nindx1
         !write(6,'(a,8i5)') 
c     &   ' calling Getnew,nwant1,imgnum1,maxim1:',nwant1,imgnum1,maxim1

d1260 5
a1264 3
         !write(6,'(a,8i5)') ' Getnew,nwant1,imgnum1,maxim1,irtflg:',
!     &                              nwant1,imgnum1,maxim1,irtflg
         IF (IRTFLG .NE. 0) RETURN     ! ERROR
d1266 3
a1268 4
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
            NINDX1 = IMGNUM1
         ENDIF
@


1.24
log
@LOCAST, ASKLIST  RULES FOR USING SENT ILIST
@
text
@d18 1
a18 1
C=* Email: spider@@wadsworth.org                                        *
@


1.23
log
@comments
@
text
@d4 8
a11 5
C  OPFILES.F        NEW                         12/15/06  ARDEAN LEITH *   
C                   BAD NUMBRT() TRAP           05/21/09  ARDEAN LEITH * 
C                   ASKNAM, PROMPTEX            12/06/10  ARDEAN LEITH *
C                   NX...                       03/26/12  ARDEAN LEITH *
C                   COPY NON SPIDER INPUT       05/26/14  ARDEAN LEITH *
a71 2
C                     ~ (TILDE) IN FIRST CHAR. SAYS USE
C                       PROMPT INSTEAD OF INPUT
d177 2
a178 1
       IF (ASKNAM .AND. LOCAST > 0 .AND. ASKLIST) THEN
@


1.22
log
@==, RETURN FILENAME WITH ANY EXTENSION IF NOT SPIDER, use input prompt
@
text
@d47 16
a62 3
C        FILPAT     FILE NAME PATTERN                              (RET)
C        NLET       CHARS IN FILE NAME PATTERN                     (RET)
C        DISP       CHAR. FLAG FOR FILE EXISTENCE                 (SENT)
d66 1
a66 1
C                   STACK INDICATOR                                (RET)
d79 2
a80 1
C        ILIST      IMAGE NUMBER LIST                              (RET)
d84 2
a85 2
C        UNUSED     UNUSED                                           (?)
C        NTOT       # OF IMAGES IN IMAGE NUMBER LIST               (RET)
d90 2
a91 2
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                       (RET)
C                     -1 GOTO PREVIOUS QUESTION
@


1.21
log
@comments
@
text
@d8 1
d13 1
a13 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d56 9
d105 1
a105 1
       CHARACTER (LEN=1)         :: CDUM,NULL 
d110 1
d112 1
a112 1
       integer                   :: lunop
d114 2
a115 4
       LOGICAL                   :: isopen
       CHARACTER (LEN=MAXNAM)    :: filnamt 

       NULL = CHAR(0)
d119 1
a119 1
       IF (ASKNAM .AND. PROMPT .EQ. NULL) THEN
d122 3
a124 3
          IF (DISP .EQ. 'N' .OR. 
     &        DISP .EQ. 'I' .OR.
     &        DISP .EQ. 'U') THEN
d137 3
a139 2
        ELSEIF (ASKNAM) THEN
C         ASK FOR FILE NAME       
d142 1
d148 1
a148 1

d202 1
a202 1
          IF (IMGWANT < 0 .OR. IMGWANT .GT. 10000000) THEN
d209 1
a209 1
          IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d225 1
a225 1
       ELSEIF (LOCAT .EQ. NLET) THEN
d228 1
a228 1
          IF (DISP .EQ. 'I') THEN
d260 3
a262 3
          IF (DISP .EQ. 'U' .OR. 
     &        DISP .EQ. 'I' .OR.
     &        DISP .EQ. 'N') THEN
d280 1
a280 1
                IF (NTOT .GT. NIMAXP) THEN
d295 1
a295 1
          IF (IMGNUM < 0 .OR. IMGNUM .GT. 10000000) THEN
d315 2
a316 1

d323 3
a325 2
             IF (NTOT > 0) THEN
                !write(6,*)' From openxmsel: ',ntot,':',filnam(:nlet) 
d336 1
d344 4
a347 1
     & 		       MAXIM,'INPUT',FOUROK,IRTFLG) 
d446 1
a446 1
        ELSEIF (LOCAST > 0 .AND. LOCAT .LE. 0) THEN 
d488 1
a488 1
           IF (IRTFLG .EQ. 0) THEN
d492 1
a492 1
           IF (IRTFLG .NE. 0 .OR. IMUSED .EQ. 0) THEN
d505 1
a505 1
        ELSEIF (LOCAT .EQ. NLET) THEN
d519 1
a519 1
              IF (IRTFLG .GT. 0) THEN
d528 1
a528 1
              IF (IMUSED .GT. 0) EXIT     ! FOUND NEXT IMAGE
d627 1
a627 1
        ELSEIF (LOCAT .LE. 0 .AND. LOCAST > 1) THEN
d661 1
a661 1
!              IF (NWANT .LE. 0) NWANT = 1
d671 1
a671 1
           IF (NWANT .GT. MAXIM) THEN
d686 1
a686 1
           IF (NWANT .GT. MAXIM .OR. ISTACK .GT. 2) THEN
d803 2
a804 2
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
d858 3
a860 3
         ELSEIF (MAXIM2 .EQ. -2  .OR.
     &           MAXIM2 .EQ. -1  .OR.
     &           MAXIM2  >    0 ) THEN
d944 2
a945 2
      IF (DISP .EQ. 'O' .OR. DISP .EQ. 'B' .OR. 
     &    DISP .EQ. 'Z' .OR. DISP .EQ. 'E') THEN 
d964 2
a965 2
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
d1008 3
a1010 3
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
     &           MAXIM1  >    0 ) THEN
@


1.20
log
@IMGNUM1,IMGNUM2  IMAGE NUMBERS                  (SENT/RET)
IF (IMGNUM1 == -1 .AND. LUNXM1 > 0
@
text
@d12 1
a12 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d30 2
d36 3
a38 3
C PURPOSE: SOLICITS FILE NAME(S) AND OPENS FILE(S)
C          SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C          WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
d881 1
a881 1
C PURPOSE:  GETS NEXT FILES FOR A STACK ORIENTED OPERATION
@


1.19
log
@if already opened msg and irtflg changed
@
text
@d734 1
a734 1
C             IMGNUM1,IMGNUM2  IMAGE NUMBERS                     (RET.)
d771 1
a771 1
         IF (IMGNUM1 .EQ. -1  ) THEN
d826 1
a826 1
         IF (IMGNUM2 .EQ. -1  ) THEN
d892 1
a892 1
C             IMGNUM1          IMAGE NUMBER                      (RET.)
d932 1
a932 1
         IF (IMGNUM1 .EQ. -1  ) THEN
d981 1
a981 1
         IF (IMGNUM1 .EQ. -1  ) THEN
@


1.18
log
@INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
for doubly opened files trap
@
text
@d170 1
a170 1
             MESG = 'FILE: ' // FILNAMT(1:NLET) //
d174 3
a176 2
                CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -1
d227 1
a227 1
             MESG = 'FILE: ' // FILNAMT(1:NLET) //
d231 3
a233 2
                CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -1
d846 1
d996 1
@


1.17
log
@NTOT       = 1 for single images[D[D[
@
text
@d99 5
d164 16
a179 1
          MAXIM  = 1               
d222 14
d305 1
a305 1
             !write(6,*)' Filnam from openxmsel: ',filnam(:nlet) 
d308 1
d761 1
d813 1
d822 2
@


1.16
log
@NX...
@
text
@d32 1
a32 1
C          INUMBRT,NIMAXT, NTOT,IMGNUM, IRTFLG)
d54 1
a54 1
C        INUMBRT    IMAGE NUMBER LIST                              (RET)
d60 1
d74 1
a74 1
     &                    FOUROK,INUMBRT,NIMAXT, 
d88 1
a88 1
       INTEGER                   :: INUMBRT(*)
d138 1
a138 1
       !write(6,*)' inumbrt:',inumbrt(1)
d147 1
a147 1
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,INUMBRT,NIMAXP,
d167 1
a167 1
          IMGWANT  = INUMBRT(1)
d227 1
a227 1
C            CREATE IMAGE NUMBER LIST IN: INUMBRT
d235 1
a235 1
                INUMBRT(NTOT) = I
d245 1
a245 1
          IMGNUM = INUMBRT(1)
d261 1
a261 1
!     &              '  for:',NTOT,' images.'
d294 1
a294 1
          NTOT       = 1
@


1.15
log
@IRTFLG = -99 if no nextfile for output
@
text
@d7 1
d12 1
a12 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d31 1
a31 1
C          ITYPE,NSAM,NROW,NSLICE,MAXIM, PROMPT,FOUROK,
d34 3
a36 3
C PURPOSE:  SOLICITS FILE NAME(S) AND OPENS FILE(S)
C           SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C           WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
d48 1
a48 2
C        NSAM,NROW  IMAGE SIZE                             (SENT OR RET)
C        NSLICE     IMAGE Z SIZE                           (SENT OR RET)
d71 1
a71 1
     &                    ITYPE,NSAM,NROW,NSLICE,MAXIM,
d84 1
a84 1
       INTEGER                   :: ITYPE,NSAM,NROW,NSLICE,MAXIM
d160 1
a160 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d202 1
a202 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d255 1
a255 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d276 1
a276 1
     &                       ITYPE,NSAM,NROW,NSLICE, 
d289 1
a289 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d363 1
a363 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d374 1
a374 1
     &                 NSAM,NROW,NSLICE, 
d379 2
a380 2
           CALL SIZCHK(NULL,NSAM1,NROW1,NSLICE1,ITYPE1,
     &                      NSAM ,NROW, NSLICE, ITYPE, IRTFLG)
d392 1
a392 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d401 1
a401 1
     &                 NSAM,NROW,NSLICE, 
d406 2
a407 2
           CALL SIZCHK(NULL,NSAM1,NROW1,NSLICE1,ITYPE1,
     &                      NSAM ,NROW, NSLICE, ITYPE, IRTFLG)
d420 2
a421 2
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d423 1
a423 1
              !write(6,*) ' lunredhed,lun,nsam,irtflg:',lun,nsam,irtflg
d430 1
a430 1
           CALL LUNREDHED(LUN,NSAM,NWANT,.FALSE.,IRTFLG)
d453 1
a453 1
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
d458 1
a458 1
              CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d461 1
a461 1
              CALL LUNREDHED(LUN,NSAM,NGOT,.FALSE.,IRTFLG)
d485 1
a485 1
           !write(6,*)' ngot,nsam:',ngot,nsam,lun,imused,irtflg
d489 1
a489 1
        CALL LUNSETIMGOFF(LUN,NGOT,NSAM,IRTFLG)
d550 1
a550 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d561 1
a561 1
     &                 NSAM1,NROW1,NSLICE1, 
d573 1
a573 1
C          NEW IMAGE, NEEDS TO KNOW: ITYPE,NSAM,NROW,NSLICE!
d575 1
a575 1
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
d586 1
a586 1
     &                 NSAM,NROW,NSLICE, 
d608 2
a609 2
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d625 1
a625 1
              CALL LUNWRTINDX(LUN,NWANT,NSAM,IRTFLGT)
d631 1
a631 1
              CALL LUNWRTHED(LUN,NSAM,0,IRTFLGT)
d652 1
a652 1
           CALL LUNWRTHED(LUN,NSAM,NWANT,IRTFLG)
d655 1
a655 1
           CALL LUNSETIMGOFF(LUN,NWANT,NSAM,IRTFLGT)
@


1.14
log
@DO I= 1,MAXIM for bare stack list bug fix
@
text
@d673 2
a674 1
C  NEXTFILES.F            NEW                     12/15/06 ARDEAN LEITH
d761 1
a761 1
          CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
d764 1
a764 1
          !write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
d804 1
a804 1
                IRTFLG = -1
d829 3
a831 1
C  NEXTFILE.F            NEW                     12/15/06 ARDEAN LEITH
d953 1
a953 1
                IRTFLG = -1
@


1.13
log
@ASKLIST
@
text
@d228 1
a228 1
             DO I= IMGNUM,MAXIM
@


1.12
log
@OPEN NEW BARE INDEXED STACK bug
@
text
@d11 1
a11 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d57 1
d90 2
a91 1
       LOGICAL                   :: SAYIT
d135 1
d137 1
d140 4
a143 1
       IF (ASKNAM .AND. LOCAST .GT. 0) THEN
d146 1
a146 1
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,INUMBRT,NIMAXT,
d149 2
d154 1
a154 1
C         STACKED FILE TEMPLATE: STK@@**** -------------- _9@@* or STK@@**
d230 1
a230 1
                IF (NTOT .GT. NIMAXT) THEN
d238 1
a238 2
         !write(6,*)' Opened bare stack: ',FILPAT(1:NLET),
c    &              ' at image: ',IMGNUM
d260 1
a260 1
c    &              '  for: ',NTOT,'  images.'
a356 1

a357 1

d760 1
a760 3
         !write(6,*) ' call gotoldimg, nwant1:',nwant1
 
         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
d763 2
a764 2
         !write(6,'(a,8i5)') ' Gotoldimg, lun1,nwant1,imgnum1: ',
c     &                                   lun1,nwant1,imgnum1
d781 1
a781 1
c     &                             nindx2,ngot2,maxim2,imgnum2
a807 1

d812 1
a812 1
c     &   ' calling Getnew,nwant2,imgnum2,maxim2:',nwant2,imgnum2,maxim2
d818 1
a818 1
c     &                              nwant2,imgnum2,maxim2,irtflg
d914 1
a914 1
        !write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
d957 1
a957 1
         !write(6,*) ' nextfiles, nwant1,nindx1:',nwant1,nindx1
d965 1
a965 1
c     &                              nwant1,imgnum1,maxim1,irtflg
@


1.11
log
@NWANT2 = IMGNUM1, IMGNUMIN
@
text
@d49 2
a50 1
C        MAXIM      STACK INDICATOR                                (RET)
d82 1
a82 1
       CHARACTER(LEN=*)          :: DISP 
d94 1
d103 3
a105 1
          IF (DISP .EQ. 'N' .OR. DISP .EQ. 'U') THEN
d134 1
d145 1
a145 1
C         STACKED FILE TEMPLATE: STK@@**** ---------------------- STK@@**
d149 1
a149 1
          MAXIM  = 1  
d182 11
a192 3
C         WHOLE BARESTACK:  STK@@  ------------------------------- STK@@
          MAXIM = 1
          CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISP,
d201 3
a203 1
          IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d229 1
a229 1
c         write(6,*)' Opened bare stack: ',FILPAT(1:NLET),
d251 1
a251 1
c         write(6,*)' Opened templated file: ',FILPAT(1:NLET),
d273 1
a273 1
c               write(6,*)' Opened selfile image: ',filnam(1:nlet) 
d288 1
a288 1
c         write(6,*)' Opened simple file: ',FILPAT(1:nlet) 
d341 1
a341 1
        INTEGER                :: NLET
d348 2
a349 1
        !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d352 1
d377 1
a377 1
c          write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)
d383 1
a383 1
        ELSEIF (LOCAST > 0 .AND. LOCAT .LE. 0) THEN
d404 1
a404 1
c          write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim
d411 1
a411 1
C          TEMPLATED STACKED IMAGE ----------------------------- STK@@***
d417 1
a417 1
              write(6,*) ' lunredhed,lun,nsam,irtflg:',lun,nsam,irtflg
d440 1
a440 1
c          write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)
d443 1
a443 1
C          WHOLE IMAGE STACK -------------------------------- STK@@
a446 1
C          LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
a447 1
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d451 3
a470 3
C             MUST LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
              CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)

a473 1
           !8dec CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
d478 2
a479 1
c          write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
d538 1
a538 1
c       write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d559 1
a559 1
c           write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)
d584 1
a584 1
c          write(6,*)' Opened new templated file: ',FILNAM(1:NLET)
d656 1
a656 1
c          write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)
d722 1
a722 1
!         write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
d759 1
a759 1
c         write(6,'(a,8i5)') ' Gotoldimg, lun1,nwant1,imgnum1: ',
d776 1
a776 1
c        write(6,'(a,8i5)')'  out: nindx2,ngot2,maxim2,imgnum2: ',
d807 2
a808 2
C        write(6,*) ' nextfiles, nwant2,nindx2:',nwant2,nindx2
c        write(6,'(a,8i5)') 
d814 1
a814 1
c         write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
d880 1
a880 1
c        write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
d911 1
a911 1
c        write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
d916 1
a916 1
c        write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
d929 1
a929 1
c        write(6,'(a,8i5)')'  out: nindx1,ngot1,maxim1,imgnum1: ',
d954 2
a955 2
C        write(6,*) ' nextfiles, nwant1,nindx1:',nwant1,nindx1
c        write(6,'(a,8i5)') 
d961 1
a961 1
c        write(6,'(a,8i5)') ' Getnew,nwant1,imgnum1,maxim1,irtflg:',
d972 1
@


1.10
log
@removed debug messages
@
text
@d58 3
a60 2
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN            (RET)
C                     <0 IS SELFILE IN USE 
d124 2
a125 1
       IMGNUM = 0 
d127 2
a128 2
       LOCAT  = INDEX(FILPAT(1:NLET),'@@')   
       LOCAST = INDEX(FILPAT(1:NLET),'*')
d180 2
a181 2
     &                     ITYPE,NSAM,NROW,NSLICE, 
     & 		           MAXIM,'INPUT',FOUROK,IRTFLG) 
d184 2
a185 2
C         OPEN FIRST FILE IN STACK 
          IMGNUMT = 1
d187 1
d189 4
a192 2
C            NEW BARE STACK
             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGNUMT,
d195 1
d197 3
a199 3
C            EXISTING BARE STACK
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGNUMT,SAYIT,
     &                      FOUROK,IMGNUM,IRTFLG)
d207 1
a207 1
                   CALL ERRT(102,'INUMBRT LIST OVERFLOW AT IMAGE',NTOT)
d697 1
a697 1
      LOGICAL           :: GOTAST
d705 1
a705 1
         GOTAST = (INDEX(FILPAT1,'*') > 0)
d714 1
a714 1
         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
d750 2
a751 2
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK 
d759 1
a759 1
         GOTAST = (INDEX(FILPAT2,'*') > 0)
d768 1
a768 1
         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST ) THEN
d772 5
d799 1
a799 1
c        write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
a802 4
         IF (MAXIM2 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
            NINDX2 = IMGNUM2
         ENDIF
@


1.9
log
@MAXIM2 .EQ. -1 bug in nextfiles, nextfile
@
text
@d354 1
a354 1
         write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)
d381 1
a381 1
         write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim
d417 1
a417 1
         write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)
d458 1
a458 1
          write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
d538 1
a538 1
           write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)
d563 1
a563 1
           write(6,*)' Opened new templated file: ',FILNAM(1:NLET)
d635 1
a635 1
          write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)
d894 2
a895 2
        write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
     &                           ngot1,nwant1,imgnum1,irtflg,maxim1
@


1.8
log
@typo
@
text
@d717 3
a719 1
         ELSEIF (MAXIM1 .EQ. -2 ) THEN
d721 1
a730 9
         ELSEIF (MAXIM1 > 0) THEN
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C               OVERUN INPUT LIST
                IRTFLG = -1
                RETURN
            ENDIF
C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)
d766 4
a769 1
         ELSEIF (MAXIM2 .EQ. -2 ) THEN
a778 11
         ELSEIF (MAXIM2 > 0) THEN
C           STACKED IMAGE WITH/WITHOUT TEMPLATE LIST 

            IF (NINDX2 > NGOT2) THEN
C               OVERUN OUTPUT LIST
                IRTFLG = -1
                RETURN
            ENDIF

C           OPEN NEXT OUTPUT FILE 
            NWANT2 = INUMBR2(NINDX2)
d875 1
d887 1
d894 2
a895 2
c        write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
c     &                                   lun1,nwant1,imgnum1,irtflg
d918 3
a920 2
         ELSEIF (MAXIM1 .EQ. -2   .OR.
     &           MAXIM1   >   0 ) THEN
@


1.7
log
@refactored
@
text
@d907 1
a907 1
 c     &                                   lun1,nwant1,imgnum1,irtflg
@


1.6
log
@GPL_2010
@
text
@d3 4
a6 4
C 
C  OPFILES.F        NEW                    ARDEAN LEITH        12/15/06 
C                   BAD NUMBRT() TRAP      ARDEAN LEITH        05/21/09
C
d29 1
a29 1
C  OPFILES(LUNCP,LUNIMG,LUNDOC, FILPAT,NLET, DISP,
d40 6
a45 4
C        LUNDOC     UNIT TO OPEN LIST DOC FILE ON                 (SENT)
C        FILPAT     FILE NAME PATTERN                             (SENT)
C        NLET       CHARS IN FILE NAME PATTERN                    (SENT)
C        DISP       CHARACTER CONTAINING  DISPOSITION             (SENT)
d49 1
a49 1
C        MAXIM      STACK INDICATOR                           (SENT/RET)
d51 1
d53 9
a61 7
C        INUMBRT    IMAGE NUMBER LIST                             (RET)
C                     NOT USED IF SINGLE IMAGE ONLY
C        NIMAXT     MAX LENGTH OF IMAGE NUMBER LIST              (SENT)
C        NTOT       NUMBER OF IMAGES IN IMAGE NUMBER LIST         (RET)
C        IMGNUM     IMAGE CURRENTLY OPENED                        (RET)
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                      (RET)
C                        -1 GOTO PREVIOUS QUESTION
d65 3
a67 2
 
       SUBROUTINE OPFILES(LUNCP,LUNIMG,LUNDOC, FILPAT,NLET, DISP,
d70 2
a71 1
     &                    FOUROK,INUMBRT,NIMAXT, NTOT,IMGNUM, IRTFLG) 
d76 4
a79 2
       INTEGER                   :: INUMBRT(*)
       CHARACTER(LEN=*)          :: FILPAT,PROMPT 
d81 2
d84 3
d91 1
d97 26
a122 4
       CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
       IF (IRTFLG .NE. 0) RETURN 
   
       NTOT   = 0 
d127 1
a127 1
C      write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d129 1
a129 1
       IF (LOCAST .GT. 0) THEN
d131 1
d137 1
a137 1
       IF (LOCAT .GT. 0 .AND. LOCAST .GT. LOCAT) THEN
d142 1
a142 1
          MAXIM = 1  
d151 1
a151 1
          IF (IMGWANT .LE. 0 .OR. IMGWANT .GT. 10000000) THEN
d153 1
d159 1
a159 1
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGWANT,
d162 2
a163 2
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)
d165 1
d167 2
a168 1
          IF (IRTFLG .NE. 0) GOTO 9000
d170 3
a172 2
c          write(6,*)'Opened templated stack: ',FILPAT(1:nlet),
c     &           ' at image: ',IMGNUM, '  for: ',NTOT,'  images.'
d186 2
a187 2
C            NEW STACKED FILE
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGNUMT,
d191 3
a193 2
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGNUMT,
     &                      SAYIT,IMGNUM,IRTFLG)
d208 1
a208 1
c         write(6,*)'Opened bare stack: ',FILPAT(1:NLET),
d211 1
a211 1
       ELSEIF (LOCAST .GT. 0) THEN
d216 1
a216 1
          IF (IMGNUM .LE. 0 .OR. IMGNUM .GT. 10000000) THEN
d218 1
d230 1
a230 1
c         write(6,*)'Opened templated file: ',FILPAT(1:NLET),
d235 1
d237 21
a257 1
C         OPEN THE FILE
d267 1
a267 1
c         write(6,*)'Opened simple file: ',FILPAT(1:nlet) 
d281 1
a281 1
C    GETOLDIMG(LUN,FILPAT,NWANT, SAYIT,NGOT,IRTFLG)
d287 2
a288 1
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
d290 3
a292 2
C        NWANT      IMAGE NUMBER WANTED                           (SENT) 
C        SAYIT      SAY FILE OPENIN INFO.                         (SENT)
d303 2
a304 1
	SUBROUTINE GETOLDIMG(LUN,FILPAT,NWANT, SAYIT,NGOT,IRTFLG)
d308 2
d311 1
d313 3
d318 1
a318 2
        CHARACTER(LEN=1)       :: DSP
        LOGICAL                :: FOUROK
d320 1
a320 1
        FOUROK = .TRUE.
d323 1
a325 1
c       write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d327 34
a360 1
        IF (LOCAST .GT. 0 .AND. LOCAT .LE. 0) THEN
d363 2
d376 6
a381 1
c          write(6,*)'Opened old templated file: ',FILNAM(1:NLET)
a385 1
        ENDIF
d387 1
a387 1
        IF (LOCAT .GT. 0 .AND. LOCAST .GT. 0 .AND.LOCAT .LT. LOCAST)THEN
d393 6
d417 1
a417 1
c          write(6,*)'Opened old templated stacked file: ',FILNAM(:NLET)
a420 1

d441 1
a441 1
              IF (IMUSED .GT. 0) EXIT
d446 4
d453 3
a455 1
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
d458 1
a458 1
c          write(6,*)'Opened old bare stacked file: ',FILNAM(1:NLET)
d470 1
d476 1
a476 1
C    GETNEWIMG(LUNCP,LUN,FILPAT,NWANTT, SAYIT,NGOT,IRTFLG)
d482 3
a484 2
C        LUNCP      LOGICAL UNIT NUMBER FOR HEADER TXT COPY       (SENT)
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
d487 1
a487 1
C        SAYIT      SAY FILE OPENIN INFO.                         (SENT)
d496 1
a496 1
	SUBROUTINE GETNEWIMG(LUNCP,LUN,FILPAT,NWANTT, 
d501 1
d503 1
d505 2
d519 25
a543 1
        IF (LOCAT .LE. 0 .AND. LOCAST .GT. 0) THEN
d563 1
a563 1
c          write(6,*)'Opened new templated file: ',FILNAM(1:NLET)
d569 1
a569 1
        ELSEIF (LOCAT .GT. 0) THEN
d573 6
a578 6
           IF (ISBARE) THEN
C             WANT NEXT IMAGE IN STACK, GET CURRENT FILE NUMBER 
              CALL LUNGETINUSE(LUN,NWANT,IRTFLG)
              NWANT = NWANT + 1
              IF (NWANT .LE. 0) NWANT = 1
           ENDIF
d583 1
a583 1

d596 1
a596 1
          IF (ISTACK .LT. 0) THEN
d605 1
d634 2
a635 1
c          write(6,*)'Opened new stacked file: ',FILNAM(1:NLET)
d649 5
a653 2
C NEXTFILES(NWANT,INUMBR,INUMBROUT, LUNIN,LUNCP,LUNOUT,
C           FILPATIN,FILPATOUT,IMGNUM,IMGNUMOUT,IRTFLG)
d658 12
a669 11
C PARAMETERS: NWANT        LIST INDEX                         (SENT)
C             INUMBR       INPUT IMAGE NUMBER LIST            (SENT)
C             INUMBROUT    OUTPUT IMAGE NUMBER LIST           (SENT)
C             LUNIN        LUN FOR OUTPUT (0 IS NO FILE IN)   (SENT)
C             LUNCP        LUN FOR OUTPUT HEADER COPY         (SENT)
C             LUNOUT       LUN FOR OUTPUT (0 IS NO FILE OUT)  (SENT)
C             FILPATIN     INPUT FILE PATTERN                 (SENT)
C             FILPATOUT    OUTPUT  FILE PATTERN               (SENT)
C             IMGNUM       INPUT IMAGE                        (SENT/RET.)
C             IMGNUMOUT    LUN FOR OUTPUT (0 IS NO FILE OUT)  (SENT/RET.)
C             IRTFLG       ERROR (0 IS OK, -1 IS END STACK)   (RET.)
d672 5
a676 4
      SUBROUTINE NEXTFILES(NWANT, INUMBRT,INUMBROUT,   
     &                     LUNIN,LUNCP,LUNOUT,
     &                     FILPATIN,FILPATOUT,
     &                     IMGNUM,IMGNUMOUT,IRTFLG) 
d678 1
a678 3
      INTEGER           :: INUMBRT(*),INUMBROUT(*)
      CHARACTER(LEN=*)  :: FILPATIN,FILPATOUT
      LOGICAL           :: SAYIT
d680 13
a692 1
      SAYIT = .TRUE.
d694 2
a695 1
      NWANT   = NWANT + 1
d697 1
a697 1
      IF (LUNIN .GT. 0) THEN  
d699 48
a746 3
         IMGNUMT = INUMBRT(NWANT)
         CALL GETOLDIMG(LUNIN,FILPATIN, IMGNUMT, 
     &                  SAYIT,IMGNUM,IRTFLG)
d749 6
d757 1
a757 1
      IF (LUNOUT .GT. 0) THEN  
d759 1
a759 1
         IMGNUMOUTT = INUMBROUT(NWANT) ! NONSENSE IF WHOLE STACK
d761 49
a809 3
         CALL GETNEWIMG(LUNCP,LUNOUT,FILPATOUT,IMGNUMOUTT,
     &                  SAYIT,IMGNUMOUT,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN    ! ERROR
d815 146
@


1.5
log
@closed lun in getnewimg bug
@
text
@d8 4
a11 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *                                                                    *
@


1.4
log
@ bad data trps
@
text
@d6 1
d8 5
a12 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d257 1
a257 1
           CLOSE(LUN)
d403 2
a404 1
           MAXIM = 0  
@


1.3
log
@lunsetisbare false
@
text
@d5 1
d8 1
a8 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a101 1

d112 1
d115 7
a121 2
          IMGNUM  = INUMBRT(1)
          SAYIT   = .TRUE.
d123 1
a123 1
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGNUM,
d126 1
a126 1
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGNUM,
d129 1
a130 1
          CALL LUNSETISBARE(LUNIMG,.FALSE.,IRTFLG)
d132 2
a133 2
c         write(6,*)'Opened templated stack: ',FILPAT(1:nlet),
c    &           ' at image: ',IMGNUM, '  for: ',NTOT,'  images.'
d176 4
d361 1
a361 1
C        LUNCP      LOGICAL UNIT NUMBER FOR HEADER TXT COPY      (SENT)
@


1.2
log
@put in getnextfiles
@
text
@d124 1
@


1.1
log
@for stacked series
@
text
@d480 58
@

