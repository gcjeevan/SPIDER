head	1.500;
access;
symbols
	pre_mrcs:1.494
	healthdept_2018:1.490
	pre_getangas:1.381
	GPL2010:1.369
	pre_GPL2010:1.368
	pre_var_equation:1.344
	pre_fftwrings:1.314
	pre_opfiles:1.297
	src:1.297
	best-code:1.285
	named-reg:1.268
	x-named-regs:1.267
	x:1.267
	v13-00:1.265
	pre_GPL:1.261
	prec_CA:1.233
	noindx:1.218
	Bproc:1.156
	oct21:1.131
	last77:1.101;
locks; strict;
comment	@c @;


1.500
date	2020.07.01.14.08.45;	author leith;	state Exp;
branches;
next	1.499;

1.499
date	2020.06.24.15.24.01;	author leith;	state Exp;
branches;
next	1.498;

1.498
date	2020.02.27.16.37.00;	author leith;	state Exp;
branches;
next	1.497;

1.497
date	2020.01.21.19.01.36;	author leith;	state Exp;
branches;
next	1.496;

1.496
date	2019.11.20.16.35.00;	author leith;	state Exp;
branches;
next	1.495;

1.495
date	2019.11.04.17.47.44;	author leith;	state Exp;
branches;
next	1.494;

1.494
date	2019.02.14.18.39.25;	author leith;	state Exp;
branches;
next	1.493;

1.493
date	2019.01.02.18.52.55;	author leith;	state Exp;
branches;
next	1.492;

1.492
date	2018.10.26.15.21.04;	author leith;	state Exp;
branches;
next	1.491;

1.491
date	2018.10.25.18.07.35;	author leith;	state Exp;
branches;
next	1.490;

1.490
date	2018.07.26.14.15.29;	author leith;	state Exp;
branches;
next	1.489;

1.489
date	2018.02.12.20.27.53;	author leith;	state Exp;
branches;
next	1.488;

1.488
date	2018.01.25.17.00.05;	author leith;	state Exp;
branches;
next	1.487;

1.487
date	2018.01.23.17.09.17;	author leith;	state Exp;
branches;
next	1.486;

1.486
date	2018.01.23.16.53.43;	author leith;	state Exp;
branches;
next	1.485;

1.485
date	2017.11.28.14.27.51;	author leith;	state Exp;
branches;
next	1.484;

1.484
date	2017.11.27.19.10.47;	author leith;	state Exp;
branches;
next	1.483;

1.483
date	2017.05.26.16.58.58;	author leith;	state Exp;
branches;
next	1.482;

1.482
date	2017.04.18.18.11.55;	author leith;	state Exp;
branches;
next	1.481;

1.481
date	2017.04.18.18.08.21;	author leith;	state Exp;
branches;
next	1.480;

1.480
date	2017.01.30.14.38.58;	author leith;	state Exp;
branches;
next	1.479;

1.479
date	2017.01.11.19.16.23;	author leith;	state Exp;
branches;
next	1.478;

1.478
date	2016.11.08.16.11.20;	author leith;	state Exp;
branches;
next	1.477;

1.477
date	2016.09.20.14.40.46;	author leith;	state Exp;
branches;
next	1.476;

1.476
date	2016.06.23.16.37.51;	author leith;	state Exp;
branches;
next	1.475;

1.475
date	2016.04.29.14.07.30;	author leith;	state Exp;
branches;
next	1.474;

1.474
date	2016.04.18.14.57.22;	author leith;	state Exp;
branches;
next	1.473;

1.473
date	2016.04.01.16.03.21;	author leith;	state Exp;
branches;
next	1.472;

1.472
date	2016.03.07.16.01.22;	author leith;	state Exp;
branches;
next	1.471;

1.471
date	2016.02.11.16.49.15;	author leith;	state Exp;
branches;
next	1.470;

1.470
date	2016.02.09.15.44.59;	author leith;	state Exp;
branches;
next	1.469;

1.469
date	2016.02.09.15.22.06;	author leith;	state Exp;
branches;
next	1.468;

1.468
date	2016.02.08.18.54.04;	author leith;	state Exp;
branches;
next	1.467;

1.467
date	2016.01.28.16.30.47;	author leith;	state Exp;
branches;
next	1.466;

1.466
date	2016.01.28.15.17.29;	author leith;	state Exp;
branches;
next	1.465;

1.465
date	2016.01.26.17.31.48;	author leith;	state Exp;
branches;
next	1.464;

1.464
date	2016.01.26.15.00.59;	author leith;	state Exp;
branches;
next	1.463;

1.463
date	2016.01.25.21.05.57;	author leith;	state Exp;
branches;
next	1.462;

1.462
date	2016.01.22.14.11.26;	author leith;	state Exp;
branches;
next	1.461;

1.461
date	2016.01.20.16.48.08;	author leith;	state Exp;
branches;
next	1.460;

1.460
date	2015.12.18.14.39.51;	author leith;	state Exp;
branches;
next	1.459;

1.459
date	2015.12.17.17.27.34;	author leith;	state Exp;
branches;
next	1.458;

1.458
date	2015.11.04.14.53.58;	author leith;	state Exp;
branches;
next	1.457;

1.457
date	2015.09.08.17.22.38;	author leith;	state Exp;
branches;
next	1.456;

1.456
date	2015.07.17.14.12.38;	author leith;	state Exp;
branches;
next	1.455;

1.455
date	2015.06.05.16.03.55;	author leith;	state Exp;
branches;
next	1.454;

1.454
date	2015.05.06.13.22.45;	author leith;	state Exp;
branches;
next	1.453;

1.453
date	2015.04.21.16.09.55;	author leith;	state Exp;
branches;
next	1.452;

1.452
date	2015.02.05.18.42.42;	author leith;	state Exp;
branches;
next	1.451;

1.451
date	2015.01.21.15.55.50;	author leith;	state Exp;
branches;
next	1.450;

1.450
date	2015.01.05.19.00.36;	author leith;	state Exp;
branches;
next	1.449;

1.449
date	2014.12.05.18.48.08;	author leith;	state Exp;
branches;
next	1.448;

1.448
date	2014.11.07.16.11.15;	author leith;	state Exp;
branches;
next	1.447;

1.447
date	2014.09.15.15.39.25;	author leith;	state Exp;
branches;
next	1.446;

1.446
date	2014.08.29.13.57.47;	author leith;	state Exp;
branches;
next	1.445;

1.445
date	2014.08.26.16.50.53;	author leith;	state Exp;
branches;
next	1.444;

1.444
date	2014.08.18.15.22.45;	author leith;	state Exp;
branches;
next	1.443;

1.443
date	2014.07.31.13.25.27;	author leith;	state Exp;
branches;
next	1.442;

1.442
date	2014.06.02.12.19.23;	author leith;	state Exp;
branches;
next	1.441;

1.441
date	2014.05.21.16.27.50;	author leith;	state Exp;
branches;
next	1.440;

1.440
date	2014.05.15.16.22.52;	author leith;	state Exp;
branches;
next	1.439;

1.439
date	2014.04.29.18.22.33;	author leith;	state Exp;
branches;
next	1.438;

1.438
date	2014.04.03.14.59.44;	author leith;	state Exp;
branches;
next	1.437;

1.437
date	2014.03.07.16.55.44;	author leith;	state Exp;
branches;
next	1.436;

1.436
date	2014.01.27.17.18.09;	author leith;	state Exp;
branches;
next	1.435;

1.435
date	2014.01.09.17.19.57;	author leith;	state Exp;
branches;
next	1.434;

1.434
date	2013.12.27.16.42.37;	author leith;	state Exp;
branches;
next	1.433;

1.433
date	2013.12.16.16.31.15;	author leith;	state Exp;
branches;
next	1.432;

1.432
date	2013.12.03.19.14.07;	author leith;	state Exp;
branches;
next	1.431;

1.431
date	2013.11.25.18.43.54;	author leith;	state Exp;
branches;
next	1.430;

1.430
date	2013.11.08.13.31.49;	author leith;	state Exp;
branches;
next	1.429;

1.429
date	2013.08.12.15.52.31;	author leith;	state Exp;
branches;
next	1.428;

1.428
date	2013.05.22.14.38.26;	author leith;	state Exp;
branches;
next	1.427;

1.427
date	2013.05.02.12.53.48;	author leith;	state Exp;
branches;
next	1.426;

1.426
date	2013.05.01.14.58.29;	author leith;	state Exp;
branches;
next	1.425;

1.425
date	2013.04.26.15.43.54;	author leith;	state Exp;
branches;
next	1.424;

1.424
date	2013.04.22.14.39.33;	author leith;	state Exp;
branches;
next	1.423;

1.423
date	2013.04.09.12.04.18;	author leith;	state Exp;
branches;
next	1.422;

1.422
date	2013.03.12.12.52.25;	author leith;	state Exp;
branches;
next	1.421;

1.421
date	2013.02.06.19.29.38;	author leith;	state Exp;
branches;
next	1.420;

1.420
date	2013.01.03.15.57.47;	author leith;	state Exp;
branches;
next	1.419;

1.419
date	2013.01.03.15.06.59;	author leith;	state Exp;
branches;
next	1.418;

1.418
date	2012.12.28.17.18.57;	author leith;	state Exp;
branches;
next	1.417;

1.417
date	2012.12.12.14.49.11;	author leith;	state Exp;
branches;
next	1.416;

1.416
date	2012.12.06.15.38.47;	author leith;	state Exp;
branches;
next	1.415;

1.415
date	2012.11.28.19.19.35;	author leith;	state Exp;
branches;
next	1.414;

1.414
date	2012.10.10.15.27.16;	author leith;	state Exp;
branches;
next	1.413;

1.413
date	2012.09.20.13.17.35;	author leith;	state Exp;
branches;
next	1.412;

1.412
date	2012.09.11.12.38.06;	author leith;	state Exp;
branches;
next	1.411;

1.411
date	2012.07.27.14.43.07;	author leith;	state Exp;
branches;
next	1.410;

1.410
date	2012.07.20.17.13.22;	author leith;	state Exp;
branches;
next	1.409;

1.409
date	2012.06.13.14.06.49;	author leith;	state Exp;
branches;
next	1.408;

1.408
date	2012.05.14.17.28.21;	author leith;	state Exp;
branches;
next	1.407;

1.407
date	2012.04.16.12.07.23;	author leith;	state Exp;
branches;
next	1.406;

1.406
date	2012.04.05.18.34.28;	author leith;	state Exp;
branches;
next	1.405;

1.405
date	2012.03.14.14.41.41;	author leith;	state Exp;
branches;
next	1.404;

1.404
date	2012.02.22.14.31.37;	author leith;	state Exp;
branches;
next	1.403;

1.403
date	2012.01.30.14.52.11;	author leith;	state Exp;
branches;
next	1.402;

1.402
date	2012.01.25.18.47.58;	author leith;	state Exp;
branches;
next	1.401;

1.401
date	2012.01.23.17.51.51;	author leith;	state Exp;
branches;
next	1.400;

1.400
date	2012.01.06.19.18.22;	author leith;	state Exp;
branches;
next	1.399;

1.399
date	2011.12.06.17.29.50;	author leith;	state Exp;
branches;
next	1.398;

1.398
date	2011.11.30.13.54.10;	author leith;	state Exp;
branches;
next	1.397;

1.397
date	2011.11.09.14.45.57;	author leith;	state Exp;
branches;
next	1.396;

1.396
date	2011.11.01.13.38.06;	author leith;	state Exp;
branches;
next	1.395;

1.395
date	2011.10.19.14.51.27;	author leith;	state Exp;
branches;
next	1.394;

1.394
date	2011.10.12.18.02.34;	author leith;	state Exp;
branches;
next	1.393;

1.393
date	2011.09.28.16.00.46;	author leith;	state Exp;
branches;
next	1.392;

1.392
date	2011.08.31.19.15.55;	author leith;	state Exp;
branches;
next	1.391;

1.391
date	2011.08.30.18.03.42;	author leith;	state Exp;
branches;
next	1.390;

1.390
date	2011.07.25.15.41.44;	author leith;	state Exp;
branches;
next	1.389;

1.389
date	2011.06.16.16.39.18;	author leith;	state Exp;
branches;
next	1.388;

1.388
date	2011.05.11.12.09.14;	author leith;	state Exp;
branches;
next	1.387;

1.387
date	2011.04.25.18.55.06;	author leith;	state Exp;
branches;
next	1.386;

1.386
date	2011.04.12.15.19.18;	author leith;	state Exp;
branches;
next	1.385;

1.385
date	2011.04.07.11.58.15;	author leith;	state Exp;
branches;
next	1.384;

1.384
date	2011.03.28.11.50.34;	author leith;	state Exp;
branches;
next	1.383;

1.383
date	2011.03.18.18.26.44;	author leith;	state Exp;
branches;
next	1.382;

1.382
date	2011.03.11.15.29.33;	author leith;	state Exp;
branches;
next	1.381;

1.381
date	2011.02.08.17.04.53;	author leith;	state Exp;
branches;
next	1.380;

1.380
date	2011.01.25.13.18.31;	author leith;	state Exp;
branches;
next	1.379;

1.379
date	2011.01.07.19.10.48;	author leith;	state Exp;
branches;
next	1.378;

1.378
date	2010.12.20.15.57.28;	author leith;	state Exp;
branches;
next	1.377;

1.377
date	2010.11.23.15.33.58;	author leith;	state Exp;
branches;
next	1.376;

1.376
date	2010.10.27.13.08.47;	author leith;	state Exp;
branches;
next	1.375;

1.375
date	2010.10.26.12.25.59;	author leith;	state Exp;
branches;
next	1.374;

1.374
date	2010.10.22.14.21.16;	author leith;	state Exp;
branches;
next	1.373;

1.373
date	2010.09.15.18.18.29;	author leith;	state Exp;
branches;
next	1.372;

1.372
date	2010.08.31.14.53.05;	author leith;	state Exp;
branches;
next	1.371;

1.371
date	2010.08.06.18.36.54;	author leith;	state Exp;
branches;
next	1.370;

1.370
date	2010.07.13.18.43.56;	author leith;	state Exp;
branches;
next	1.369;

1.369
date	2010.06.24.13.27.01;	author leith;	state Exp;
branches;
next	1.368;

1.368
date	2010.06.17.14.28.51;	author leith;	state Exp;
branches;
next	1.367;

1.367
date	2010.06.01.15.52.16;	author leith;	state Exp;
branches;
next	1.366;

1.366
date	2010.04.20.15.51.53;	author leith;	state Exp;
branches;
next	1.365;

1.365
date	2010.03.23.14.55.15;	author leith;	state Exp;
branches;
next	1.364;

1.364
date	2010.03.03.19.26.35;	author leith;	state Exp;
branches;
next	1.363;

1.363
date	2010.03.01.13.16.49;	author leith;	state Exp;
branches;
next	1.362;

1.362
date	2010.02.01.13.40.28;	author leith;	state Exp;
branches;
next	1.361;

1.361
date	2010.01.13.18.51.48;	author leith;	state Exp;
branches;
next	1.360;

1.360
date	2010.01.06.19.11.02;	author leith;	state Exp;
branches;
next	1.359;

1.359
date	2009.12.30.20.01.38;	author leith;	state Exp;
branches;
next	1.358;

1.358
date	2009.11.25.18.16.58;	author leith;	state Exp;
branches;
next	1.357;

1.357
date	2009.11.23.20.24.57;	author leith;	state Exp;
branches;
next	1.356;

1.356
date	2009.11.19.21.32.19;	author leith;	state Exp;
branches;
next	1.355;

1.355
date	2009.11.19.18.37.18;	author leith;	state Exp;
branches;
next	1.354;

1.354
date	2009.11.10.19.29.03;	author leith;	state Exp;
branches;
next	1.353;

1.353
date	2009.11.05.19.32.46;	author leith;	state Exp;
branches;
next	1.352;

1.352
date	2009.11.02.19.40.19;	author leith;	state Exp;
branches;
next	1.351;

1.351
date	2009.10.01.14.00.29;	author leith;	state Exp;
branches;
next	1.350;

1.350
date	2009.08.31.16.58.15;	author leith;	state Exp;
branches;
next	1.349;

1.349
date	2009.08.28.15.38.12;	author leith;	state Exp;
branches;
next	1.348;

1.348
date	2009.08.19.13.55.05;	author leith;	state Exp;
branches;
next	1.347;

1.347
date	2009.07.31.11.30.47;	author leith;	state Exp;
branches;
next	1.346;

1.346
date	2009.06.26.15.40.25;	author leith;	state Exp;
branches;
next	1.345;

1.345
date	2009.06.26.13.59.23;	author leith;	state Exp;
branches;
next	1.344;

1.344
date	2009.06.22.15.19.20;	author leith;	state Exp;
branches;
next	1.343;

1.343
date	2009.06.12.10.56.54;	author leith;	state Exp;
branches;
next	1.342;

1.342
date	2009.05.29.13.41.42;	author leith;	state Exp;
branches;
next	1.341;

1.341
date	2009.05.22.16.07.36;	author leith;	state Exp;
branches;
next	1.340;

1.340
date	2009.04.28.16.23.05;	author leith;	state Exp;
branches;
next	1.339;

1.339
date	2009.04.15.11.39.00;	author leith;	state Exp;
branches;
next	1.338;

1.338
date	2009.03.24.16.31.47;	author leith;	state Exp;
branches;
next	1.337;

1.337
date	2009.03.06.13.06.47;	author leith;	state Exp;
branches;
next	1.336;

1.336
date	2009.02.09.17.54.47;	author leith;	state Exp;
branches;
next	1.335;

1.335
date	2008.12.22.15.50.07;	author leith;	state Exp;
branches;
next	1.334;

1.334
date	2008.12.19.17.11.55;	author leith;	state Exp;
branches;
next	1.333;

1.333
date	2008.12.08.15.10.08;	author leith;	state Exp;
branches;
next	1.332;

1.332
date	2008.12.05.16.16.21;	author leith;	state Exp;
branches;
next	1.331;

1.331
date	2008.11.25.15.47.17;	author leith;	state Exp;
branches;
next	1.330;

1.330
date	2008.11.15.15.58.39;	author leith;	state Exp;
branches;
next	1.329;

1.329
date	2008.11.10.14.07.45;	author leith;	state Exp;
branches;
next	1.328;

1.328
date	2008.11.04.13.32.15;	author leith;	state Exp;
branches;
next	1.327;

1.327
date	2008.10.31.17.24.17;	author leith;	state Exp;
branches;
next	1.326;

1.326
date	2008.10.31.15.18.27;	author leith;	state Exp;
branches;
next	1.325;

1.325
date	2008.10.17.12.34.26;	author leith;	state Exp;
branches;
next	1.324;

1.324
date	2008.09.12.16.36.52;	author leith;	state Exp;
branches;
next	1.323;

1.323
date	2008.08.14.12.32.45;	author leith;	state Exp;
branches;
next	1.322;

1.322
date	2008.06.30.14.24.35;	author leith;	state Exp;
branches;
next	1.321;

1.321
date	2008.06.06.17.49.40;	author leith;	state Exp;
branches;
next	1.320;

1.320
date	2008.06.03.15.55.01;	author leith;	state Exp;
branches;
next	1.319;

1.319
date	2008.05.30.17.39.12;	author leith;	state Exp;
branches;
next	1.318;

1.318
date	2008.05.27.15.44.07;	author leith;	state Exp;
branches;
next	1.317;

1.317
date	2008.05.22.17.33.45;	author leith;	state Exp;
branches;
next	1.316;

1.316
date	2008.05.19.19.07.02;	author leith;	state Exp;
branches;
next	1.315;

1.315
date	2008.05.19.12.02.31;	author leith;	state Exp;
branches;
next	1.314;

1.314
date	2008.04.09.13.35.30;	author leith;	state Exp;
branches;
next	1.313;

1.313
date	2008.03.13.18.47.39;	author leith;	state Exp;
branches;
next	1.312;

1.312
date	2008.01.24.16.27.37;	author leith;	state Exp;
branches;
next	1.311;

1.311
date	2007.12.20.19.36.31;	author leith;	state Exp;
branches;
next	1.310;

1.310
date	2007.12.13.19.07.09;	author leith;	state Exp;
branches;
next	1.309;

1.309
date	2007.10.09.19.06.08;	author leith;	state Exp;
branches;
next	1.308;

1.308
date	2007.09.21.14.07.32;	author leith;	state Exp;
branches;
next	1.307;

1.307
date	2007.09.05.16.47.41;	author leith;	state Exp;
branches;
next	1.306;

1.306
date	2007.07.30.16.14.44;	author leith;	state Exp;
branches;
next	1.305;

1.305
date	2007.07.23.12.56.55;	author leith;	state Exp;
branches;
next	1.304;

1.304
date	2007.05.25.13.22.15;	author leith;	state Exp;
branches;
next	1.303;

1.303
date	2007.05.24.16.20.14;	author leith;	state Exp;
branches;
next	1.302;

1.302
date	2007.04.18.19.23.48;	author leith;	state Exp;
branches;
next	1.301;

1.301
date	2007.03.27.16.00.26;	author leith;	state Exp;
branches;
next	1.300;

1.300
date	2007.03.21.15.19.18;	author leith;	state Exp;
branches;
next	1.299;

1.299
date	2007.02.27.14.51.12;	author leith;	state Exp;
branches;
next	1.298;

1.298
date	2007.01.17.19.50.24;	author leith;	state Exp;
branches;
next	1.297;

1.297
date	2007.01.05.14.40.37;	author leith;	state Exp;
branches;
next	1.296;

1.296
date	2006.11.21.14.17.40;	author leith;	state Exp;
branches;
next	1.295;

1.295
date	2006.11.20.17.46.41;	author leith;	state Exp;
branches;
next	1.294;

1.294
date	2006.11.20.16.38.50;	author leith;	state Exp;
branches;
next	1.293;

1.293
date	2006.11.01.19.17.07;	author leith;	state Exp;
branches;
next	1.292;

1.292
date	2006.10.31.17.40.03;	author leith;	state Exp;
branches;
next	1.291;

1.291
date	2006.09.05.18.50.01;	author leith;	state Exp;
branches;
next	1.290;

1.290
date	2006.07.20.18.17.41;	author leith;	state Exp;
branches;
next	1.289;

1.289
date	2006.06.27.15.19.44;	author leith;	state Exp;
branches;
next	1.288;

1.288
date	2006.03.31.19.15.50;	author leith;	state Exp;
branches;
next	1.287;

1.287
date	2006.03.31.16.01.15;	author leith;	state Exp;
branches;
next	1.286;

1.286
date	2006.03.24.19.54.06;	author leith;	state Exp;
branches;
next	1.285;

1.285
date	2006.03.08.15.21.59;	author leith;	state Exp;
branches;
next	1.284;

1.284
date	2006.02.22.19.39.02;	author leith;	state Exp;
branches;
next	1.283;

1.283
date	2006.02.15.21.42.50;	author leith;	state Exp;
branches;
next	1.282;

1.282
date	2006.02.13.18.06.05;	author leith;	state Exp;
branches;
next	1.281;

1.281
date	2006.02.07.18.21.59;	author leith;	state Exp;
branches;
next	1.280;

1.280
date	2006.02.02.20.49.27;	author leith;	state Exp;
branches;
next	1.279;

1.279
date	2006.01.26.16.55.23;	author leith;	state Exp;
branches;
next	1.278;

1.278
date	2006.01.25.21.49.17;	author leith;	state Exp;
branches;
next	1.277;

1.277
date	2006.01.23.17.04.09;	author leith;	state Exp;
branches;
next	1.276;

1.276
date	2006.01.12.21.32.05;	author leith;	state Exp;
branches;
next	1.275;

1.275
date	2006.01.11.19.13.23;	author leith;	state Exp;
branches;
next	1.274;

1.274
date	2006.01.06.14.41.14;	author leith;	state Exp;
branches;
next	1.273;

1.273
date	2006.01.05.20.39.11;	author leith;	state Exp;
branches;
next	1.272;

1.272
date	2005.12.30.18.22.30;	author leith;	state Exp;
branches;
next	1.271;

1.271
date	2005.12.21.21.27.58;	author leith;	state Exp;
branches;
next	1.270;

1.270
date	2005.12.19.19.31.07;	author leith;	state Exp;
branches;
next	1.269;

1.269
date	2005.12.16.01.46.54;	author cyang;	state Exp;
branches;
next	1.268;

1.268
date	2005.12.12.15.59.33;	author leith;	state Exp;
branches;
next	1.267;

1.267
date	2005.12.07.21.18.56;	author leith;	state Exp;
branches;
next	1.266;

1.266
date	2005.11.15.21.50.41;	author leith;	state Exp;
branches;
next	1.265;

1.265
date	2005.10.19.17.37.27;	author leith;	state Exp;
branches;
next	1.264;

1.264
date	2005.10.19.17.35.11;	author leith;	state Exp;
branches;
next	1.263;

1.263
date	2005.10.17.20.26.19;	author leith;	state Exp;
branches;
next	1.262;

1.262
date	2005.10.17.18.18.06;	author leith;	state Exp;
branches;
next	1.261;

1.261
date	2005.09.26.16.40.54;	author leith;	state Exp;
branches;
next	1.260;

1.260
date	2005.09.12.19.29.20;	author leith;	state Exp;
branches;
next	1.259;

1.259
date	2005.09.12.19.10.36;	author leith;	state Exp;
branches;
next	1.258;

1.258
date	2005.09.09.14.42.40;	author leith;	state Exp;
branches;
next	1.257;

1.257
date	2005.08.16.16.25.08;	author leith;	state Exp;
branches;
next	1.256;

1.256
date	2005.07.22.18.50.07;	author leith;	state Exp;
branches;
next	1.255;

1.255
date	2005.07.01.16.05.04;	author leith;	state Exp;
branches;
next	1.254;

1.254
date	2005.06.28.15.42.02;	author leith;	state Exp;
branches;
next	1.253;

1.253
date	2005.04.15.17.37.06;	author leith;	state Exp;
branches;
next	1.252;

1.252
date	2005.03.03.02.28.27;	author cyang;	state Exp;
branches;
next	1.251;

1.251
date	2004.12.09.15.02.23;	author leith;	state Exp;
branches;
next	1.250;

1.250
date	2004.11.19.18.40.21;	author leith;	state Exp;
branches;
next	1.249;

1.249
date	2004.10.20.18.30.51;	author leith;	state Exp;
branches;
next	1.248;

1.248
date	2004.09.30.18.33.12;	author leith;	state Exp;
branches;
next	1.247;

1.247
date	2004.09.20.15.59.18;	author leith;	state Exp;
branches;
next	1.246;

1.246
date	2004.09.20.12.45.19;	author leith;	state Exp;
branches;
next	1.245;

1.245
date	2004.09.14.14.14.48;	author leith;	state Exp;
branches;
next	1.244;

1.244
date	2004.08.18.19.50.25;	author leith;	state Exp;
branches;
next	1.243;

1.243
date	2004.08.05.13.50.46;	author leith;	state Exp;
branches;
next	1.242;

1.242
date	2004.07.28.20.06.48;	author leith;	state Exp;
branches;
next	1.241;

1.241
date	2004.07.14.17.42.23;	author leith;	state Exp;
branches;
next	1.240;

1.240
date	2004.06.12.21.51.31;	author leith;	state Exp;
branches;
next	1.239;

1.239
date	2004.04.06.13.24.54;	author leith;	state Exp;
branches;
next	1.238;

1.238
date	2004.02.02.20.05.08;	author leith;	state Exp;
branches;
next	1.237;

1.237
date	2004.01.14.20.47.56;	author leith;	state Exp;
branches;
next	1.236;

1.236
date	2003.12.03.16.31.18;	author leith;	state Exp;
branches;
next	1.235;

1.235
date	2003.12.03.13.55.42;	author leith;	state Exp;
branches;
next	1.234;

1.234
date	2003.11.24.17.36.18;	author leith;	state Exp;
branches;
next	1.233;

1.233
date	2003.09.16.15.16.18;	author leith;	state Exp;
branches;
next	1.232;

1.232
date	2003.09.08.18.20.42;	author leith;	state Exp;
branches;
next	1.231;

1.231
date	2003.09.08.18.13.57;	author leith;	state Exp;
branches;
next	1.230;

1.230
date	2003.09.04.20.14.55;	author leith;	state Exp;
branches;
next	1.229;

1.229
date	2003.09.04.17.42.57;	author leith;	state Exp;
branches;
next	1.228;

1.228
date	2003.09.04.13.42.10;	author leith;	state Exp;
branches;
next	1.227;

1.227
date	2003.08.18.18.59.21;	author leith;	state Exp;
branches;
next	1.226;

1.226
date	2003.08.07.18.34.45;	author leith;	state Exp;
branches;
next	1.225;

1.225
date	2003.07.18.00.06.03;	author leith;	state Exp;
branches;
next	1.224;

1.224
date	2003.06.11.13.08.23;	author leith;	state Exp;
branches;
next	1.223;

1.223
date	2003.04.02.19.26.16;	author leith;	state Exp;
branches;
next	1.222;

1.222
date	2003.03.24.18.42.26;	author leith;	state Exp;
branches;
next	1.221;

1.221
date	2003.03.04.16.26.57;	author leith;	state Exp;
branches;
next	1.220;

1.220
date	2003.02.26.17.15.47;	author leith;	state Exp;
branches;
next	1.219;

1.219
date	2003.01.23.15.53.37;	author leith;	state Exp;
branches;
next	1.218;

1.218
date	2003.01.02.14.55.56;	author leith;	state Exp;
branches;
next	1.217;

1.217
date	2002.12.30.16.24.17;	author leith;	state Exp;
branches;
next	1.216;

1.216
date	2002.11.20.14.25.38;	author leith;	state Exp;
branches;
next	1.215;

1.215
date	2002.10.10.14.28.15;	author leith;	state Exp;
branches;
next	1.214;

1.214
date	2002.10.07.19.05.50;	author leith;	state Exp;
branches;
next	1.213;

1.213
date	2002.09.13.13.22.40;	author leith;	state Exp;
branches;
next	1.212;

1.212
date	2002.09.11.14.09.53;	author leith;	state Exp;
branches;
next	1.211;

1.211
date	2002.08.14.13.52.40;	author leith;	state Exp;
branches;
next	1.210;

1.210
date	2002.07.08.13.13.55;	author leith;	state Exp;
branches;
next	1.209;

1.209
date	2002.07.02.18.05.57;	author leith;	state Exp;
branches;
next	1.208;

1.208
date	2002.07.02.16.36.21;	author leith;	state Exp;
branches;
next	1.207;

1.207
date	2002.06.28.16.22.03;	author leith;	state Exp;
branches;
next	1.206;

1.206
date	2002.06.26.19.36.37;	author leith;	state Exp;
branches;
next	1.205;

1.205
date	2002.06.14.16.38.16;	author leith;	state Exp;
branches;
next	1.204;

1.204
date	2002.05.17.19.01.21;	author leith;	state Exp;
branches;
next	1.203;

1.203
date	2002.03.19.16.54.03;	author leith;	state Exp;
branches;
next	1.202;

1.202
date	2002.03.07.15.50.39;	author leith;	state Exp;
branches;
next	1.201;

1.201
date	2002.02.27.14.20.15;	author leith;	state Exp;
branches;
next	1.200;

1.200
date	2002.02.13.20.26.34;	author leith;	state Exp;
branches;
next	1.199;

1.199
date	2002.01.30.14.53.16;	author leith;	state Exp;
branches;
next	1.198;

1.198
date	2001.11.19.14.39.53;	author leith;	state Exp;
branches;
next	1.197;

1.197
date	2001.11.13.15.09.44;	author leith;	state Exp;
branches;
next	1.196;

1.196
date	2001.08.06.13.01.16;	author leith;	state Exp;
branches;
next	1.195;

1.195
date	2001.07.31.18.33.59;	author leith;	state Exp;
branches;
next	1.194;

1.194
date	2001.07.27.17.24.04;	author leith;	state Exp;
branches;
next	1.193;

1.193
date	2001.06.15.18.19.29;	author leith;	state Exp;
branches;
next	1.192;

1.192
date	2001.06.05.12.37.20;	author leith;	state Exp;
branches;
next	1.191;

1.191
date	2001.05.30.14.50.07;	author leith;	state Exp;
branches;
next	1.190;

1.190
date	2001.04.18.18.15.17;	author leith;	state Exp;
branches;
next	1.189;

1.189
date	2001.04.16.18.34.44;	author leith;	state Exp;
branches;
next	1.188;

1.188
date	2001.04.09.14.26.48;	author leith;	state Exp;
branches;
next	1.187;

1.187
date	2001.04.06.15.36.53;	author leith;	state Exp;
branches;
next	1.186;

1.186
date	2001.04.06.15.35.16;	author leith;	state Exp;
branches;
next	1.185;

1.185
date	2001.03.27.14.52.27;	author leith;	state Exp;
branches;
next	1.184;

1.184
date	2001.03.19.18.02.11;	author leith;	state Exp;
branches;
next	1.183;

1.183
date	2001.03.19.15.54.26;	author leith;	state Exp;
branches;
next	1.182;

1.182
date	2001.02.23.20.16.01;	author leith;	state Exp;
branches;
next	1.181;

1.181
date	2001.02.22.14.29.27;	author leith;	state Exp;
branches;
next	1.180;

1.180
date	2001.02.15.19.28.53;	author leith;	state Exp;
branches;
next	1.179;

1.179
date	2001.02.08.17.07.08;	author leith;	state Exp;
branches;
next	1.178;

1.178
date	2001.02.02.19.45.17;	author leith;	state Exp;
branches;
next	1.177;

1.177
date	2001.02.01.19.56.59;	author leith;	state Exp;
branches;
next	1.176;

1.176
date	2001.01.26.21.16.12;	author leith;	state Exp;
branches;
next	1.175;

1.175
date	2001.01.24.20.59.30;	author leith;	state Exp;
branches;
next	1.174;

1.174
date	2001.01.23.15.47.23;	author leith;	state Exp;
branches;
next	1.173;

1.173
date	2001.01.10.14.02.59;	author leith;	state Exp;
branches;
next	1.172;

1.172
date	2001.01.05.20.49.42;	author leith;	state Exp;
branches;
next	1.171;

1.171
date	2001.01.04.18.51.34;	author leith;	state Exp;
branches;
next	1.170;

1.170
date	2000.12.20.16.44.33;	author leith;	state Exp;
branches;
next	1.169;

1.169
date	2000.12.18.17.47.18;	author leith;	state Exp;
branches;
next	1.168;

1.168
date	2000.11.21.16.10.23;	author leith;	state Exp;
branches;
next	1.167;

1.167
date	2000.11.01.17.37.53;	author leith;	state Exp;
branches;
next	1.166;

1.166
date	2000.10.18.19.55.10;	author leith;	state Exp;
branches;
next	1.165;

1.165
date	2000.10.13.13.59.50;	author leith;	state Exp;
branches;
next	1.164;

1.164
date	2000.10.12.20.12.38;	author leith;	state Exp;
branches;
next	1.163;

1.163
date	2000.10.12.18.59.37;	author leith;	state Exp;
branches;
next	1.162;

1.162
date	2000.10.12.18.34.09;	author leith;	state Exp;
branches;
next	1.161;

1.161
date	2000.10.10.19.28.55;	author leith;	state Exp;
branches;
next	1.160;

1.160
date	2000.09.27.16.26.48;	author leith;	state Exp;
branches;
next	1.159;

1.159
date	2000.09.19.19.42.49;	author leith;	state Exp;
branches;
next	1.158;

1.158
date	2000.09.19.15.56.17;	author leith;	state Exp;
branches;
next	1.157;

1.157
date	2000.09.18.18.54.31;	author leith;	state Exp;
branches;
next	1.156;

1.156
date	2000.09.07.16.30.25;	author leith;	state Exp;
branches;
next	1.155;

1.155
date	2000.09.05.18.27.40;	author leith;	state Exp;
branches;
next	1.154;

1.154
date	2000.09.05.13.47.57;	author leith;	state Exp;
branches;
next	1.153;

1.153
date	2000.08.31.19.49.30;	author leith;	state Exp;
branches;
next	1.152;

1.152
date	2000.08.30.15.44.56;	author leith;	state Exp;
branches;
next	1.151;

1.151
date	2000.08.14.14.46.46;	author leith;	state Exp;
branches;
next	1.150;

1.150
date	2000.08.14.14.25.24;	author leith;	state Exp;
branches;
next	1.149;

1.149
date	2000.08.08.18.19.37;	author leith;	state Exp;
branches;
next	1.148;

1.148
date	2000.07.31.16.02.21;	author leith;	state Exp;
branches;
next	1.147;

1.147
date	2000.07.17.17.57.14;	author leith;	state Exp;
branches;
next	1.146;

1.146
date	2000.07.05.15.32.04;	author leith;	state Exp;
branches;
next	1.145;

1.145
date	2000.06.20.15.11.03;	author leith;	state Exp;
branches;
next	1.144;

1.144
date	2000.06.13.19.36.34;	author leith;	state Exp;
branches;
next	1.143;

1.143
date	2000.05.26.15.45.28;	author leith;	state Exp;
branches;
next	1.142;

1.142
date	2000.04.28.12.52.34;	author leith;	state Exp;
branches;
next	1.141;

1.141
date	2000.04.24.20.31.09;	author leith;	state Exp;
branches;
next	1.140;

1.140
date	2000.04.10.14.22.04;	author leith;	state Exp;
branches;
next	1.139;

1.139
date	2000.03.28.15.46.11;	author leith;	state Exp;
branches;
next	1.138;

1.138
date	2000.03.28.14.09.30;	author leith;	state Exp;
branches;
next	1.137;

1.137
date	2000.02.18.16.27.05;	author leith;	state Exp;
branches;
next	1.136;

1.136
date	2000.01.10.17.36.28;	author leith;	state Exp;
branches;
next	1.135;

1.135
date	99.12.01.15.09.54;	author leith;	state Exp;
branches;
next	1.134;

1.134
date	99.11.15.21.27.35;	author leith;	state Exp;
branches;
next	1.133;

1.133
date	99.11.02.17.49.21;	author leith;	state Exp;
branches;
next	1.132;

1.132
date	99.11.02.17.46.28;	author leith;	state Exp;
branches;
next	1.131;

1.131
date	99.10.20.14.21.43;	author leith;	state Exp;
branches;
next	1.130;

1.130
date	99.10.19.19.07.41;	author leith;	state Exp;
branches;
next	1.129;

1.129
date	99.10.19.18.35.53;	author leith;	state Exp;
branches;
next	1.128;

1.128
date	99.10.19.14.12.51;	author leith;	state Exp;
branches;
next	1.127;

1.127
date	99.10.18.19.14.57;	author leith;	state Exp;
branches;
next	1.126;

1.126
date	99.10.13.14.39.46;	author leith;	state Exp;
branches;
next	1.125;

1.125
date	99.10.01.14.32.53;	author leith;	state Exp;
branches;
next	1.124;

1.124
date	99.09.30.20.32.17;	author leith;	state Exp;
branches;
next	1.123;

1.123
date	99.09.30.16.02.17;	author leith;	state Exp;
branches;
next	1.122;

1.122
date	99.09.17.17.26.54;	author leith;	state Exp;
branches;
next	1.121;

1.121
date	99.09.17.16.14.56;	author leith;	state Exp;
branches;
next	1.120;

1.120
date	99.09.16.20.16.46;	author leith;	state Exp;
branches;
next	1.119;

1.119
date	99.09.16.20.04.26;	author leith;	state Exp;
branches;
next	1.118;

1.118
date	99.09.15.14.55.01;	author leith;	state Exp;
branches;
next	1.117;

1.117
date	99.09.13.16.11.59;	author leith;	state Exp;
branches;
next	1.116;

1.116
date	99.09.08.16.58.25;	author leith;	state Exp;
branches;
next	1.115;

1.115
date	99.09.01.15.37.11;	author leith;	state Exp;
branches;
next	1.114;

1.114
date	99.08.31.13.14.03;	author leith;	state Exp;
branches;
next	1.113;

1.113
date	99.08.20.13.12.41;	author leith;	state Exp;
branches;
next	1.112;

1.112
date	99.08.19.18.56.49;	author leith;	state Exp;
branches;
next	1.111;

1.111
date	99.08.17.16.19.40;	author leith;	state Exp;
branches;
next	1.110;

1.110
date	99.08.09.20.26.01;	author leith;	state Exp;
branches;
next	1.109;

1.109
date	99.07.19.18.26.38;	author leith;	state Exp;
branches;
next	1.108;

1.108
date	99.07.07.20.59.50;	author pawel;	state Exp;
branches;
next	1.107;

1.107
date	99.06.24.13.33.21;	author leith;	state Exp;
branches;
next	1.106;

1.106
date	99.05.12.19.57.45;	author leith;	state Exp;
branches;
next	1.105;

1.105
date	99.05.12.19.46.12;	author leith;	state Exp;
branches;
next	1.104;

1.104
date	99.04.20.15.26.54;	author leith;	state Exp;
branches;
next	1.103;

1.103
date	99.04.12.15.52.57;	author leith;	state Exp;
branches;
next	1.102;

1.102
date	99.04.06.22.19.09;	author pawel;	state Exp;
branches;
next	1.101;

1.101
date	99.03.22.19.21.38;	author leith;	state Exp;
branches;
next	1.100;

1.100
date	99.03.16.16.04.28;	author leith;	state Exp;
branches;
next	1.99;

1.99
date	99.03.12.20.50.24;	author leith;	state Exp;
branches;
next	1.98;

1.98
date	99.03.02.17.15.35;	author leith;	state Exp;
branches;
next	1.97;

1.97
date	99.02.19.13.28.47;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	99.02.05.16.32.32;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	99.01.11.14.05.21;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	98.12.01.21.02.41;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	98.11.24.20.13.00;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	98.11.12.15.49.10;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	98.11.10.15.20.40;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	98.10.27.18.19.20;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	98.10.20.13.38.18;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	98.09.14.15.27.30;	author leith;	state Exp;
branches;
next	1.87;

1.87
date	98.08.18.19.56.41;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	98.05.04.16.00.21;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	98.04.17.18.39.11;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	98.04.08.14.33.41;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	98.03.31.20.13.19;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	98.03.23.18.51.08;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	98.03.05.15.34.19;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	98.03.04.15.20.43;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	98.02.19.15.57.35;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	98.02.12.19.40.25;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	98.02.03.14.13.13;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	98.01.29.16.22.39;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	98.01.26.21.17.38;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	98.01.26.14.47.16;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	98.01.08.22.06.56;	author hedget;	state Exp;
branches;
next	1.72;

1.72
date	97.12.31.20.56.44;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	97.12.23.18.23.22;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	97.12.23.16.30.30;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	97.12.08.17.32.16;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	97.12.04.16.38.38;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	97.12.03.15.32.08;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	97.11.19.16.47.21;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	97.11.13.16.51.22;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	97.10.31.20.23.52;	author hedget;	state Exp;
branches;
next	1.63;

1.63
date	97.10.30.21.03.27;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	97.10.30.16.34.57;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	97.10.29.18.22.58;	author hedget;	state Exp;
branches;
next	1.60;

1.60
date	97.10.15.20.25.22;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	97.10.15.20.02.11;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	97.10.02.17.12.29;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	97.10.02.13.08.37;	author pawel;	state Exp;
branches;
next	1.56;

1.56
date	97.09.30.21.29.56;	author pawel;	state Exp;
branches;
next	1.55;

1.55
date	97.09.25.13.16.37;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	97.09.17.15.52.55;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	97.08.29.14.00.45;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	97.07.25.14.00.53;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	97.07.24.16.21.17;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	97.05.22.14.47.16;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	97.05.19.13.24.47;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	97.05.16.13.48.46;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	97.05.15.19.07.55;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	97.05.14.20.01.33;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	97.05.13.16.08.51;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	97.04.30.13.33.40;	author pawel;	state Exp;
branches;
next	1.43;

1.43
date	97.04.11.16.33.06;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	97.04.11.12.57.34;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	97.04.01.16.09.10;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	97.01.14.21.17.27;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	96.12.03.20.04.17;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	96.11.22.15.18.41;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	96.11.06.16.46.33;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	96.09.30.16.31.22;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	96.09.25.16.22.57;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	96.09.20.15.06.18;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	96.09.10.15.48.34;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	96.08.16.15.19.38;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	96.08.05.19.07.39;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	96.07.24.14.17.49;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	96.05.17.18.38.08;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	96.02.12.17.11.36;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	96.02.08.16.36.27;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	95.08.21.16.01.12;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	95.08.11.20.09.05;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	95.08.11.17.51.00;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	95.08.03.18.52.06;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	95.07.28.15.33.09;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	95.05.23.20.03.14;	author mladjadj;	state Exp;
branches;
next	1.20;

1.20
date	95.05.05.20.22.36;	author mladjadj;	state Exp;
branches;
next	1.19;

1.19
date	95.05.04.18.06.20;	author mladjadj;	state Exp;
branches;
next	1.18;

1.18
date	95.04.28.16.31.12;	author mladjadj;	state Exp;
branches;
next	1.17;

1.17
date	95.04.28.15.43.52;	author mladjadj;	state Exp;
branches;
next	1.16;

1.16
date	95.04.26.20.19.46;	author mladjadj;	state Exp;
branches;
next	1.15;

1.15
date	95.04.21.16.40.55;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	95.04.17.19.13.02;	author mladjadj;	state Exp;
branches;
next	1.13;

1.13
date	95.02.07.12.32.53;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	95.02.06.16.26.27;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	95.01.06.11.48.24;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	94.12.06.14.16.50;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	94.12.05.13.27.48;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	94.11.14.11.27.18;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	94.11.14.10.51.27;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	94.11.01.21.30.16;	author mladjadj;	state Exp;
branches;
next	1.5;

1.5
date	94.09.21.09.38.16;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	94.09.14.13.51.56;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	94.08.26.14.46.43;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.08.26.14.20.02;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.14.11.19;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.500
log
@version
@
text
@
C ++********************************************************************
C                                                                      *
C SPIDER : (System for Processing Image Data in                        *
C           Electron microscopy and Related fields)                    *
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2020  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the      *
C=* GNU General Public License (www.gnu.org/licenses) for details.     *
C=*                                                                    *
C **********************************************************************
C                                                                      *
C  PURPOSE: MAIN ROUTINE FOR SPIDER IMAGE PROCESSING SYSTEM.           *
C                                                                      *
C  LUN ASSIGNMENTS: LUN     INTERACTIVE   IN PROC.         CONNECTS    *
C                   NLOGP        1           1                LOG      *
C                   NLOG         1           0                         *
C                   LUNSPIRE     2           2               SPIRE     *
C                   NDAT         3           3              RESULTS    *
C                   NDOC         4           4             A DOCFILE   *
C                   NSTDINP      5           5               STDIN     *
C                   NIN          5          5/1                        *
C                   NOUT         6           3                         *
C                   NSTDOUTP     6           6              STDOUT     *
C                                                                      *
C                   LUNTEXT    103                         SYMPAR TXT  *
C                   LUNDO      301                         LUNDO FILE  *
C                              200...200+MAXICDOCS          SAVDOCQ    *
C                                                                      *
C  UPDATE VERSION STATEMENT (MARKED BY CHERE) WHEN VERSION IS CHANGED! *
C                                                                      *
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

#ifdef  HAS_IEEE
#ifndef USE_MPI
#ifndef __APPLE__
        USE, intrinsic :: ieee_exceptions
#endif
#endif
#endif

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ PARAMETER  INITIALIZATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C       ONE PLUS THE MAXIMUM NUMBER OF REGISTERS PER KEY IN 'UD IC'
        INTEGER, PARAMETER :: MAXREG=7     

C       MAXIMUM NUMBER OF KEYS IN 'UD IC'
        INTEGER, PARAMETER :: MAXKEY=9999  

C       MAXIMUM NUMBER OF REGISTER ARGUMENTS SENT TO A PROCEDURE
        INTEGER, PARAMETER :: NPARG=24    

C       MAXIMUM NUMBER OF NESTED 'IF's
        INTEGER, PARAMETER :: MAXIF=20      
    
C       COMMON BLOCK SPACE RESERVATION USED AT ALBANY, IS NOW ONLY 5 MB. 
C       (MOST ROUTINES NOW USE RUN-TIME ALLOCATION OF MEMORY WHICH 
C       IS INDEPENDENT OF THE COMMON BLOCK AND MAXDI ASSIGNMENT.
C       WE USUALLY HAVE > 2 GB RAM AVAILABLE ON ALBANY MACHINES
 
        INTEGER, PARAMETER  :: MAXDI = 5000000
        INTEGER             :: PLINEGO(MAXDI/5)
        CHARACTER           :: PDATA(4*4*MAXDI/5)
        COMMON                 PLINEGO,PDATA

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  DECLARATIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        INTEGER   :: IDOSTK(7,MAXPRC),NARGSREC(MAXPRC),LOOPSV(8,MAXPRC)
        INTEGER   :: IARGSENT(NPARG,MAXPRC),IARGSREC(NPARG,MAXPRC)
        INTEGER   :: IFSV(MAXPRC)
        INTEGER   :: NUML(3)
        INTEGER   :: getpid
        INTEGER   :: NEWLOOP

        LOGICAL   :: USEELSE(MAXIF,MAXPRC)
        LOGICAL   :: JUMP,EX,ISDIGI,ISCHAR,DELETIT,LISTIT
        LOGICAL   :: GLOBAL,ISATAT,SAYIT

        CHARACTER(LEN=MAXNAM) :: PNAME
        CHARACTER(LEN=MAXNAM) :: PROCFL(MAXPRCNAM)
        CHARACTER(LEN=MAXNAM) :: RESULT,LOG,SPIRE_FILE

        CHARACTER(LEN=160)    :: MESG,PLINE,ARG4,ARGNOW,FCHARNOBLANK
        CHARACTER(LEN=40)     :: CVERS
        CHARACTER(LEN=12)     :: CDATT
        CHARACTER(LEN=8)      :: ZEIT
        CHARACTER(LEN=7)      :: RESULM
        CHARACTER(LEN=5)      :: LABEL 
        CHARACTER(LEN=4)      :: CXNUM,CREG
        CHARACTER(LEN=3)      :: LOGM
        CHARACTER(LEN=2)      :: NQ12
        CHARACTER(LEN=1)      :: NULL,RESPONSE

C       DBUF = COMMON TEMPORARY BUFFER FOR DOCUMENT FILE(S) 
C       NO LONGER USED FOR 'INCORE' DOCUMENT FILES 
        COMMON /DOC_BUF/ DBUF(MAXREG,MAXKEY,2)

        COMMON /DRIV1_COM/ T1,LOOPREG,CXNUM

C       MAKE SURE FIRST SIZING OF IOBUF IS LARGE
        COMMON /IOBUF/   BUFIO(NBUFSIZ)

C       MAKE SURE FIRST SIZING OF COMMUN IS LARGE
        INTEGER, PARAMETER :: NCOMSIZ = 8000
        COMMON /COMMUN/ BUFC(NCOMSIZ)

        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF

        INTEGER                    :: ITIME(8)

C       RANDOM NUMBER GENERATOR SEED
#if defined (SP_GFORTRAN)  || defined(__GFORTRAN__)
        INTEGER,ALLOCATABLE        :: ISEED(:)       
#else
        INTEGER                    :: ISEED(2)       
#endif

C       FOR LOCAL VARIABLE HANDLING 
        INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
        COMMON /QSTR_STUFF1/ ISTOPR,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                       IPNUMSTACK,IPARNUM

        COMMON /PROC_STUFF/ NUMPROCNOW

C       SIZING OF GOTLAB FOR CHECKING DUPLICATE LABELS
        INTEGER, PARAMETER   :: MAXNUMLAB = 50
        INTEGER              :: LABGOT(MAXNUMLAB)

C       LOGICAL UNIT NUMBERS DEFINED HERE
        INTEGER, PARAMETER   :: LUNDO    = 300   
        INTEGER, PARAMETER   :: LUNSPIRE = 2   
        INTEGER, PARAMETER   :: LUNTEXT  = 103 
  
        LOGICAL              :: RES_TO_TERM = .FALSE. ! UNUSED?
        LOGICAL              :: USEPUBSUB    ! HAS COSMETIC EFFECTS

        INTEGER  :: omp_get_stack_size
        INTEGER  :: isiz1,isiz2

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DATA STATEMENTS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ VERSION INITIALIZATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

CHERE               123456789 123456789 123456789 1234567890 
        DATA CVERS/'VERSION:  UNIX 26.06  ISSUED:  6/30/2020'/

        DATA RESULM/'results'/
        DATA LOGM/'LOG'/

C       SOME DO LOOP PARAMETERS
        DATA IDOTOP,IFLEVEL/1,0/

#ifdef USE_MPI
        INCLUDE 'mpif.h'
        DOUBLE PRECISION :: TT0, TT1   
        LOGICAL          :: ONLYONE_RED,ONLYONE_WRT
        COMMON /COMM_MPI/ONLYONE_RED,ONLYONE_WRT

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  CODE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        IN_PARALLEL = .FALSE.
        ONLYONE_RED = .TRUE.
        ONLYONE_WRT = .TRUE.

        CALL MPI_INIT(MPIERR)
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID,  MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)
#ifdef MPI_DEBUG
        IF (MYPID == 0)WRITE(6,*) ' NPROCS, ICOMM: ', NPROCS,ICOMM
        TT0 = MPI_WTIME()
#endif
#else
C       NOT USING MPI
        MYPID = -1
#endif

#ifdef SP_MP
C       NEEDED BY PGI 2013.10 COMPILER

#ifndef USE_MPI
#ifndef __APPLE__
#if defined(SP_IFC) || defined(__INTEL_COMPILER)
        isiz1 = kmp_get_stacksize()
        CALL kmp_set_stacksize(65536)
        isiz2 = kmp_get_stacksize()
#else
	isiz1 = omp_get_stack_size()
	CALL omp_set_stack_size(65536)
	isiz2 = omp_get_stack_size()
#endif
        !write(6,*) ' OMP Stack size: ',isiz1,' -->',isiz2
#endif
#endif
#endif

C       INITIALIZE COMMON BLOCK LUNS
C       NLOGP IS FOR LOG FILE,  NLOG = NLOGP WHEN LOG IS IN USE
        NLOGP     = 1  
        NLOG      = NLOGP
        NECHO     = 0        ! COUNTER FOR LOG FILE OUTPUT

C       NDAT IS FOR RESULTS FILE,  NOUT=NDAT=3 WHEN RESULTS FILE IN USE
        NDAT      = 3

        NSTDINP   = 5
        NIN       = NSTDINP
        NSTDOUTP  = 6
        NOUT      = NSTDOUTP

C       INITIALIZE SOME COMMON BLOCK DATA ELEMENTS (SEE: setmode.f)
        ISTOP          = 1
        ISTOPR         = 1
        IBCNT          = 0
        NLOOP          = 0       ! TOTAL NUMBER OF LOOP ITERATIONS
        ILOOP          = 1       ! CURRENT LOOP ITERATION
        IFOUND         = 1
        NTRACE         = 0
        VERBOSE        = .TRUE.
        SILENT         = .FALSE.
        USE_LONGCOL    = .FALSE. 
        LEGACYPAR      = .FALSE. ! () IN DO NO LONGER! DEC 2010
        USE_FBS_INTERP = .FALSE. ! NEW JUL 2011
        NECHO          = 0       ! COUNTER FOR LOG FILE OUTPUT
        MAXDIM         = MAXDI   ! SET SIZE OF COMMON BUFFER
        NUMFFTWTH      = 0       ! NUMBER OF FFTW3 THREADS
        NULL           = CHAR(0)
        NQ12           = CHAR(34) // CHAR(39)   ! QUOTES
        MRC_AXIS       = 'UL L'

C       SET ISEED  TO INITIAL "RANDOM" VALUE USING CLOCK
#if defined (SP_GFORTRAN)  || defined(__GFORTRAN__)
        CALL RANDOM_SEED(SIZE = N)
        ALLOCATE(ISEED(N))
        CALL SYSTEM_CLOCK(COUNT = ICLOCK)
        ISEED = ICLOCK + 37 * (/ (I - 1, I = 1, N) /)
        CALL RANDOM_SEED(PUT = ISEED)
        DEALLOCATE(ISEED)
#else
        CALL DATE_AND_TIME(VALUES=ITIME)       ! GET CURRENT TIME
        ISEED(1) = ITIME(4) * (360000*ITIME(5) + 6000*ITIME(6) + 
     &             100*ITIME(7) + ITIME(8))
        IF (ISEED(1) == 0 .AND. ISEED(2) == 0) THEN
C          KLUDGE TO PREVENT ERROR ON SOME INTEL PROCESSORS
           write(0,*) ' Using default random number seed'
           CALL RANDOM_SEED()
        ELSE
           CALL RANDOM_SEED(PUT = ISEED)
        ENDIF
#endif

C       TIME TM IS ASSUMED AT BEGINNING OF RUN.  
        T1 = SECNDS(0.0)

C       INITIALIZE DO_LOOP STACK VARIABLES
        DO I=1,5
           IDOSTK(I,1) = 1
        ENDDO
        IDOSTK(4,1) = 0
        IDOSTK(6,1) = 0
        IDOSTK(7,1) = 1
        LOOPREG     = 0    ! REG. FOR LOOP COUNTER
        IFSV(1)     = 0

C       INITIAL MODE IS INTERACTIVE.
        COPT = 'I'

C       INITIALIZE PROCFL & NUMPRC USED TO TRACK OF PROCEDURE LISTING:
C       PROCEDURES LOADED & LISTED ON 1'ST OCCURRENCE ONLY
        DO NUMPROCNOWT=1,MAXPRCNAM
           PROCFL(NUMPROCNOWT)(:MAXNAM) = ' '
        ENDDO
        NUMPRC     = 1
        NUMPROCNOW = 1

C       PUT THE STARTING PROCEDURE FILE NAME ON THE STACK
        IPNUMSTACK(ISTOP) = 1
        PROCFL(1)(:MAXNAM) = 'INTERACTIVE'

C       INITIALIZE REGISTERS FOR MAIN BANK
        CALL REG_INIT(1,IRTFLG)
 
C       INITIALIZE GLOBAL SYMBOL STORAGE
        CALL SETSYMPAR(NULL,RESPONSE,.FALSE.,IRTFLG)
C       INITIALIZE SYMBOL INFO FOR INITIAL PROCEDURE = 1
        CALL SETSYMPAR(NULL,RESPONSE,.TRUE.,IRTFLG)
      
C       GET THE DATE AND TIME
        CALL DATE_2K(CDATT)
        CALL MYTIME(CTIM)

C       GET DATEXC, RESULTS FILE VERSION, FIRST OP & REGISTER SETTING
C       AND USE_SPIRE SETTING
        CALL INITUNIX(NUMARG,FCHAR,NALPH,CXNUM,MESG,USEPUBSUB)

        IF (MYPID <= 0) THEN 
          IF (.NOT. USEPUBSUB) THEN
C           PRINT OUT HEADING WITH VERSION AND RELEASE DATES
            WRITE(NOUT,*)' '
            WRITE(NOUT,9090)
            WRITE(NOUT,9091)
            WRITE(NOUT,9092)
            WRITE(NOUT,9093)CVERS
            WRITE(NOUT,9094)CDATT(1:11),CTIM

#if defined(SP_IFC) || defined(__INTEL_COMPILER)
 9090   FORMAT('  \__`O O''__/        SPIDER -- COPYRIGHT')
#else
 9090   FORMAT('  \\__`O O''__/        SPIDER -- COPYRIGHT')
#endif

 9091   FORMAT('  ,__xXXXx__         HEALTH RESEARCH INC., MENANDS, NY') 
 9092   FORMAT('   __xXXXx__')

#if defined(SP_IFC) || defined(__INTEL_COMPILER)
 9093   FORMAT('  /  /xxx\  \        ',A)
 9094   FORMAT('    /     \          DATE:     ',A,'    AT  ',A,/)
#else
 9093   FORMAT('  /  /xxx\\  \\        ',A)
 9094   FORMAT('    /     \\          DATE:     ',A,'    AT  ',A,/)
#endif

            WRITE(NOUT,9097)
 9097       FORMAT('  If SPIDER is useful, please cite:',/,
     &        '  Frank J, Radermacher M, Penczek P, Zhu J, Li Y,',
     &         ' Ladjadj M,  Leith A.',/,
     &       '  SPIDER and WEB: Processing and visualization of images',
     &         ' in 3D electron ',/,
     &        '  microscopy and related fields.  J. Struct. Biol.',
     &         ' 1996; 116: 190-199.')

            WRITE(NOUT,*) ' '
            NCT = lnblnk(MESG)
            WRITE(NOUT,9095) MESG(1:NCT)    
9095        FORMAT('  Running:     ',A)
            WRITE(NOUT,*) ' '    
          ENDIF
        ENDIF

        IF (NUMARG <= 0) THEN
C          GET THE PROJECT AND DATA EXTENSION FROM USER
           NLOG       = 0
           FCHAR(1:3) = 'NC' // CHAR(0)
           CALL DRIV1(MAXDIM)
           NLOG       = NLOGP
        ENDIF

C       CREATE NAME FOR LOG FILE AND OPEN THE LOG FILE
        CALL FILNAMANDEXT(LOGM,PRJEXC,LOG,NLET,.FALSE.,IER)
        IF (IER .NE. 0)
     &     STOP '*** UNABLE TO CONSTRUCT LOG FILE NAME ***'

        OPEN(NLOG,FILE=LOG,STATUS='UNKNOWN',IOSTAT=IER)
        IF (IER .NE. 0) 
     &     STOP '*** UNABLE TO OPEN LOG FILE ***'

C       CREATE NAME FOR THE RESULTS FILE
        CALL FILNAMANDEXT(RESULM,PRJEXC,RESULT,NRESUL,.FALSE.,IER)
        IF (IER .NE. 0) 
     &     STOP '*** UNABLE TO CONSTRUCT RESULTS FILE NAME ***'

C       INCREMENT THE RESULTS FILE VERSION IF EXISTING
        IF (MYPID <= 0) THEN

#ifndef SP_NO_VERSION
           SAYIT = .NOT. USEPUBSUB
           CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,CXNUM,SAYIT)
#endif

C          APPEND TO EXISTING RESULTS FILE
           INQUIRE(FILE=RESULT,EXIST=EX)
           IF (EX) THEN
              OPEN(NDAT,FILE=RESULT,STATUS='OLD',POSITION='APPEND',
     &             IOSTAT=IER)
           ELSE
              OPEN(NDAT,FILE=RESULT,STATUS='REPLACE',IOSTAT=IER)
           ENDIF
           IF (IER .NE. 0) STOP '*** UNABLE TO OPEN RESULTS FILE ***'

           IF (USEPUBSUB) THEN
             LENT = lnblnkn(RESULT)
             WRITE(NOUT,9089) CVERS(17:),CDATT(1:11),CTIM,RESULT(:LENT) 
 9089        FORMAT('  SPIDER: ',A,2X,'In parallel:',2X,
     &              A,2X,A,' Results: ',A)

             WRITE(NDAT,9089) CVERS(17:),CDATT(1:11),CTIM ,RESULT(:LENT)
             WRITE(NDAT,9086) PRJEXC(1:3),DATEXC(1:3)
9086         FORMAT('  Project extension: ',A,3X,'Data extension: ',A)

           ELSE

C            PRINT OUT HEADING WITH VERSION AND RELEASE DATES
             WRITE(NDAT,9090)
             WRITE(NDAT,9091)
             WRITE(NDAT,9092)
             WRITE(NDAT,9093) CVERS
             WRITE(NDAT,9094) CDATT(1:11),CTIM
             WRITE(NDAT,9096) PRJEXC(1:3),DATEXC(1:3)
9096         FORMAT('  Project extension: ',A,3X,'Data extension: ',A)
             NCT = lnblnk(MESG)
             WRITE(NDAT,9095) MESG    

           ENDIF

C          FLUSH RESULTS FILE TO ENSURE THAT IT IS CREATED NOW
           CALL FLUSHRESULTS_Q(.FALSE.)

           IF (USE_SPIRE) THEN
C             SPIRE IN USE, OPEN SPIRE OUTPUT FILE
              SPIRE_FILE = 'spireout' // RESULT(8:) 
              OPEN(LUNSPIRE,FILE=SPIRE_FILE,STATUS='REPLACE',IOSTAT=IER)

              MESG = ' Running: ' // MESG  
              CALL SPIREOUT(MESG,IRTFLG)     ! Running: SPIDER executable
              CALL SPIREOUT(CVERS,IRTFLG)    ! Version
              MESG = 'DATE:    ' // CDATT(1:11) // '    AT  ' // CTIM  
              CALL SPIREOUT(MESG,IRTFLG)     ! Date and time
              CALL SPIREOUT(RESULT,IRTFLG)   ! Results file name
#if defined (SP_GFORTRAN)  || defined(__GFORTRAN__)
              IPID =  getpid()
#else
              IPID =  getpid(IPID)
#endif
              WRITE(MESG,9098) IPID
9098          FORMAT('  Current process id: ',I9)
              CALL SPIREOUT(MESG,IRTFLG)     ! Process id
              CALL FLUSHFILE(LUNSPIRE)
           ENDIF

        ENDIF

C       SKIP OPERATION INPUT IF FIRST OPERATION ON COMMAND LINE
        IF (NUMARG > 1) GOTO 5300
        GOTO 5000

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ OPERATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

5000    CONTINUE

C       SEE IF WE MUST COPY LINE TO INTERACTIVE DO LOOP FILE IN RDPR
        LUNDONOW = 0
        IF (COPT == 'I' .AND. NLOOP > 0 .AND. ILOOP == 1) THEN 
           LUNDONOW = LUNDO
           IF (IDOTOP >= 2 ) THEN
              LUNDONOW = LUNDO
              DO I = 1,IDOTOP-1
                 IF (IDOSTK(1,I) > 1) LUNDONOW = 0
              ENDDO
           ELSEIF (IDOTOP == 1) THEN
              IF (NLOOP <= 0) LUNDONOW = 0
           ENDIF
        ENDIF  

C       GET THE NEXT OPERATION, DOES NOT CONVERT INPUT TO UPPERCASE
        SILENT  = .FALSE.
        FCHAR   = NULL
        CALL RDPROP('OPERATION',FCHAR,NALPH,IRTFLG)

C       IF OPERATION IS A COMMENT OR NULL, IGNORE IT.
5100    IF (NALPH  < 1 .OR. 
     &      FCHAR(:1) == ';' .OR. 
     &      FCHAR(:1) == '!') GOTO 5000 

5300    IF (NTRACE > 0 .AND. MYPID <= 0) THEN
           IF (IABSLP .NE. 0 .AND. LOOPREG .NE. 0) THEN
              CALL REG_GET_NAME(LOOPREG,MESG,NLET,IRTFLG)
              WRITE(NSTDOUTP,9039) MESG(1:NLET),IABSLP
9039          FORMAT('  LOOP INDEX (',A,') = ',I8)
           ENDIF
        ENDIF

        !write(6,*) ' idotop: ',idotop, ' at: ',fchar(1:nalph)

C       IF THE FIRST CHARACTER IS '@@', GOTO PROCEDURE EVALUATION
        IF (FCHAR(:1) == '@@') GOTO 5600

C       IF VARIABLE ASSIGNMENT', SET VARIABLE
        !write(6,*) 'fchar: ',fchar(1:nalph),':', nalph

        ILBRAK = INDEX(FCHAR(1:NALPH),'[')
        IF (ILBRAK > 0) THEN
           IEQ =  INDEX(FCHAR(1:NALPH),'=')
           IF (IEQ > ILBRAK) THEN

C             EQUAL SIGN AFTER BRACKET, CHECK FOR GLOBAL
              GLOBAL = (FCHAR(1:2) == 'GL' .OR. FCHAR(1:2) == 'gl'
     &             .OR. FCHAR(1:2) == 'Gl' .OR. FCHAR(1:2) == 'gL')
 
C             CREATE AND ASSIGN SYMBOLIC (STRING) VARIABLE
              CALL EQU_SYMPAR(FCHAR(1:NALPH),GLOBAL,IRTFLG)
              IF (IRTFLG == 0) GOTO 5000   ! HAVE SET THE VARIABLE
              IF (IRTFLG == 1) GOTO 5000   ! ERROR IN SETTING

C             REGISTER ASSIGNMENTS RETURN: IRTFLG = 2
              IF (IRTFLG == 2) THEN
C                REGISTER ASSIGNMENT, SUBSTITUTE FOR ALL SYM. VAR.
                 CALL SUBSYMPAR(FCHAR(1:NALPH),FCHAR,NALPH,0,IRTFLG)
              ENDIF
           ENDIF
        ENDIF
        
C       IF THE FIRST OR SECOND CHARACTER IS NEITHER A 
C       LETTER NOR A DIGIT, CONSIDER OPERATION AN EXPRESSION
        IF(((.NOT. ISCHAR(FCHAR(1:1)))   .AND.
     &      (.NOT. ISDIGI(FCHAR(1:1))))  .OR.
     &     ((.NOT. ISCHAR(FCHAR(2:2)))   .AND.
     &      (.NOT. ISDIGI(FCHAR(2:2))))) GOTO 6800

C       IF THE FIRST THREE CHARACTERS ARE LETTERS AND THE FORTH IS '('
C       THEN IT MUST BE AN ON-LINE FUNCTION CALL. GOTO EXPRESSION EVAL.
C       FCHAR(5:5) ALLOWS MIS-TYPING SQRT(...) FOR SQR(...)

        IF ((ISCHAR(FCHAR(1:1))) .AND. (ISCHAR(FCHAR(2:2))) .AND. 
     &      (ISCHAR(FCHAR(3:3))) .AND.
     &      (FCHAR(4:4)=='('   .OR. FCHAR(5:5)=='(' )) GOTO 6800

C       IF THE OPERATION STARTS WITH A [] , EVALUATE EXPRESSION.
        IF (FCHAR(1:1) == '[') GOTO 6800

C       CHAR FOLLOWED BY 2 DIGITS IS OLD STYLE BATCH (B01) CALL
        IF (ISCHAR(FCHAR(1:1)) .AND.
     &      ISDIGI(FCHAR(2:2)) .AND. ISDIGI(FCHAR(3:3)) .AND.
     &      NALPH == 3) GOTO 5600

C       OK TO TRANSLATE OPERATION STRING TO UPPER CASE NOW
        CALL SSUPCAS_NOVAR(FCHAR)

C       IF A LABEL 'LB<DIGIT> IS FOUND, AND A DO-LOOP IS IN EFFECT ...
        IF (FCHAR(1:2) == 'LB' .AND. NLOOP >= 1) GOTO 8800
C       IF A ENDDO IS FOUND, AND A DO-LOOP IS IN EFFECT ...
        IF (FCHAR(1:5) == 'ENDDO'  .AND. NLOOP >= 1) GOTO 8800
        IF (FCHAR(1:6) == 'END DO' .AND. NLOOP >= 1) GOTO 8800

C       IF A LABEL IS FOUND, AND NO DO-LOOP IS IN EFFECT ...
        IF (FCHAR(1:2) == 'LB' .AND. NLOOP <= 0) GOTO 5000

C       RESET FFTW3 CACHE 
        CALL FMRS_DEPLAN(IRTFLG)

C       TSWITCH IS MAIN SELECTION PROGRAM FOR OPERATIONS OUTSIDE MAIN
        CALL TSWITCH(IWHICH,ICOM,MAXDIM,IRTFLG)
 
C       IF OPERATION FOUND OUTSIDE OF SPIDER MAIN, GET NEXT OPERATION
        IF (IRTFLG == 0) GOTO 5000
         
C       OPERATION IS NOT IN OUTSIDE MENU. SEARCH LOCAL SUBMENU FOR
C       SPECIFIC LOOPING, IF, EN, ETC OPERATIONS
C       HANDLE LONG LOCAL 'OPERATIONS'

        IF (FCHAR(1:6) == 'ELSEIF' .OR.
     &      FCHAR(1:7) == 'ELSE IF')  GOTO 10795
        IF (FCHAR(1:2) == 'IF'  .OR.
     &      FCHAR(1:2) == 'GO')       GOTO 10800
        IF (FCHAR(1:4) == 'ELSE')     GOTO 10798
        IF (FCHAR(1:5) == 'ENDIF')    GOTO 10799
        IF (FCHAR(1:5) == 'CYCLE')    GOTO 10796
        IF (FCHAR(1:4) == 'EXIT')     GOTO 10797

C       HANDLE SHORT LOCAL OPS: 'EN','DO','LB','RE','MD','OF','IQ VER'
        SELECT CASE(FCHAR(1:2))
          CASE ('EN')
             GOTO 8400
          CASE ('DO')
             GOTO 8600
          CASE ('LB')
             GOTO 8800
          CASE ('RE')
             GOTO 10000
          CASE ('MD')
             GOTO 8500
          CASE ('IQ')
             GOTO 8300
        END SELECT

C       ANY REMAINING OPERATION ASSUMED TO BE ARITHMETIC EXPRESSION
6800    CALL ARASQ(FCHAR,NALPH,GLOBAL,IFLAG)
        IF (IFLAG .NE. 0)THEN
C          EXPRESSION IS NO GOOD - IF IN PROCEDURE, TERMINATES
           MESG = 'UNDEFINED OPERATION OR EXPRESSION: ' // FCHAR
           CALL ERRT(101,MESG,NE)
        ENDIF
        GOTO 5000

C       COMMON TERMINATE ON ERROR SEQUENCE IN PROCEDURE -------------
9999    CALL ENDIT('SHOULD NEVER GET HERE',.FALSE.,RESULT)
        STOP '**** FATAL ERROR'

C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START PROCEDURE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

5600    CONTINUE

C       SET FLAG FOR PROCEDURE/INTERACTIVE MODE WHEN PROCEDURE WAS CALLED
        FROMBATCH = (COPT == 'B')
        NCHAR     = NALPH
        ISATAT    = (FCHAR(1:2) == '@@@@')

C       COPY ARGUMENT LIST IF PRESENT -------------------------------
C       IF REGISTERS ARE FOUND, THEN NARGREG > 0
        NCHAR    = NALPH
        ILEFPAR = INDEX(FCHAR(1:NCHAR),'(')
        IF (ILEFPAR > 0 .AND. ISATAT) THEN
           CALL ERRT(101,
     &           'ARGUMENT TRANSFER NOT ALLOWED WITH @@@@PROCEDURE',NE)
           GOTO 5000

        ELSEIF (ILEFPAR > 0) THEN
C          SAVE REGISTER LIST SENT TO NEW PROC. IN IARGSENT

           CALL REG_GET_SEL(ISTOP,FCHAR(ILEFPAR:NCHAR),.TRUE.,.TRUE.,
     &                      NARGREG,IRTFLG)
           CALL REG_GET_SELS(IARGSENT(1,ISTOP+1),NPARG,NREG,IRTFLG)
C          CUT OFF THE ARGUMENT STRING
           NCHAR = ILEFPAR - 1
        ENDIF

C       TRY TO FIND PROCEDURE FILE LISTED IN THE OPERATION
        CALL GETPROCFILE(FCHAR,NCHAR,PNAME,NPNAME,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 5000

C       INCREMENT PROCEDURE STACK LEVEL COUNTER
        ISTOP  = ISTOP + 1 
        ISTOPR = ISTOP
        IF (ISATAT) ISTOPR = ISTOPR - 1

        IF (ISTOP > MAXPRC) THEN
C          LIMIT IS MAXPRC PROCEDURES !! LET USER KNOW 
           CALL ERRT(102,'PROCEDURE NESTING LEVEL EXCEEDED',MAXPRC)
        ENDIF

C       SAVE DO-LOOP INFO FOR CALLING PROCEDURE IN PROCEDURE'S STACK
        LOOPSV(1,ISTOP) = ILOOP     ! CURRENT LOOP ITERATION
        LOOPSV(2,ISTOP) = IABSLP    ! CURRENT LOOP COUNTER
        LOOPSV(3,ISTOP) = LOOPREG   ! REG. FOR LOOP COUNTER
        LOOPSV(4,ISTOP) = NLOOP     ! NUMBER OF ITERATIONS FOR LOOP
        LOOPSV(6,ISTOP) = IDOTOP    ! LOOP STACK POINTER
        LOOPSV(7,ISTOP) = LBNO      ! LABEL/NDOLINE FOR END OF CURRENT LOOP
        LOOPSV(8,ISTOP) = LOOPINC   ! LOOP COUNTER INCREMENT

C       SAVE THE IFLEVEL VALUES IN THE CALLED PROCEDURE STACK
        IFSV(ISTOP) = IFLEVEL
        IFLEVEL     = 0

C       INITIALIZE VARIABLE INFO FOR NEW PROCEDURE
        CALL SETSYMPAR(NULL,RESPONSE,.TRUE.,IRTFLG)

C       RE-SET DO-LOOP INFO INSIDE CALLED PROCEDURE
        ILOOP   = 1      ! CURRENT LOOP ITERATION
        IABSLP  = 0      ! CURRENT LOOP COUNTER
        NLOOP   = 0      ! NUMBER OF ITERATIONS FOR LOOP
        LOOPREG = 0      ! REG. FOR LOOP COUNTER
        LOOPINC = 1      ! LOOP COUNTER INCREMENT

C       SAVE ALL THE DO-LOOP VALUES IN THE CALLED PROCEDURE STACK
        IDOTOP           = IDOTOP + 1 ! LOOP STACK POINTER
        IDOSTK(1,IDOTOP) = ILOOP      ! CURRENT LOOP ITERATION
        IDOSTK(2,IDOTOP) = IABSLP     ! CURRENT LOOP COUNTER
        IDOSTK(3,IDOTOP) = LOOPREG    ! REG. FOR LOOP COUNTER
        IDOSTK(4,IDOTOP) = NLOOP      ! NUMBER OF ITERATIONS FOR LOOP
        IDOSTK(5,IDOTOP) = ISTOP      ! PROCEDURE STACK LEVEL
        IDOSTK(6,IDOTOP) = LBNO       ! LABEL/NDOLINE FOR END OF CURRENT LOO
        IDOSTK(7,IDOTOP) = LOOPINC    ! LOOP COUNTER INCREMENT

C       PUT IBCNT ON STACK, IF IT ISN'T FIRST CALL, STACK OFFSET
        IPSTACK(ISTOP) = IBCNT

        IF (COPT == 'I') THEN
C         WRITE IT, SINCE NOT ECHOED IN RESULTS FILE IN INTERACTIVE MODE
          IF (MYPID <= 0) THEN
             WRITE(NDAT, 6320)
6320         FORMAT(/,' .OPERATION:')
             WRITE(NDAT, 6340) FCHAR(1:80)
6340         FORMAT(5X,A)
          ENDIF

C         WE'RE NOW IN PROCEDURE MODE, WRITE OUT HEADING.
          COPT = 'B'
        ENDIF

        IF (MYPID <= 0) THEN
           IF (VERBOSE) WRITE(NDAT, *) ' '
           WRITE(NDAT, 6380) PNAME(1:NPNAME)
6380       FORMAT('  -- START OF: ',A,'    --')
        ENDIF 

C       INITIALIZE NEW BANK OF REGISTERS FOR NEW PROCEDURE
        CALL REG_INIT(ISTOPR,IRTFLG)

        IF (NUMARG >= 4) THEN
C          SET INITIAL REGISTERS IN THIS PROCEDURE FROM COMMAND LINE
C          !write(6,*) 'Number of intial arguments: ',numarg
           CALL getarg(4,ARG4)
           NLETA = lnblnk(ARG4)

           DO NARG = 5,NUMARG
C             CONCATENATE FOLLOWING ARGUMENTS (IF ANY) ONTO ARG4
              CALL getarg(NARG,ARGNOW)
              NLETN = lnblnk(ARGNOW)
              ARG4  = ARG4(1:NLETA) // ' ' // ARGNOW(1:NLETN) 
              NLETA = NLETA + NLETN + 1
           ENDDO

           !write(6,*) 'intial arguments: ',ARG4(1:NLETA)
           IFIRST = 1
           DO WHILE (IFIRST < NLETA) 
              CALL GETNEXTTOKEN(ARG4,IFIRST,IGO,IEND)
              IF (IGO <= 0) EXIT
              ARGNOW = ARG4(IGO:IEND)
              IF (ARGNOW(1:1) .NE. '[') THEN
C                NO [] AROUND VARIABLE NAME, ADD IT
                 NTOEQ  = INDEX(ARGNOW,'=') - 2
                 IF (NTOEQ < 0)THEN
C                   EXPRESSION IS NO GOOD - IF BATCH, TERMINATES
                    MESG = 'INVALID INITIAL REGISTER: ' // ARGNOW
                    CALL ERRT(101,MESG,NE)
                    EXIT
                 ENDIF
                 IF (ARG4(IGO:IGO) == 'X' .OR. 
     &               ARG4(IGO:IGO) == 'x') THEN
                    ARGNOW = '[_' // ARG4(IGO+1:IGO+NTOEQ) // ']' //
     &                              ARG4(IGO+NTOEQ+1:IEND)
                 ELSE    
                    ARGNOW = '[' // ARG4(IGO:IGO+NTOEQ) // ']' //
     &                              ARG4(IGO+NTOEQ+1:IEND)
                 ENDIF                  
              ENDIF 
              NLETN = lnblnk(ARGNOW)
              !write(6,*) ' current argument: ',ARGNOW(1:NLETN)

C             SET THE REGISTER, GLOBAL = .FALSE.
              CALL ARASQ(ARGNOW,NLETN,.FALSE.,IFLAG)
              IF (IFLAG .NE. 0)THEN
C                EXPRESSION IS NO GOOD - IF BATCH, TERMINATES
                 MESG = 'INVALID INITIAL REGISTER: '//ARGNOW(:NLETA)
                 CALL ERRT(101,MESG,NE)
                 EXIT
              ENDIF
              IFIRST = IEND + 1
           ENDDO
           NUMARG = 0
        ENDIF 

C       SET ALL THE LUNS & CURRENT PROCEDURE LINE COUNTER
        NIN   = 1
        NOUT  = NDAT
        IBCNT = 0

C       CLOSE THE LOG FILE IF INTERACTIVE,
        IF (NLOG .NE. 0) CLOSE(NLOG)
        NLOG = 0

C       SEE IF PROCEDURE ALREADY LOADED, IF NOT LOAD & LIST
        LISTIT = .TRUE.
        DO NUMPROCNOW = 1, NUMPRC 
           IF (PNAME == PROCFL(NUMPROCNOW)(:MAXNAM)) THEN
C            DON'T NEED TO LOAD PROC FILE OR LIST INTO RESULTS FILE
             LISTIT = .FALSE.
             EXIT
          ENDIF
        ENDDO

        IF (LISTIT) THEN
C          MUST LOAD & LIST

C          OPEN NEW PROCEDURE FILE.
           OPEN(NIN,FILE=PNAME,STATUS='UNKNOWN')

           NUMPRC = NUMPRC + 1
           IF (NUMPRC > MAXPRCNAM) THEN
C             TOO MANY PROCEDURES TO STORE
              CALL ERRT(102,'NO. OF PROCEDURES EXCEEDS MAXPRCNAM',
     &                  MAXPRCNAM)
              GOTO 5000
           ENDIF
           NUMPROCNOW = NUMPRC
           PROCFL(NUMPROCNOW)(:MAXNAM) = PNAME

C          READ IN PROCEDURE LINES & LIST IN RESULTS FILE
           NLINES   = 0
           NCHARS   = 1
           NUMLABS  = 0

           IF (VERBOSE .AND. MYPID <= 0) WRITE(NDAT,*) ' '

           DO 
              READ(NIN,3950,IOSTAT=IERR) PLINE
3950          FORMAT(A)
              IF (IERR .NE. 0) EXIT

              NLINES = NLINES + 1
              NCHAR  = lnblnk(PLINE)

              IF (VERBOSE .and. MYPID <= 0) 
     &           WRITE(NDAT,3960) NLINES, PLINE(:NCHAR)
3960          FORMAT(3X,I4,4X,A)

C             FIND MESG = PLINE WITHOUT WHITESPACE
              CALL SHRINK(PLINE,MESG,NCHARM)

              IF (NLINES == 1 .AND. NCHAR > 0) THEN
C                FIRST LINE. MODERNIZE ANY OLD STYLE ARGUMENTS 
                 IF (NCHARM > 0) THEN
C                   FIRST LINE IS NOT ALL WHITESPACE 

C                   CHECK FOR OLD STYLE ARGUMENTS []
                    CALL CHARINSIDE(MESG,'[',']',.FALSE.,.FALSE.,
     &                              ILEFBRAK,IRITBRAK,NINBRAK)

                    IF (ILEFBRAK == 1 .AND. IRITBRAK == NCHARM) THEN
C                      MODERNIZE OLD STYLE ARGUMENTS 
                       MESG(ILEFBRAK:ILEFBRAK) = '('
                       MESG(IRITBRAK:IRITBRAK) = ')'
                       IF (MYPID <= 0) WRITE(NOUT,*) 
     &                ' *** PLEASE CONVERT PROCEDURE ARGUMENTS TO: (..)'
                    ENDIF   ! (ILEFBRAK == 1 .... 

                    IF (MESG(1:1) == '(') THEN
C                      STRIP WHITESPACE FROM FIRST LINE
                       PLINE = MESG
                       NCHAR = NCHARM 
                    ENDIF   ! (MESG(1:1) == '(')
                 ENDIF      ! (NCHARM > 0) 
              ENDIF         ! (NLINES == 1) 

C             CHECK FOR DUPLICATE LABEL
              IF ((MESG(1:1) == 'L' .OR. MESG(1:1) == 'l') .AND.
     &            (MESG(2:2) == 'B' .OR. MESG(2:2) == 'b') .AND.
     &            ISDIGI(MESG(3:3)) ) THEN

C                OPERATION IS A GOTO LABEL
                 CALL GETLBNO(PLINE,ILBNO,IRTFLG)
                 IF (NUMLABS > 0) THEN
C                   CHECK THRU EXISTING LABELS IN LIST
                    DO I = 1,NUMLABS
                       IF (LABGOT(I) == ILBNO) THEN
C                         ALREADY HAVE THIS LABEL
                          CALL ERRT(102,'DUPLICATE LABEL',ILBNO)
                       ENDIF
                    ENDDO
                 ENDIF
                
C                WRITE(NOUT,*)' PUSHING LABEL: ',ILBNO
                 NUMLABS = NUMLABS + 1
                 IF (NUMLABS <= MAXNUMLAB) THEN
                    LABGOT(NUMLABS) = ILBNO
                 ELSE
                    WRITE(NOUT,*)' --- WARNING TOO MANY LABELS, ',
     &                           ' DUPLICATE LABEL CHECKING ABANDONED'
                    NUMLABS = MAXNUMLAB
                 ENDIF
              ENDIF ! END OF: IF ((MESG(1:1) == 'L' ......

              PLINEGO(NLINES) = NCHARS
              DO I = 1,NCHAR
                 PDATA(NCHARS+I-1) = PLINE(I:I)
              ENDDO
              NCHARS = NCHARS + NCHAR
           ENDDO

           IF (VERBOSE .AND. MYPID <= 0) WRITE(NDAT,*) ' '

           CLOSE(NIN)
C          SAVE PROCEDURE LINES FOR FUTURE USE
           CALL PROC_SET(NUMPRC,NCHARS,NLINES,PLINEGO(1),
     &                   PDATA(1),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 10000
        ENDIF

C       PUT NEW PROCEDURE NUMBER ON THE STACK
        IPNUMSTACK(ISTOP) = NUMPROCNOW
        IPARNUM(ISTOP)    = 0   !NUMBER FOR OLD IMPLIED <n> SYM. PAR.
        NARGSREC(ISTOP)   = 0

C       CHECK FIRST LINE OF PROCEDURE FOR ARGUMENT TRANSFER
        IBCNT = IBCNT + 1
        CALL PROC_GETPLINE(IBCNT,NUMPROCNOW,PLINE,NUMCHR,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(102,'COULD NOT READ PROC. LINE',IBCNT)
           GOTO 10000
        ENDIF

        IF (PLINE(1:1) == '(') THEN
C          SUBSTITUTE FOR ANY ARGUMENT TRANSFER INTO PROCEDURE
C          @@@@PROC HAS NONE
           CALL RDPR(PLINE,NCHAR,PLINE,.FALSE.,.FALSE.,.TRUE.,
     &               .FALSE.,.FALSE.,.TRUE.,.TRUE.,IRTFLG)

           IF (PLINE(2:2) == '[') THEN
C             REGISTER ARGUMENT TRANSFER TO PROCEDURE

C             GET REGISTER LIST IN NSELREG
              CALL REG_GET_SEL(ISTOP,PLINE(1:NCHAR),.TRUE.,.FALSE.,
     &                         NARGREG1,IRTFLG)

C             SAVE REGISTER LIST RECEIVED IN IARGSREC
              CALL REG_GET_SELS(IARGSREC(1,ISTOP),NPARG,NREG,IRTFLG)

              IF (NARGREG .NE. NARGREG1) THEN
                WRITE(NOUT,*) 
     &          '*** REGISTER ARGUMENTS SENT TO PROCEDURE:',NARGREG,
     &                        ' <> ARGUMENTS IN PROCEDURE:',NARGREG1
                CALL ERRT(102, 
     &            'WRONG NUMBER OF REGISTERS SENT TO PROCEDURE',NARGREG)
             ENDIF
C            STORE NUMBER OF CURRENT REGISTERS SENT TO THIS PROC.
             NARGSREC(ISTOP) = NARGREG1

C            UPDATE NEW PROCEDURES REGISTERS FROM CALLER'S REGISTERS
             CALL REG_LIST_COPY(NARGREG,
     &                         IARGSENT(1,ISTOP),IARGSREC(1,ISTOP))

           ELSE
             WRITE(NOUT,*) 
     &       '*** REGISTER ARGUMENTS SENT TO PROCEDURE:',NARGREG,
     &       ' BUT NO REGISTER ARGUMENTS IN PROCEDURE'
             CALL ERRT(102, 
     &          'WRONG NUMBER OF REGISTERS SENT TO PROCEDURE',NARGREG)
           ENDIF

        ELSEIF (PLINE(1:1) .NE. '(') THEN

C         NO ARGUMENT TRANSFER, WILL WANT TO REREAD THIS LINE
          IBCNT = IBCNT - 1
        ENDIF

        GOTO 5000


C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ RETURN FROM PROCEDURE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C       RETURN FROM PROCEDURE--------------------------------------- RE

C       ISTOP TELLS US HOW DEEPLY NESTED WE ARE.  POINTS TO CURRENT
C       TOP OF STACK, WHICH IS CURRENT PROCEDURE FILE.

10000   IF (COPT == 'I') THEN
           CALL ERRT(101,'OPERATION NOT ALLOWED IN INTERACTIVE MODE',N)
           GOTO 5000
        ELSEIF (ISTOP <= 1) THEN
C          TOO MANY RETURNS, HALT IN ERRT
           CALL ERRT(101,'TOO MANY PROCEDURE RETURNS GIVEN',NE)
           GOTO 9999
        ENDIF

C       TAKE PROCEDURE OFF THE STACK, AND CLOSE IT UP

        IF (NARGSREC(ISTOP) > 0) THEN
C          SAVE REGISTER VALUES SPECIFIED IN RECEIVED ARGUMENT LIST
           CALL REG_LIST_COPY(NARGSREC(ISTOP),
     &                        IARGSREC(1,ISTOP),IARGSENT(1,ISTOP))
        ENDIF

C       RETRIEVE DO-LOOP INFO FROM LOWER PROCEDURE LEVEL
        ILOOP    = LOOPSV(1,ISTOP)    ! CURRENT LOOP ITERATION
        IABSLP   = LOOPSV(2,ISTOP)    ! CURRENT LOOP COUNTER
        LOOPREG  = LOOPSV(3,ISTOP)    ! REG. FOR LOOP COUNTER
        NLOOP    = LOOPSV(4,ISTOP)    ! NUMBER OF ITERATIONS FOR LOOP
        IDOTOP   = LOOPSV(6,ISTOP)    ! LOOP STACK POINTER
        LBNO     = LOOPSV(7,ISTOP)    ! CURRENT LOOP LABEL NO.
        LOOPINC  = LOOPSV(8,ISTOP)    ! LOOP COUNTER INCREMENT

C       RETRIEVE IFLEVEL FROM LOWER PROCEDURE LEVEL
        IFLEVEL          = IFSV(ISTOP)

C       RETRIEVE PROCEDURE INFO FROM LOWER PROCEDURE LEVEL
        IBCNT     = IPSTACK(ISTOP)

        ISTOP     = ISTOP - 1
        FROMBATCH = ISTOP > 2
        ISTOPR    = ISTOP             ! REGISTER STACK

C       SET CURRENT LOOPREG IN THIS PROCEDURE.
        IF (LOOPREG > 0)
     &     CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)

C       SIGNAL END OF CURRENT PROCEDURE 
        IF (MYPID <= 0) THEN
            IF (VERBOSE) WRITE(NDAT,*) ' '
            WRITE(NDAT,10080) PNAME(1:NPNAME)
10080       FORMAT('  -- END OF: ',A,'  --')
            IF (VERBOSE) WRITE(NDAT,*) ' '
        ENDIF

C       RETRIEVE CALLER INFO FROM LOWER PROCEDURE LEVEL 
        NUMPROCNOW  = IPNUMSTACK(ISTOP)

        IF (ISTOP > 1) THEN
C          NEW PROCEDURE NAME IS NOW PNAME AT TOP OF STACK.
           PNAME(1:MAXNAM) = PROCFL(NUMPROCNOW)

C          IBCNT OFFSETS INPUT FOR SOLICITATIONS THAT WERE DONE BY
C          PROCEDURE PRIOR TO CALLING A CHILD PROCEDURE
           GOTO 5000
        ENDIF

C       INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
C       REOPEN THE LOG FILE, SINCE IT WAS CLOSED FOR PROCEDURE, 

        COPT  = 'I'
        IBCNT = 0
        NIN   = 5
        NOUT  = NSTDOUTP
        NLOG  = NLOGP

C       USE APPEND FOR LOG FILE, SINCE WE WANT TO ADD ON TO FROM BEFORE
        OPEN(NLOG,FILE=LOG,STATUS='OLD',
     &        ACCESS='SEQUENTIAL',POSITION='APPEND')

C       IF NOT 1ST TIME THROUGH THIS OLD LOOP, READ FROM DO-LOOP FILE
        IF (COPT == 'I' .AND. ILOOP > 1)  NIN = LUNDO

        GOTO 5000

C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ OTHER LOCAL OPERATIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


C     IQ VAR      ------------------------------------------------- IQ
C            123456789 123456789 123456789 1234567890 
8300  READ(CVERS(16:20),*) FVERS
      WRITE(NOUT,8301) FVERS
8301  FORMAT('  SPIDER VERSION: ',F5.2,/)
      CALL REG_SET_NSEL(1,1,FVERS, 0.0,0.0,0.0,0.0,IRTFLG)   
      GOTO 5000


C     SET OPTIONS ------------------------------------------------- MD
8500  CALL SETMODE(RES_TO_TERM)    ! HANDLES 'MD MRC' ALSO
      GOTO 5000


C     END SPIDER. ------------------------------------------------- EN
C     CLOSE RESULTS & LOG FILE

8400  DELETIT = FCHAR(1:4) == 'EN D'
      CALL SPIREOUT('**** SPIDER NORMAL STOP ****',IRTFLG)
      IF (MYPID <= 0) CALL ENDIT(' COMPLETED',DELETIT,RESULT)

#ifdef USE_MPI
#ifdef MPI_DEBUG
      TT1 = MPI_WTIME()
      IF (MYPID == 0) WRITE(6,8405) TT1-TT0
8405  FORMAT(' TOTAL TIME = ', 1PE11.3)  
#endif
      CALL MPI_FINALIZE(IRC)
#else
#ifdef  HAS_IEEE
#ifndef __APPLE__
C     DO NOT REPORT IEEE INEXACT ....
      call ieee_set_flag( ieee_inexact,       .FALSE. )
      call ieee_set_flag( ieee_denorm,        .FALSE. )
      call ieee_set_flag( ieee_invalid,       .FALSE. )
      call ieee_set_flag( ieee_overflow,      .FALSE. ) ! MAYBE SHUD??
      call ieee_set_flag( ieee_underflow,     .FALSE. ) ! MAYBE SHUD??
      call ieee_set_flag( ieee_divide_by_zero,.FALSE. ) ! MAYBE SHUD??
#endif
#endif
#endif
      IF (.NOT. USEPUBSUB) THEN
         STOP '  **** SPIDER NORMAL STOP ****'
      ENDIF
      STOP ' ' 



C START OF DO LOOP ------------------------------------------------ DO
C ILOOP COUNTS THE NUMBER OF TIMES WE'VE BEEN THRU THE LOOP.
C NLOOP IS THE NUMBER OF ITERATIONS FOR THE LOOP (IF < 1, NOT IN LOOP).
C ILOOP AND NLOOP ARE NEEDED IN THE RDPR* INPUT ROUTINES.
C IABSLP IS THE ACTUAL VALUE OF THE CURRENT ITERATION.

C LBNO HOLDS THE # FROM "DO LB#".
C THIS IS COMPARED WHEN A LABEL "LB#" IS ENCOUNTERED TO SEE IF THE 
C DO-LOOP SHOULD BE UPDATED OR IF THE LABEL SHOULD BE IGNORED.

8600    IF (COPT == 'I' .AND. NLOOP <= 0) THEN
C          NOT IN A LOOP, MUST OPEN NEW DOLOOP SCRATCH FILE
           OPEN(LUNDO,STATUS='SCRATCH',ACCESS='SEQUENTIAL',
     &          FORM='FORMATTED',IOSTAT=IOERR)
           IF (IOERR .NE. 0) THEN
              CALL ERRT(101,'UNABLE TO OPEN TEMP. DO-LOOP FILE',NE)
              GOTO 5000
           ENDIF
C          COPY FIRST DO LINE TO INTERACTIVE DO LOOP FILE
           WRITE(LUNDO,*) FCHAR(1:NALPH)
           NINSAVE = NIN
           NDOLINE = 1
        ENDIF
        ILOOP = 1

C       PRESERVE FCHAR,REMOVE BLANKS FROM FCHAR, ADDS BLANKS AT END 
        FCHARNOBLANK(1:160) = FCHAR(1:160)  
        CALL SHRINKQ(FCHAR,80,FCHAR,NLET)

        IF (NLET == 2) THEN
C          BARE DO LOOP, APPEND SOME DUMMY LOOP PARAMETERS
C                       123456789012345678901234567890
           FCHAR(1:) = 'DO[__DumIndx_]=1,999999999'
           NLET=26           
        ENDIF

        ILOCLIM = INDEX(FCHAR,'=') + 1
        IF (.NOT. ISCHAR(FCHAR(ILOCLIM-2:ILOCLIM-2))) THEN
C          NEW STYLE LOOP INDEX [var], GET REGISTER NUMBER FROM TOKEN
           CALL REG_FIND_IREG('LOC',FCHAR(1:ILOCLIM-2),IDUM,
     &                        LOOPREG,IERR)
           IF (IERR .NE. 0) THEN
               CALL ERRT(101,'CAN NOT PARSE DO LOOP',NDUM)
               GOTO 5000
           ENDIF
        ELSE
C          OLD STYLE LOOP INDEX (K,I,...)
C          CONVERT DO LOOP VARIABLE TO REGISTER (E.G. A --> _A)

           CREG = '[_' // FCHAR(ILOCLIM-2:ILOCLIM-2) // ']'
           CALL REG_FIND_IREG('LOC',CREG,IDUM,LOOPREG,IERR)
           !!CALL REG_GET_VAR(0,CREG,.TRUE.,VALUE,LOOPREG,IENDVAR,IERR)
        ENDIF

C       PARSE OUT LIMITS OF DO LOOP,  (LIMITS CAN BE IN REGISTERS)
C       LOWER LIMIT PUT IN IABSLP, REPITITIONS PUT IN NLOOP
        NC = NLET - ILOCLIM + 1 
        CALL CHKSTR(FCHAR(ILOCLIM:NLET),NC,'I',NUML,FDUM,3,NVAL,IRTFLG)
        IF (IRTFLG .NE. 0 .OR. NVAL < 2) THEN
           CALL ERRT(101,'CAN NOT PARSE DO LOOP',NDUM)
           GOTO 5000
        ENDIF
        IABSLP   = NUML(1)

C       SET LOOP COUNTER INCREMENT
        LOOPINC  = 1
        IF (NVAL > 2)  LOOPINC = NUML(3)
        NLOOP    = (NUML(2) - IABSLP) / LOOPINC + 1
        
C       PUT LOOP START IN REGISTER FOR LOOP COUNTER
        IF (LOOPREG > 0) THEN
           CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 5000
        ENDIF

C       PUT IABSLP IN REGISTER [_0] ALSO
        CALL REG_SET(0,REAL(IABSLP),NULL,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 5000

C       ADD THIS NEW DO LOOP TO THE TOP OF THE LOOP STACK
        IDOTOP = IDOTOP + 1      ! LOOP STACK POINTER

        !write(6,*) ' set idotop: ',idotop,' for:',fchar(1:nalph)

        IF (IDOTOP > MAXPRC) THEN
C          NESTING LEVEL IS MAXPRC, ALWAYS HALTS IN ERRT
           WRITE(NOUT,6171) MAXPRC
6171       FORMAT(' *** LOOP NESTING LEVEL (',I3,') EXCEEDED')
           CALL ERRT(101,'LOOP NESTING LEVEL EXCEEDED',NE)
           GOTO 9999
        ENDIF

C       GET ENDING LABEL NUMBER FOR THIS LOOP
        CALL GETLBNO(FCHAR,LBNO,IRTFLG)
        IF (LBNO < 0) THEN
C          MAKE NEG. LB# FOR PROCEDURE LINE 
           LBNO = -IBCNT
           IF (COPT == 'I') LBNO = -NDOLINE
        ENDIF

C       SAVE ALL THE VALUES IN THE STACKS
        IDOSTK(1,IDOTOP) = ILOOP      ! CURRENT LOOP ITERATION
        IDOSTK(2,IDOTOP) = IABSLP     ! CURRENT LOOP COUNTER
        IDOSTK(3,IDOTOP) = LOOPREG    ! REG. FOR LOOP COUNTER
        IDOSTK(4,IDOTOP) = NLOOP      ! NUMBER OF ITERATIONS FOR LOOP
        IDOSTK(5,IDOTOP) = ISTOP      ! PROCEDURE STACK LEVEL
        IDOSTK(6,IDOTOP) = LBNO       ! LABEL FOR END OF CURRENT LOOP
        IDOSTK(7,IDOTOP) = LOOPINC    ! LOOP INCREMENT

        IF (VERBOSE .and. MYPID <= 0) THEN 
           WRITE(NOUT, 8860) FCHARNOBLANK,IABSLP
        ENDIF
        GOTO 5000

C END OF DO LOOP -------------------------------------------- LB,ENDDO
C       IF # IN LB# IS THE SAME AS CURRENT DO-LOOP, CONTINUE AS
C       USUAL AT THE END OF A DO-LOOP.  OTHERWISE, IGNORE THE LABEL
C       AND GO BACK TO OPERATION AND READ IN THE NEXT LINE.
C       GET LABEL NUMBER FROM THE LINE

8800    IF (FCHAR(1:2) == 'LB') THEN
           CALL GETLBNO(FCHAR,ILBNO,IRTFLG)

C          IF NUMBER IN LB## IS NOT SAME AS CURRENT DO-LOOP, IGNORE 
C          THIS LABEL, GO BACK TO INPUT AND READ IN THE NEXT LINE.
           IF (ILBNO .NE. IDOSTK(6,IDOTOP)) GOTO 5000
        ELSE
           ILBNO = LBNO
        ENDIF

C       MAKE SURE THE LABEL BEING HUNTED FOR IS IN CURRENT PROC.
        IF (ISTOP .NE. IDOSTK(5,IDOTOP)) GOTO 5000

C       NORMAL ENDING OF DO-LOOP
C       INCREASE THE NUMBER OF TIMES WE'VE BEEN THRU THE LOOP AS WELL
C       AS THE ACTUAL ITERATION VALUE OF THE LOOP
        ILOOP  = ILOOP  + 1
        IABSLP = IABSLP + LOOPINC

C       UPDATE REGISTER FOR CURRENT LOOP COUNT X0
        CALL REG_SET(0,REAL(IABSLP),NULL,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 5000

        IF (ILOOP <= NLOOP) THEN
C         WE'RE NOT DONE WITH THIS LOOP YET
          IF (COPT == 'I' .AND. ILOOP == 2) THEN
C            USE DOLOOP SCRATCH FILE FOR INPUT NOW
             NIN = LUNDO
          ENDIF
          IBCNT = 0
          IF (LOOPREG > 0)
     &          CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)

C         SAVE CHANGED VALUES IN THE CURRENT DO-LOOP STACK
          IDOSTK(1,IDOTOP)    = ILOOP
          IDOSTK(2,IDOTOP)    = IABSLP

C         FIND START OF THE DOLOOP WE'RE WORKING ON, AND CONTINUE
          CALL SEARCHQ(ILBNO,IER)
          IF (IER .NE. 0) THEN
C            SHOULD HALT IN ERRT
             CALL ERRT(102,'END-OF-FILE IN DO-LOOP SEARCH LINE',ILBNO)
             GOTO 9999
          ENDIF

          IF (VERBOSE .AND. MYPID <= 0) 
     &       WRITE(NOUT, 8860) FCHAR(1:20),IABSLP
8860      FORMAT(5X,A20,'    / ',I8)
 
          GOTO 5000
        ENDIF

C       DONE WITH THIS LOOP, RESET VALUES
C       POP THE DO-LOOP STACK, GET ALL THE LOOP VALUES BACK

        IDOTOP = IDOTOP - 1      ! LOOP STACK POINTER

        IF (IDOTOP < 1 .OR. IDOTOP > MAXPRC) THEN
C          NESTING LEVEL IS MAXPRC.  IF EXCEEDED, HALTS IN ERRT
           CALL ERRT(101,'PGM ERROR, LOOP NESTING LEVEL EXCEEDED',NE)
           GOTO 9999
        ENDIF
        ILOOP       = IDOSTK(1,IDOTOP)    ! CURRENT LOOP ITERATION
        IABSLP      = IDOSTK(2,IDOTOP)    ! CURRENT LOOP COUNTER
        LOOPREG     = IDOSTK(3,IDOTOP)    ! REGISTER FOR LOOP COUNTER
        NLOOP       = IDOSTK(4,IDOTOP)    ! NUMBER OF ITERATIONS FOR LOOP
        LBNO        = IDOSTK(6,IDOTOP)    ! LOOP LABEL NUMBER
        LOOPINC     = IDOSTK(7,IDOTOP)    ! LOOP COUNT INCREMENT
        !write(6,*) ' down idotop: ',idotop,lbno, ' for: ',fchar(1:nalph)
 
C       PUT CURRENT IABSLP IN X0 & LOOPREG
        CALL REG_SET(0,REAL(IABSLP),NULL,IRTFLG)
        IF (LOOPREG > 0) THEN
           CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)
        ENDIF

        IF (COPT == 'I' .AND. ILOOP == 1) THEN
C          FIRST TIME THROUGH THIS LOOP, READ FROM TERMINAL NOW
           NIN = NINSAVE

           IF (IDOTOP >= 2 ) THEN
              DO I = 1,IDOTOP-1
C                NOT 1ST TIME THROUGH A HIGHER LOOP, READ DO-LOOP FILE
                 IF (IDOSTK(1,I) > 1) NIN = LUNDO
              ENDDO
           ENDIF
        ENDIF

C       DELETE DOLOOP SCRATCH FILE IF NOT IN NESTED INTERACTIVE DO-LOOP
        IF (COPT == 'I' .AND. IDOTOP == 1) THEN
           CLOSE(LUNDO)
           NDOLINE = 0
        ENDIF

C       GO TO THE TOP OF THE FILE, RESET IBCNT, WHICH TELLS US
C       HOW MANY LINES WE'VE READ IN, AND UPDATE THE STACK VALUES 
        GOTO 5000

C LOGICAL ELSEIF ----------------------------------------------- ELSEIF
10795   IF (IFLEVEL >= 1 .AND. (.NOT. USEELSE(ISTOP,IFLEVEL))) THEN
C          DO NOT NEED TO PROCESS THESE OPERATIONS, SKIP THEM
C          KEEP READING INPUT LINES TILL CORRESPONDING ENDIF FOUND
           CALL FINDENDIF('ENDIF',IFLEVEL,IRTFLG)
           GOTO 5000
        ENDIF
C       CONTINUES INTO 10800

C LOGICAL IF -- OR GOTO---------------------------------------- IF/GOTO
10800   CALL LOGIFQ(FCHAR,LABEL,JUMP,IER)

        IF (IER .NE. 0) THEN
C          ERROR DETECTED, CAN NOT JUMP, (ERRT CALLED IN LOGIFQ)
           GOTO 5000

        ELSEIF (LABEL(1:5) == 'ENDDO' .AND. JUMP) THEN
C          WANT IMMEDIATE EXIT FROM CURRENT LOOP
           GOTO 10797

        ELSEIF (LABEL(1:5) == 'CYCLE' .AND. JUMP) THEN
C             WANT IMMEDIATE CYCLING OF CURRENT LOOP
              GOTO 10796

        ELSEIF (LABEL(1:4) .NE. 'ELSE' .AND. .NOT. JUMP) THEN
C          NO ERROR AND DO NOT WANT TO JUMP, CONTINUE AS NORMAL
           GOTO 5000

        ELSEIF (LABEL(1:1) == ' ') THEN
C          IF FIRST LABEL ELEMENT BLANK, LOGIFQ JUST SETS AN ARITHMETIC 
C          EXPRESSION. NO NEED TO JUMP TO ANY LABEL, CONTINUE AS NORMAL
           GOTO 5000

        ELSEIF (FCHAR(1:6) == 'ELSEIF') THEN
C          THIS IS AN: ELSEIF....THEN....ELSE OPERATION
           USEELSE(ISTOP,IFLEVEL) = JUMP
           IF (JUMP) THEN
C             'IF' IS FALSE, JUMP TO CORRESPONDING ELSE OR ENDIF
C             DECREMENTS IFLEVEL ALSO
              CALL FINDENDIF('ELSE',IFLEVEL,IRTFLG)
           ENDIF
           GOTO 5000
        ENDIF

        IF (LABEL(1:4) == 'ELSE') THEN
C          THIS IS AN: IF....THEN....ELSE OPERATION
           IFLEVEL = IFLEVEL + 1

           IF (IFLEVEL <= 0) THEN
C             USE-ELSE UNDERFLOW, WILL HALT IN PROCEDURE MODE IN ERRT
              CALL ERRT(101,' 2 IN PROGRAM IFLEVEL <= 0',NE)
              GOTO 5000
           ELSEIF (IFLEVEL > MAXPRC) THEN
C             USEELSE OVERFLOW, WILL HALT IN PROCEDURE MODE IN ERRT
              CALL ERRT(101,'IF..ELSE NESTING LEVEL EXCEEDED',NE)
              GOTO 5000
           ENDIF

           USEELSE(ISTOP,IFLEVEL) = JUMP
           IF (JUMP) THEN
C             'IF' IS FALSE, JUMP TO CORRESPONDING ELSE OR ENDIF
C             DECREMENTS IFLEVEL ALSO
              CALL FINDENDIF('ELSE',IFLEVEL,IRTFLG)
           ENDIF
           GOTO 5000
        ENDIF

        IF (.NOT. ISDIGI(LABEL(4:4))) LABEL(4:4) = ' '
C       MAKE SECOND DIGIT OF LB# A BLANK IN THIS CASE

C       CONTINUE INPUT LINES TILL LABEL IS FOUND. NO EFFECT ON IFLEVEL
        CALL FINDLBQ(LABEL,IDOTOP,NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRT)
C       ERRT CALLED IN FINDLBQ NOW, SO IT SHOULD HALT THERE

        IF (NEWLOOP < 0) THEN
C          HAVE PASSED CURRENT DO-LOOP END, MUST POP DO-LOOP STACK
           IF (COPT == 'I') THEN
              CALL ERRT(13,'SPIDER',NE)
              GOTO 5000
           ENDIF

           IDOTOP      = IDOTOP + NEWLOOP   ! LOOP STACK POINTER

           IF (IDOTOP > MAXPRC .OR. IDOTOP <= 0) THEN
C             NESTING LEVEL IS MAXPRC.  IF EXCEEDED, HALTS IN ERRT
              CALL ERRT(101,'PGM ERROR 2, LOOP NESTING LEVEL 2',NE)
              GOTO 9999
           ENDIF
           ILOOP       = IDOSTK(1,IDOTOP)   ! CURRENT LOOP ITERATION
           IABSLP      = IDOSTK(2,IDOTOP)   ! CURRENT LOOP COUNTER
           LOOPREG     = IDOSTK(3,IDOTOP)   ! REG. FOR LOOP COUNTER
           NLOOP       = IDOSTK(4,IDOTOP)   ! NUMBER OF ITERATIONS FOR LOOP
           LBNO        = IDOSTK(6,IDOTOP)   ! LOOP LABEL NUMBER
           LOOPINC     = IDOSTK(7,IDOTOP)   ! LOOP COUNTER INCREMENT
 
C          PUT CURRENT IABSLP IN X0 & LOOPREG
           CALL REG_SET(0,REAL(IABSLP),NULL,IRTFLG)
           IF (LOOPREG > 0) THEN
              CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)
           ENDIF
        ENDIF

C       PROCESS THE OPERATION RETURNED FROM FINDLBQ
        GOTO 5100

C       LOOP CYCLE ---------------------------------------------- CYCLE
C       CONTINUE INPUT LINES TILL ENDDO IS FOUND. NO EFFECT ON IFLEVEL

10796   CALL FINDLBQ('ENDDO',IDOTOP,NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRT)

C       PROCESS THE 'ENDDO' OPERATION RETURNED FROM FINDLBQ
        GOTO 5100

C       LOOP EXIT ------------------------------------------------ EXIT
C       CONTINUE INPUT LINES TILL ENDDO IS FOUND. NO EFFECT ON IFLEVEL

10797   CALL FINDLBQ('ENDDO',IDOTOP,NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 8400 

C       MAKE THIS LAST ITERATION OF THE CURRENT LOOP
        ILOOP = NLOOP
        !write(6,*) ' iloop,newloop: ',iloop,newloop

C       PROCESS THE 'ENDDO' OPERATION RETURNED FROM FINDLBQ
        GOTO 5100


C LOGICAL ELSE -------------------------------------------------- ELSE
10798   CONTINUE
        IF (IFLEVEL <= 0) THEN
           CALL ERRT(102,' IN PROGRAM IFLEVEL <= 0',IFLEVEL)
        ELSEIF (.NOT. USEELSE(ISTOP,IFLEVEL)) THEN
C          DO NOT NEED TO PROCESS THESE OPERATIONS, SKIP THEM
C          KEEP READING INPUT LINES TILL CORRESPONDING ENDIF FOUND
           CALL FINDENDIF('ENDIF',IFLEVEL,IRTFLG)

        ELSE IF (USEELSE(ISTOP,IFLEVEL)) THEN
C          MUST USE THIS ELSE CLAUSE
           CONTINUE
        ENDIF
        GOTO 5000

C LOGICAL ENDIF ------------------------------------------------ ENDIF
10799   CONTINUE
        IFLEVEL = IFLEVEL - 1
        GOTO 5000
      
        END



C **************************************************************************
C
C    SHRINK(INSTR,OUTSTR,LENOUT)

C    PURPOSE:  SHRINK STRING BY IGNORING ALL NON-PRINTING CHARACTERS
C
C    PARAMETERS: INSTR      INPUT STRING TO BE SHRANK         SENT
C                OUTSTR     OUPUT SHRUNKEN STRING             RET.
C                LENOUT     LENGTH OF SHRUNKEN STRING         RET.
C
C *************************************************************************

        SUBROUTINE SHRINK(INSTR,OUTSTR,LENOUT)

        CHARACTER *(*) INSTR,OUTSTR

        LENIN  = LEN(INSTR)
        LENMAX = LEN(OUTSTR)

        LENOUT = 0
        DO I=1,LENIN
           IF (INSTR(I:I) >= '!' .AND. INSTR <=  '~') THEN
              LENOUT = LENOUT + 1
              OUTSTR(LENOUT:LENOUT) = INSTR(I:I)
           ENDIF
        ENDDO

        IF (LENOUT. LT. LENMAX) THEN
C          PUT BLANKS AT END OF OUTSTR
           OUTSTR(LENOUT+1:LENMAX) = ' '
        ENDIF

        END

C **************************************************************************
C
C    EQU_SYMPAR(LINE,GLOBAL,IRTFLG)
  
C    PURPOSE: CREATE A SYMBOLIC (STRING) VARIABLE FROM COMMAND LINE
C             ASSIGNMENT
C
C    PARAMETERS:   LINE       INPUT STRING 
C                  GLOBAL     FLAG FOR GLOBAL VARIABLE
C                  IRTFLG     ERROR FLAG (2 IF NOT FOR STRING VAR)
C
C *************************************************************************

      SUBROUTINE EQU_SYMPAR(LINE,GLOBAL,IRTFLG)

      IMPLICIT NONE

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER (LEN=*)   :: LINE
      LOGICAL             :: GLOBAL
      INTEGER             :: IRTFLG

      CHARACTER (LEN=160) :: SYMPARID,SYMPARVAL,MSG
      CHARACTER(LEN=1)    :: CIGO,CEND
      LOGICAL             :: LOCAL,ISREGVAR
      REAL                :: VALDUM
      INTEGER             :: ICOMM,MYPID,MPIERR
      INTEGER             :: lnblnkn
      INTEGER             :: LENT,IP1,IP2,NCHARID,NE,NCHARI,IREG,NEQ
      INTEGER             :: NCHARV,IFIRST,IGO,IEND,ICVAR,NCHARS

      CHARACTER(LEN=1)    :: NQ1 = CHAR(39)                  ! '
      CHARACTER(LEN=1)    :: NQ2 = CHAR(34)                  ! "
      CHARACTER(LEN=2)    :: NQ1NQ2                          ! '"

C     FOR ISTOP 
      INTEGER             :: IPSTACK(MAXPRC)
      INTEGER             :: IPNUMSTACK(MAXPRC)
      INTEGER             :: IPARNUM(MAXPRC)
      INTEGER             :: ISTOP,ITI,ITIN,IWHERE
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      CALL SET_MPI(ICOMM,MYPID,MPIERR)

      NQ1NQ2 = NQ1 // NQ2   ! '"

      IRTFLG    = 1
      LENT      = lnblnkn(LINE)

C     LOCATE FIRST VARIABLE NAME IN LINE (SHOULD'VE ALEADY BEEN TESTED)

      CALL CHARINSIDE(LINE,'[',']',.TRUE.,.FALSE.,IP1,IP2,NCHARID)
      IF (NCHARID <= 0) THEN
         LENT = lnblnkn(LINE)
         MSG  = 'NO VARIABLE NAME ([NAME]) IN: ' // LINE(1:LENT)
         CALL ERRT(101,MSG,NE)
         RETURN
      ENDIF

C     GET  VARIABLE NAME FROM LINE 
      SYMPARID = '<' // LINE(IP1:IP2) // '>'  
      NCHARI   =  IP2 - IP1 + 3    
      !write(6,*) ' Got symparid:',symparid(:nchari),':',nchari

      CALL REG_FIND(1,SYMPARID(:NCHARI),VALDUM,IREG,IRTFLG) ! 3/7/16al
      !write(6,*) ' Queried reg var:', symparid(1:nchari),ireg,valdum,irtflg

      IF (IREG > 0 .OR. SYMPARID(2:2) == '_' ) THEN
C        TRYING TO EVALUATE IF EXPRESSION OR SET REGISTER VARIABLE
         IRTFLG = 2
         RETURN
      ENDIF 
      
      CALL REG_FIND(0,SYMPARID(:NCHARI),VALDUM,IREG,IRTFLG)
      !write(6,*) ' Queried reg var:', SYMPARID(1:NCHARI), ireg,valdum

      IF (IREG > 0 .OR. SYMPARID(2:2) == '_' ) THEN
C        TRYING TO EVALUATE IF EXPRESSION OR SET REGISTER VARIABLE
         IRTFLG = 2
         RETURN
      ENDIF 

C     GET ASSIGNED VARIABLE VALUE FROM LINE, MAY BE AN EXPRESSION
      NEQ    = 0         ! = SIGN COUNTER
      NCHARV = 0         ! = CHARACTER COUNTER
      IFIRST = IP2 + 2   ! = STARTING LOCATION

      !write(6,*) ' ifirst:',ifirst,':',line(ifirst:lent),':'

      DO 
         CALL GETNEXTTOKEN2(LINE,IFIRST,IGO,IEND) 
         IF (IEND <= 0) EXIT     ! NO MORE TOKENS

C        FOUND A TOKEN, IT SHOULD BE A: =, SYM. VARIABLE, OR QUOTED STRING
         IFIRST = IEND + 1         ! NEXT START FOR TOKEN SEARCH
         CIGO   = LINE(IGO:IGO)
         CEND   = LINE(IEND:IEND)
         !write(6,*) ' igo:iend:',igo,iend
         !write(6,*) ' token(igo:iend):',line(igo:iend)
         !write(6,*) ' cgo:cend:',cigo,':',cend,':'

         IF (CIGO == '=' ) THEN
C           TOKEN IS AN EQUAL SIGN             
            IF (NEQ > 0) THEN
               MSG = 'EXTRA = SYMBOL IN: '// LINE
               CALL ERRT(101,MSG,NE)
               RETURN
            ENDIF
            NEQ = NEQ + 1 

         ELSEIF (CIGO == NQ1 .OR. CIGO == NQ2 ) THEN
C           TOKEN IS START OF A QUOTED TEXT STRING
            IEND = SCAN(LINE(IGO+1:),NQ1NQ2, .TRUE.)  ! FROMBACK
            IEND = IGO + IEND
            !!write(6,*) ' igo:iend:',igo,iend,ncharv
            !1write(6,*)' quoted:',line(igo+1:iend-1),':'

            SYMPARVAL(NCHARV+1:) = LINE(IGO+1:IEND-1)
            NCHARV               = NCHARV + (IEND - IGO - 1)
            !write(6,*) ' igo:iend:',igo,iend,ncharv
            !write(6,*)' symparval:',symparval(:ncharv),':'

         ELSEIF (CIGO == '[' .AND.CEND == ']') THEN

            !write(6,*)' Calling issympar:',line(igo:iend),':'
C           TOKEN IS A [] VARIABLE, IS IT A SYM. STRING VARIABLE?
            CALL ISSYMPAR(LINE(IGO:IEND),-1,ICVAR,IRTFLG)
            !write(6,*)' Issympar:',line(igo:iend),':',ICVAR,IRTFLG

            IF (ICVAR <= 0 .OR. IRTFLG .NE. 0) THEN
C              RIGHT SIDE NOT A SYMVAR, MAY BE REG. ASSIGNMENT INSTEAD?
               !write(6,*)' Not sympar:',line(igo:iend),':',ICVAR,IRTFLG
           
               IRTFLG = 2
               RETURN
            ENDIF

C           UNQUOTED SYM [] VARIABLE, SUBSTITUTE VALUE FOR IT 
            !write(6,*)' Sub:',line(igo:iend),':',symparval(ncharv+1:),':'
            CALL SYMPAR_SUB(LINE(IGO:IEND),SYMPARVAL(NCHARV+1:),
     &                      NCHARS,ISTOP,.TRUE.,IRTFLG)
            !write(6,*)' Sub, nchars,irtflg:',nchars,irtflg

            NCHARV = NCHARV + NCHARS
         ENDIF
      ENDDO

      IF (NCHARV < 1) THEN
C        MAY BE A REGISTER ASSIGNMENT INSTEAD?
         IRTFLG = 2
         RETURN
      ENDIF
       
      !write(6,*) ' Symparval:',symparval(:ncharv),':',ncharv

      LOCAL = .NOT. GLOBAL
      CALL SETSYMPAR(SYMPARID(:NCHARI),SYMPARVAL(:NCHARV),LOCAL,IRTFLG)

      IRTFLG = 0
      END




C       -------------  GETPROCFILE ----------------------- GETPROCFILE

C       GET PROCEDURE FILE NAME FROM STR LINE

        SUBROUTINE GETPROCFILE(STR,NCHAR,PNAME,NPNAME,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        CHARACTER(LEN=*)      :: STR,PNAME
        CHARACTER(LEN=MAXNAM) :: PNAMEM
        CHARACTER(LEN=160)    :: MESG
        LOGICAL               :: EX

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       FIND FIRST CHARACTER IN FILENAME
        NFSTRT = INDEX(STR(1:NCHAR),'@@',BACK=.TRUE.) + 1

C       SUBSTITUTE FOR ALL SYM. VAR. IN STR
        !write(6,*) ' Checking: ',STR(NFSTRT:NCHAR)
        CALL SUBSYMPAR(STR(NFSTRT:NCHAR),PNAMEM,NCT,0,IRTFLG)

C       WILL STOP IN FILNAMANDEXT ON ERRT
        CALL FILNAMANDEXT(PNAMEM(:NCT),PRJEXC,PNAME,NPNAME,.TRUE.,IER)

C       TRY TO FIND PROCEDURE IN USER'S DIRECTORY & PROJECT EXTENSION

        !write(6,*) ' Checking: ',pname(NFSTRT:NCHAR)
        IF (MYPID <= 0) INQUIRE(FILE=PNAME,EXIST=EX)
        CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)

        IF (.NOT. EX) THEN
C         PROCEDURE FILE DOESN'T EXIST IN USER'S DIRECTORY
          IF (MYPID <= 0)  WRITE(NOUT,90) PNAME 
90        FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 

C         TRY AGAIN UNDER 'PROC:*.spi' IN PROC DIR.
C         7/10/88 PROC IS ENV. VAR. FOR DIR. WHERE *.spi FILES ARE al

          CALL MYGETENV('SPPROC_DIR',PNAME,NCHART,
     &                 'dir-for-proc-files',IER)
          IF (IER .NE. 0) CALL ERRT(101,'NO ENVIRONMENT VARIABLE',NE)
          NCHARTN = LNBLNKN(PNAMEM)
          PNAME   = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.spi'
          NPNAME  = NCHART + NCHARTN + 4

          IF (MYPID <= 0) INQUIRE(FILE=PNAME,EXIST=EX)
          CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)

          IF (.NOT. EX) THEN
C            THE *.spi FILE DOES NOT EXIST. NOTIFY USER
             MESG = 'PROCEDURE FILE.spi DOES NOT EXIST: '//
     &              PNAME(:NPNAME) 
             CALL ERRT(101,MESG,NE)
             IRTFLG = 1
             RETURN
          ENDIF
        ENDIF

        IRTFLG = 0
        END




#ifdef MPI_DEBUG

        SUBROUTINE PI3F   ! CAN BE USED FOR TESTING MPI WITHIN SPIDER 

        DOUBLE PRECISION, PARAMETER ::
     &                    PI25DT = 3.141592653589793238462643D0

        DOUBLE PRECISION :: DMYPI, PI, H, SUM, X, F, A
        INTEGER          :: RC
        ! FUNCTION TO INTEGRATE
        F(A) = 4.D0 / (1.D0 + A*A)

        INCLUDE 'mpif.h'

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID,  MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)

        IF(MYPID == 0)WRITE(6,*) ' NPROCS = ', NPROCS,' icomm:',icomm
        SIZETYPE   = 1
        SUMTYPE    = 2
 
        DO j= 35,-1,-7
            IF ( MYPID == 0 ) THEN
               N = j
c              CALL RDPRI1S( N,NOTUSED,
c     &           'ENTER THE NUMBER OF INTERVALS: (0 QUITS)',IRTFLG)
c 99           FORMAT(I10)

              WRITE(6,*) 'INTERVALS: ',N
            ENDIF
      
c              WRITE(6,*) ' bcasting: ',N
           CALL MPI_BCAST(N,1,MPI_INTEGER,0,ICOMM,MPIERR)

           ! CHECK FOR QUIT SIGNAL
           IF ( N <= 0 ) EXIT

           ! CALCULATE THE INTERVAL SIZE
           H = 1.0D0 / N
 
           SUM  = 0.0D0
           DO I = MYPID+1, N, NPROCS
              X   = H * (DBLE(I) - 0.5D0)
              SUM = SUM + F(X)
           ENDDO
           DMYPI = H * SUM

C          COLLECT THE PARTIAL SUMS
c              WRITE(6,*) ' reducing: ',N
           CALL MPI_REDUCE(DMYPI,PI,1,MPI_DOUBLE_PRECISION,MPI_SUM,0, 
     &                  ICOMM,MPIERR)

C          NODE 0 PRINTS THE ANSWER.
           IF (MYPID == 0) THEN
              WRITE(6, 97) PI, ABS(PI - PI25DT)
 97           FORMAT('  Pi is approximately: ', F10.8,
     &               '  Error is: ', F10.8)
           ENDIF
        ENDDO

        END

#endif
@


1.499
log
@VERSION:  UNIX 26.05
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 26.05  ISSUED:  6/24/2020'/
@


1.498
log
@26.04
@
text
@d11 1
a11 1
C=* Copyright 1985-2019  Health Research Inc.,                         *
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 26.04  ISSUED:  2/27/2020'/
@


1.497
log
@version 26.03
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 26.03  ISSUED:  1/20/2020'/
@


1.496
log
@MRC_AXIS       = 'UL L'    , version:26.01
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 26.01  ISSUED: 11/20/2019'/
@


1.495
log
@version 26.0 for mrc support
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 26.00  ISSUED: 22/04/2019'/
d246 1
d1043 1
a1043 1
8500  CALL SETMODE(RES_TO_TERM)
@


1.494
log
@version 25.02
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 25.02  ISSUED: 02/14/2019'/
@


1.493
log
@recon dir removed,  documentation update,  spire location fixed
@
text
@d11 1
a11 1
C=* Copyright 1985-2018  Health Research Inc.,                         *
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 25.01  ISSUED: 01/02/2019'/
@


1.492
log
@version 25.00 new spire files
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 25.00  ISSUED: 10/26/2018'/
@


1.491
log
@spire refactoring release
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 24.09  ISSUED: 10/26/2018'/
@


1.490
log
@new release 24.08
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 24.08  ISSUED:  7/26/2018'/
@


1.489
log
@version 24.06 for "PW" parallel
@
text
@d11 1
a11 1
C=* Copyright 1985-2017  Health Research Inc.,                         *
d13 1
a13 1
C=* Email: spider@@wadsworth.org                                        *
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 24.06  ISSUED:  2/12/2018'/
@


1.488
log
@8300 CVERS altered
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 24.05  ISSUED:  1/23/2018'/
@


1.487
log
@removed VERSION comment from 8300 line label
@
text
@d1034 1
a1034 1
8300  READ(CVERS(17:21),*) FVERS
@


1.486
log
@version 24.05 for FQ
@
text
@a1033 1
C     CVERS/'VERSION:  UNIX  20.07 ISSUED: 1/30/2012'/ 
@


1.485
log
@if defined(SP_IFC) for greeting logo fix
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX 24.04  ISSUED: 11/28/2017'/
@


1.484
log
@version for Intel icc, FFTW 3.3.7, 'AP SR' intel bug fix, 'DE' on doc files
@
text
@d102 1
a102 1
        CHARACTER(LEN=39)     :: CVERS
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.04 Issued: 11/28/2017'/
d322 3
d326 3
a328 1
 9091   FORMAT('  ,__xXXXx___        HEALTH RESEARCH INC., ALBANY, NY.') 
d330 5
d337 1
@


1.483
log
@'FQ' volume filter bug
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.03 Issued: 5/26/2017 '/
@


1.482
log
@version 24.02
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.02 Issued: 4/18/2017 '/
@


1.481
log
@'CL CLA' bug fix
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.01 Issued: 4/18/2017 '/
@


1.480
log
@version for apscc bug fix
@
text
@d11 1
a11 1
C=* Copyright 1985-2016  Health Research Inc.,                         *
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.01 Issued: 1/30/2017 '/
@


1.479
log
@version 24.0
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  24.00 Issued: 1/13/2017 '/
@


1.478
log
@version 23.05
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.05 Issued: 11/8/2016 '/
@


1.477
log
@23.04 version for CP TO MRC unfilled stacks
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.04 Issued: 9/20/2016 '/
@


1.476
log
@23.03 version for 'FQ' updated from 'FQ Q',  mrc stack fix
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.03 Issued: 6/23/2016 '/
@


1.475
log
@23.02 for 'DIS' & 'DOC SLI'
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.02 Issued: 4/29/2016 '/
@


1.474
log
@has 'cp to stk'
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.01 Issued: 4/18/2016 '/
@


1.473
log
@version 23
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  23.00 Issued: 4/01/2016 '/
@


1.472
log
@new version 22.19 for equ-sympar global var search
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.19 Issued: 3/07/2016 '/
d388 1
a388 1
 9089        FORMAT('  SPIDER: ',A,2X,'Using PubSub:',2X,
@


1.471
log
@sayit not logical
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.18 Issued: 2/08/2016 '/
d1530 1
a1530 1
         MSG = 'NO VARIABLE NAME ([NAME]) IN: ' // LINE(1:LENT)
d1540 9
a1551 1
C     SEE IF TRYING TO SET A REGISTER VARIABLE
d1553 1
@


1.470
log
@startup msg
@
text
@d95 1
a95 1
        LOGICAL   :: GLOBAL,ISATAT
@


1.469
log
@startup msg
@
text
@d102 1
a102 1
        CHARACTER(LEN=40)     :: CVERS
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.18 Issued:  2/08/2016'/
d313 1
a313 5
          IF (USEPUBSUB) THEN
            WRITE(NOUT,9089) CVERS(17:),CDATT(1:11),CTIM 
 9089       FORMAT('  SPIDER: ',A,3X,'Running with PubSub:',2X,A,2X,A)

          ELSE
d336 1
d371 2
a372 1
           CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,CXNUM)
d386 6
a391 1
             WRITE(NDAT,9089) CVERS(17:),CDATT(1:11),CTIM 
d1023 1
a1023 1
C     CVERS/'VERSION:  UNIX  20.07 ISSUED:  1/30/2012'/ 
@


1.468
log
@version for 'FSC MA'
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.18 ISSUED:  2/08/2016'/
d314 3
a316 2
           WRITE(NOUT,9089) CVERS(17:),CDATT(1:11),CTIM 
 9089      FORMAT('  SPIDER: ',A,3X,'Running with PubSub at:',3X,A,2X,A)
d344 1
d372 1
d377 1
d388 1
a388 1
             WRITE(NDAT,9089) CVERS,CDATT(1:11),CTIM 
a403 2

             WRITE(NOUT,*) ' '    
@


1.467
log
@FLUSHRESULTS_Q(.FALSE.),  no SP_NT,  startup msgs changed
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.17 ISSUED:  1/28/2016'/
d314 2
a315 2
            WRITE(NOUT,9089) CVERS,CDATT(1:11),CTIM 
 9089       FORMAT('  SPIDER Running with PubSub: ',A,4X,A,4X,A)
a385 1
             WRITE(NOUT,9086) PRJEXC(1:3),DATEXC(1:3)
@


1.466
log
@pubsub cosmetic msg.
@
text
@d315 1
a315 1
 9089       FORMAT('  SPIDER RUNNING WITH PUBSUB: ',A,4X,A,4X,A)
d340 3
d385 3
a387 2
             WRITE(NDAT,9096) PRJEXC(1:3),DATEXC(1:3)
             WRITE(NOUT,9096) PRJEXC(1:3),DATEXC(1:3)
d398 5
a402 4
9096         FORMAT(/'  PROJECT EXTENSION: ',A3,
     &               '   DATA EXTENSION: ',A3,/)
             WRITE(NOUT,9095) MESG
9095         FORMAT('  Running: ',A)
d407 1
a407 1
           CALL FLUSHRESULTS
a419 3
#ifdef SP_NT
              CALL ERRT(101,'PROCESS ID NOT AVAILABLE IN WINDOWS',NE)
#else
a427 1
#endif
@


1.465
log
@pubsub output formatting
@
text
@d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.17 ISSUED:  1/25/2016'/
d315 1
a315 1
 9089       FORMAT('  RUNNING SPIDER: ',A,'  USING PUBSUB',3X,A,4X,A,/)
d383 1
d1058 1
a1058 1
      IF (.NOT. IN_PARALLEL) THEN
@


1.464
log
@usepubsub output
@
text
@d314 2
a315 3
            WRITE(NOUT,9089) CVERS  
 9089       FORMAT('  SPIDER: ',A,'  RUNNING USING: PUBSUB',/)
            WRITE(NOUT,9094)CDATT(1:11),CTIM
d381 1
a381 3
             WRITE(NDAT,9088) CVERS  
9088         FORMAT('  SPIDER: ',A,'  RUNNING USING: PUBSUB',/)
             WRITE(NDAT,9094) CDATT(1:11),CTIM
d395 1
a395 2

             WRITE(NOUT,9095)MESG
@


1.463
log
@usepubsub on command line added
@
text
@d27 1
a27 1
C  PURPOSE: MAIN SUBROUTINE OF SPIDER IMAGE PROCESSING SYSTEM.                  *
d315 2
a316 1
 9089       FORMAT('  SPIDER: ',A,'  RUNNING USING: PUBSUB 89',/)
d382 4
a385 2
             WRITE(NOUT,9088) CVERS  
9088         FORMAT('  SPIDER: ',A,'  RUNNING USING: PUBSUB 88',/)
d393 2
a394 3
             WRITE(NDAT,9093)CVERS
             WRITE(NDAT,9094)CDATT(1:11),CTIM

@


1.462
log
@fromback on scan in equ_symvar
@
text
@d153 1
a153 1

d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.16 ISSUED:  1/20/2016'/
d216 3
a218 3
        NLOGP    = 1  
        NLOG     = NLOGP
        NECHO    = 0        ! COUNTER FOR LOG FILE OUTPUT
d228 1
a228 1
C       INITIALIZE SOME COMMON BLOCK DATA ELEMENTS (SEE: SETMODE.F)
d310 1
a310 1
        CALL INITUNIX(NUMARG,FCHAR,NALPH,CXNUM,MESG)
d312 12
a323 8
        IF (MYPID <= 0) THEN
C       PRINT OUT HEADING WITH VERSION AND RELEASE DATES
        WRITE(NOUT,*)' '
        WRITE(NOUT,9090)
        WRITE(NOUT,9091)
        WRITE(NOUT,9092)
        WRITE(NOUT,9093)CVERS
        WRITE(NOUT,9094)CDATT(1:11),CTIM
d331 2
a332 2
        WRITE(NOUT,9097)
 9097   FORMAT('  If SPIDER is useful, please cite:',/,
d339 2
a340 2
        WRITE(NOUT,*) ' '

d380 21
a400 10
C          PRINT OUT HEADING WITH VERSION AND RELEASE DATES
           WRITE(NDAT,9090)
           WRITE(NDAT,9091)
           WRITE(NDAT,9092)
           WRITE(NDAT,9093)CVERS
           WRITE(NDAT,9094)CDATT(1:11),CTIM

           WRITE(NDAT,9096) PRJEXC(1:3),DATEXC(1:3)
9096       FORMAT(/'  PROJECT EXTENSION: ',A3,
     &             '   DATA EXTENSION: ',A3,/)
a401 2
           WRITE(NOUT,9095)MESG
9095       FORMAT('  Running: ',A)
@


1.461
log
@EQU_SYMPAR bug fix for: [var] = '[var1]=text'
version increment
@
text
@d11 1
a11 1
C=* Copyright 1985-2015  Health Research Inc.,                         *
d1547 3
a1549 4
      !write(6,*) ' igo:iend:',igo,iend
      !write(6,*) ' token(igo:iend):',line(igo:iend)
      !write(6,*) ' cgo:cend:',cigo,':',cend,':'

d1562 1
a1562 1
            IEND = SCAN(LINE(IGO+1:),NQ1NQ2)
d1564 2
a1565 2
      !!write(6,*) ' igo:iend:',igo,iend,ncharv
      !1write(6,*)' quoted:',line(igo+1:iend-1),':'
d1569 2
a1570 2
      !write(6,*) ' igo:iend:',igo,iend,ncharv
      !write(6,*)' symparval:',symparval(:ncharv),':'
@


1.460
log
@added in_parallel to replace say_stop
@
text
@a151 1
        LOGICAL              :: IN_PARALLEL = .FALSE.
d162 1
a162 1
        DATA CVERS/'VERSION:  UNIX  22.15 ISSUED: 12/17/2015'/
d178 1
d1471 2
d1477 3
d1481 11
a1491 2
      CHARACTER(LEN=1)    :: NQ1,NQ2,CIGO,CEND
      LOGICAL             :: GLOBAL,LOCAL,ISREGVAR
d1494 4
a1497 1
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
d1503 1
a1503 2
      NQ1       = CHAR(39)   ! '
      NQ2       = CHAR(34)   ! "
d1536 3
d1547 4
d1561 7
a1567 3
         ELSEIF ((CIGO == NQ1 .AND. CEND == NQ1) .OR.
     &           (CIGO == NQ2 .AND. CEND == NQ2)) THEN
C           TOKEN IS QUOTED TEXT STRING             
d1570 2
@


1.459
log
@saystop,  version 22.15, cosmetic
@
text
@d152 1
a152 1
        LOGICAL              :: SAYSTOP     = .TRUE.
d1015 1
a1015 1
8500  CALL SETMODE(RES_TO_TERM,SAYSTOP)
d1046 1
a1046 1
      IF (SAYSTOP) THEN
@


1.458
log
@version
@
text
@d95 1
a95 1
        LOGICAL   :: RES_TO_TERM,GLOBAL,ISATAT
d144 2
a145 2
        INTEGER, PARAMETER       :: MAXNUMLAB = 50
        INTEGER                  :: LABGOT(MAXNUMLAB)
d148 7
a154 3
        INTEGER, PARAMETER       :: LUNDO    = 300   
        INTEGER, PARAMETER       :: LUNSPIRE = 2   
        INTEGER, PARAMETER       :: LUNTEXT  = 103   
d163 1
a163 1
        DATA CVERS/'VERSION:  UNIX  22.14 ISSUED: 11/4/2015'/
a166 1
        DATA RES_TO_TERM/.FALSE./
d238 1
d1015 1
a1015 1
8500  CALL SETMODE(RES_TO_TERM)
d1046 4
a1050 1
      STOP ' **** SPIDER NORMAL STOP ****'
@


1.457
log
@version 22.13
@
text
@d159 1
a159 1
        DATA CVERS/'VERSION:  UNIX  22.13 ISSUED:  9/8/2015'/
@


1.456
log
@release
@
text
@d22 2
a23 4
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
d27 1
a27 2
C  MAIN SUBROUTINE OF SPIDER IMAGE PROCESSING SYSTEM.                  *
C  UPDATE VERSION STATEMENT (MARKED BY CHERE) WHEN VERSION IS CHANGED! *
d44 2
d82 1
a82 1
        COMMON   PLINEGO,PDATA
d159 1
a159 1
        DATA CVERS/'VERSION:  UNIX  22.12 ISSUED:  7/17/2015'/
d1394 1
a1394 1
           CALL ERRT(101,' IN PROGRAM IFLEVEL <= 0',NE)
a1446 1
        RETURN
d1647 1
a1647 1
        SUBROUTINE PI3F
d1670 2
a1671 2
c              CALL RDPRI1S( N,notused,
c     &           'ENTER THE NUMBER OF INTERVALS: (0 QUITS)',irtflg)
@


1.455
log
@if defined (SP_GFORTRAN)  || defined(__GFORTRAN__)
if defined(SP_IFC) || defined(__INTEL_COMPILER)
kmp_get_stacksize used on ifort
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.11 ISSUED:  5/05/2015'/
@


1.454
log
@for 'CP TO MRC' endian to little
@
text
@d131 1
a131 1
#if defined (SP_GFORTRAN)
d198 9
a206 3
        isiz1 = omp_get_stack_size()
        CALL omp_set_stack_size(65536)
        isiz2 = omp_get_stack_size()
a207 1

d245 1
a245 1
#if defined (SP_GFORTRAN)
d403 1
a403 1
#ifdef SP_GFORTRAN
@


1.453
log
@22.10
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.10 ISSUED:  4/21/2015'/
@


1.452
log
@for "ML"
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.09 ISSUED:  2/8/2015'/
@


1.451
log
@version 22.08 for MRC 8 bit integer
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.08 ISSUED:  1/19/2015'/
@


1.450
log
@22.07 for 'DIS'
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.07 ISSUED:  1/05/2015'/
@


1.449
log
@for 'PO R' and 'FS VAL'
@
text
@d11 1
a11 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.06 ISSUED: 12/05/2014'/
@


1.448
log
@22.05 version for: 'FQ Q'
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.05 ISSUED: 11/07/2014'/
@


1.447
log
@22.04 for copymrc stack support
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.04 ISSUED: 09/15/2014'/
@


1.446
log
@FORMAT('  Running: ,   NLOG = 0 for starting driv1,   version 22.03
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.03 ISSUED: 08/29/2014'/
@


1.445
log
@22.02 for 'CP' keepext bug
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.02 ISSUED: 08/26/2014'/
d333 1
d336 1
d380 1
a380 1
9095       FORMAT(' Running: ',A)
@


1.444
log
@version 22.01 for 'LI T [xval]'
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.01 ISSUED: 08/18/2014'/
@


1.443
log
@new version 22.00
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  22.00 ISSUED: 07/31/2014'/
@


1.442
log
@version 21.23 for non spider file 'CP'
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.23 ISSUED: 06/02/2014'/
@


1.441
log
@version for 'SPH', REG_GET_SEL(ISTOP,FCHAR(ILEFPAR:NCHAR),.TRUE.,.TRUE.,
@
text
@d11 1
a11 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.22 ISSUED: 05/21/2014'/
@


1.440
log
@21.21 for wantsqrts in FSC op
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.21 ISSUED: 05/15/2014'/
d586 2
a587 1
           CALL REG_GET_SEL(ISTOP,FCHAR(ILEFPAR:NCHAR),.TRUE.,.FALSE.,
@


1.439
log
@version 21.20 for relion2spi
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.20 ISSUED: 04/29/2014'/
@


1.438
log
@21.19 for 'DOC SEP'
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.19 ISSUED: 04/03/2014'/
@


1.437
log
@21.18 for cp from tif
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.18 ISSUED: 03/07/2014'/
@


1.436
log
@release 20.17
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.17 ISSUED: 01/27/2014'/
@


1.435
log
@== used, 'NC' does not close ndat, new version
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.16 ISSUED: 01/09/201r'/
@


1.434
log
@set_stack_size call needed for PGI 2013 compiler (buggy)
@
text
@d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.15 ISSUED: 12/27/2013'/
d185 1
a185 1
        IF (MYPID .EQ. 0)WRITE(6,*) ' NPROCS, ICOMM: ', NPROCS,ICOMM
d352 1
a352 1
        IF (MYPID .LE. 0) THEN
d411 1
a411 1
        IF (NUMARG .GT. 1) GOTO 5300
d420 1
a420 1
        IF (COPT .EQ. 'I' .AND. NLOOP .GT. 0 .AND. ILOOP .EQ. 1) THEN 
d422 1
a422 1
           IF (IDOTOP .GE. 2 ) THEN
d425 1
a425 1
                 IF (IDOSTK(1,I) .GT. 1) LUNDONOW = 0
d427 2
a428 2
           ELSEIF (IDOTOP .EQ. 1) THEN
              IF (NLOOP .LE. 0) LUNDONOW = 0
d438 3
a440 3
5100    IF (NALPH  .LT. 1 .OR. 
     &      FCHAR(:1) .EQ. ';' .OR. 
     &      FCHAR(:1) .EQ. '!') GOTO 5000 
d442 1
a442 1
5300    IF (NTRACE .GT. 0 .AND. MYPID .LE. 0) THEN
d453 1
a453 1
        IF (FCHAR(:1) .EQ. '@@') GOTO 5600
d459 1
a459 1
        IF (ILBRAK .GT. 0) THEN
d461 1
a461 1
           IF (IEQ .GT. ILBRAK) THEN
d464 2
a465 2
              GLOBAL = (FCHAR(1:2) .EQ. 'GL' .OR. FCHAR(1:2) .EQ. 'gl'
     &             .OR. FCHAR(1:2) .EQ. 'Gl' .OR. FCHAR(1:2) .EQ. 'gL')
d469 2
a470 2
              IF (IRTFLG .EQ. 0) GOTO 5000   ! HAVE SET THE VARIABLE
              IF (IRTFLG .EQ. 1) GOTO 5000   ! ERROR IN SETTING
d473 1
a473 1
              IF (IRTFLG .EQ. 2) THEN
d493 1
a493 1
     &      (FCHAR(4:4).EQ.'('   .OR. FCHAR(5:5).EQ.'(' )) GOTO 6800
d496 1
a496 1
        IF (FCHAR(1:1) .EQ. '[') GOTO 6800
d501 1
a501 1
     &      NALPH .EQ. 3) GOTO 5600
d507 1
a507 1
        IF (FCHAR(1:2) .EQ. 'LB' .AND. NLOOP .GE. 1) GOTO 8800
d509 2
a510 2
        IF (FCHAR(1:5) .EQ. 'ENDDO'  .AND. NLOOP .GE. 1) GOTO 8800
        IF (FCHAR(1:6) .EQ. 'END DO' .AND. NLOOP .GE. 1) GOTO 8800
d513 1
a513 1
        IF (FCHAR(1:2) .EQ. 'LB' .AND. NLOOP .LE. 0) GOTO 5000
d522 1
a522 1
        IF (IRTFLG .EQ. 0) GOTO 5000
d528 8
a535 8
        IF (FCHAR(1:6) .EQ. 'ELSEIF' .OR.
     &      FCHAR(1:7) .EQ. 'ELSE IF')  GOTO 10795
        IF (FCHAR(1:2) .EQ. 'IF'  .OR.
     &      FCHAR(1:2) .EQ. 'GO')       GOTO 10800
        IF (FCHAR(1:4) .EQ. 'ELSE')     GOTO 10798
        IF (FCHAR(1:5) .EQ. 'ENDIF')    GOTO 10799
        IF (FCHAR(1:5) .EQ. 'CYCLE')    GOTO 10796
        IF (FCHAR(1:4) .EQ. 'EXIT')     GOTO 10797
d571 1
a571 1
        FROMBATCH = (COPT .EQ. 'B')
d573 1
a573 1
        ISATAT    = (FCHAR(1:2) .EQ. '@@@@')
d579 1
a579 1
        IF (ILEFPAR .GT. 0 .AND. ISATAT) THEN
d584 1
a584 1
        ELSEIF (ILEFPAR .GT. 0) THEN
d602 1
a602 1
        IF (ISTOP .GT. MAXPRC) THEN
d643 1
a643 1
        IF (COPT .EQ. 'I') THEN
d645 1
a645 1
          IF (MYPID .LE. 0) THEN
d656 1
a656 1
        IF (MYPID .LE. 0) THEN
d665 1
a665 1
        IF (NUMARG .GE. 4) THEN
d681 1
a681 1
           DO WHILE (IFIRST .LT. NLETA) 
d683 1
a683 1
              IF (IGO .LE. 0) EXIT
d688 1
a688 1
                 IF (NTOEQ .LT. 0)THEN
d694 2
a695 2
                 IF (ARG4(IGO:IGO) .EQ. 'X' .OR. 
     &               ARG4(IGO:IGO) .EQ. 'x') THEN
d731 1
a731 1
           IF (PNAME .EQ. PROCFL(NUMPROCNOW)(:MAXNAM)) THEN
d745 1
a745 1
           IF (NUMPRC .GT. MAXPRCNAM) THEN
d759 1
a759 1
           IF (VERBOSE .and. MYPID .LE. 0) WRITE(NDAT,*) ' '
d769 1
a769 1
              IF (VERBOSE .and. MYPID .LE. 0) 
d776 1
a776 1
              IF (NLINES .EQ. 1 .AND. NCHAR .GT. 0) THEN
d778 1
a778 1
                 IF (NCHARM .GT. 0) THEN
d785 1
a785 1
                    IF (ILEFBRAK .EQ. 1 .AND. IRITBRAK .EQ. NCHARM) THEN
d789 1
a789 1
                       IF (MYPID .LE. 0) WRITE(NOUT,*) 
d791 1
a791 1
                    ENDIF   ! (ILEFBRAK .EQ. 1 .... 
d793 1
a793 1
                    IF (MESG(1:1) .EQ. '(') THEN
d797 3
a799 3
                    ENDIF   ! (MESG(1:1) .EQ. '(')
                 ENDIF      ! (NCHARM .GT. 0) 
              ENDIF         ! (NLINES .EQ. 1) 
d802 2
a803 2
              IF ((MESG(1:1) .EQ. 'L' .OR. MESG(1:1) .EQ. 'l') .AND.
     &            (MESG(2:2) .EQ. 'B' .OR. MESG(2:2) .EQ. 'b') .AND.
d808 1
a808 1
                 IF (NUMLABS .GT. 0) THEN
d811 1
a811 1
                       IF (LABGOT(I) .EQ. ILBNO) THEN
d820 1
a820 1
                 IF (NUMLABS .LE. MAXNUMLAB) THEN
d827 1
a827 1
              ENDIF ! END OF: IF ((MESG(1:1) .EQ. 'L' ......
d836 1
a836 1
           IF (VERBOSE .AND. MYPID .LE. 0) WRITE(NDAT,*) ' '
d858 1
a858 1
        IF (PLINE(1:1) .EQ. '(') THEN
d864 1
a864 1
           IF (PLINE(2:2) .EQ. '[') THEN
d912 1
a912 1
10000   IF (COPT .EQ. 'I') THEN
d915 1
a915 1
        ELSEIF (ISTOP .LE. 1) THEN
d923 1
a923 1
        IF (NARGSREC(ISTOP) .GT. 0) THEN
d945 1
a945 1
        FROMBATCH = ISTOP .GT. 2
d949 1
a949 1
        IF (LOOPREG .GT. 0)
d953 1
a953 1
        IF (MYPID .LE. 0) THEN
d963 1
a963 1
        IF (ISTOP .GT. 1) THEN
d986 1
a986 1
        IF (COPT .EQ. 'I' .AND. ILOOP .GT. 1)  NIN = LUNDO
d1018 1
a1018 1
      IF (MYPID .EQ. 0) WRITE(6,8405) TT1-TT0
d1049 1
a1049 1
8600    IF (COPT .EQ. 'I' .AND. NLOOP .LE. 0) THEN
d1068 1
a1068 1
        IF (NLET .EQ. 2) THEN
d1097 1
a1097 1
        IF (IRTFLG .NE. 0 .OR. NVAL .LT. 2) THEN
d1105 1
a1105 1
        IF (NVAL .GT. 2)  LOOPINC = NUML(3)
d1109 1
a1109 1
        IF (LOOPREG .GT. 0) THEN
d1123 1
a1123 1
        IF (IDOTOP .GT. MAXPRC) THEN
d1133 1
a1133 1
        IF (LBNO .LT. 0) THEN
d1136 1
a1136 1
           IF (COPT .EQ. 'I') LBNO = -NDOLINE
d1148 1
a1148 1
        IF (VERBOSE .and. MYPID .LE. 0) THEN 
d1159 1
a1159 1
8800    IF (FCHAR(1:2) .EQ. 'LB') THEN
d1182 1
a1182 1
        IF (ILOOP .LE. NLOOP) THEN
d1184 1
a1184 1
          IF (COPT .EQ. 'I' .AND. ILOOP .EQ. 2) THEN
d1189 1
a1189 1
          IF (LOOPREG .GT. 0)
d1204 1
a1204 1
          IF (VERBOSE .AND. MYPID .LE. 0) 
d1216 1
a1216 1
        IF (IDOTOP .LT. 1 .OR. IDOTOP .GT. MAXPRC) THEN
d1231 1
a1231 1
        IF (LOOPREG .GT. 0) THEN
d1235 1
a1235 1
        IF (COPT .EQ. 'I' .AND. ILOOP .EQ. 1) THEN
d1239 1
a1239 1
           IF (IDOTOP .GE. 2 ) THEN
d1242 1
a1242 1
                 IF (IDOSTK(1,I) .GT. 1) NIN = LUNDO
d1248 1
a1248 1
        IF (COPT .EQ. 'I' .AND. IDOTOP .EQ. 1) THEN
d1258 1
a1258 1
10795   IF (IFLEVEL .GE. 1 .AND. (.NOT. USEELSE(ISTOP,IFLEVEL))) THEN
d1273 1
a1273 1
        ELSEIF (LABEL(1:5) .EQ. 'ENDDO' .AND. JUMP) THEN
d1277 1
a1277 1
        ELSEIF (LABEL(1:5) .EQ. 'CYCLE' .AND. JUMP) THEN
d1285 1
a1285 1
        ELSEIF (LABEL(1:1) .EQ. ' ') THEN
d1290 1
a1290 1
        ELSEIF (FCHAR(1:6) .EQ. 'ELSEIF') THEN
d1301 1
a1301 1
        IF (LABEL(1:4) .EQ. 'ELSE') THEN
d1305 1
a1305 1
           IF (IFLEVEL .LE. 0) THEN
d1309 1
a1309 1
           ELSEIF (IFLEVEL .GT. MAXPRC) THEN
d1331 1
a1331 1
        IF (NEWLOOP .LT. 0) THEN
d1333 1
a1333 1
           IF (COPT .EQ. 'I') THEN
d1340 1
a1340 1
           IF (IDOTOP .GT. MAXPRC .OR. IDOTOP .LE. 0) THEN
d1354 1
a1354 1
           IF (LOOPREG .GT. 0) THEN
d1386 1
a1386 1
        IF (IFLEVEL .LE. 0) THEN
d1429 1
a1429 1
           IF (INSTR(I:I) .GE. '!' .AND. INSTR .LE.  '~') THEN
d1482 1
a1482 1
      IF (NCHARID .LE. 0) THEN
d1498 1
a1498 1
      IF (IREG .GT. 0 .OR. SYMPARID(2:2) .EQ. '_' ) THEN
d1509 1
a1509 1
         IF (IEND .LE. 0) EXIT     ! NO MORE TOKENS
d1518 1
a1518 1
            IF (NEQ .GT. 0) THEN
d1538 1
a1538 1
            IF (ICVAR .LE. 0 .OR. IRTFLG .NE. 0) THEN
d1602 1
a1602 1
        IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
d1607 1
a1607 1
          IF (MYPID .LE. 0)  WRITE(NOUT,90) PNAME 
d1620 1
a1620 1
          IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
d1657 1
a1657 1
        IF(MYPID .EQ. 0)WRITE(6,*) ' NPROCS = ', NPROCS,' icomm:',icomm
d1662 1
a1662 1
            IF ( MYPID .EQ. 0 ) THEN
d1675 1
a1675 1
           IF ( N .LE. 0 ) EXIT
d1693 1
a1693 1
           IF (MYPID .EQ. 0) THEN
@


1.433
log
@*** empty log message ***
@
text
@d57 1
d67 1
a67 1
        PARAMETER (MAXKEY=9999) 
d80 3
a82 3
        INTEGER, PARAMETER                :: MAXDI = 5000000
        INTEGER, DIMENSION(MAXDI/5)       :: PLINEGO
        CHARACTER, DIMENSION(4*4*MAXDI/5) :: PDATA
d153 3
d160 1
a160 1
        DATA CVERS/'VERSION:  UNIX  21.13 ISSUED: 12/16/2013'/
d191 14
@


1.432
log
@version 21.12 for 'ROT' z rot bug fix
also has spire guitools consolidation in docs
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.12 ISSUED: 12/03/2013'/
@


1.431
log
@21.11 for CTF FIND, ro sd r
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.11 ISSUED: 11/25/2013'/
@


1.430
log
@version update to 20.10
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.10 ISSUED: 11/12/2013'/
@


1.429
log
@HIS support
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.07 ISSUED: 08/12/2013'/
d313 1
a313 1
        IF (NUMARG .LE. 0) THEN
d356 2
a357 1
9096       FORMAT(/' PROJECT EXTENSION: ',A3,'   DATA EXTENSION: ',A3,/)
@


1.428
log
@new version
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.06 ISSUED: 05/22/2013'/
@


1.427
log
@21.05 for gfort
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.05 ISSUED: 05/01/2013'/
@


1.426
log
@tabs,  delay_free removed
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.04 ISSUED: 05/01/2013'/
@


1.425
log
@*** empty log message ***
@
text
@d62 1
a62 1
C	ONE PLUS THE MAXIMUM NUMBER OF REGISTERS PER KEY IN 'UD IC'
d65 2
a66 2
C	MAXIMUM NUMBER OF KEYS IN 'UD IC'
	PARAMETER (MAXKEY=9999) 
d68 2
a69 2
C	MAXIMUM NUMBER OF REGISTER ARGUMENTS SENT TO A PROCEDURE
	INTEGER, PARAMETER :: NPARG=24    
d71 1
a71 1
C	MAXIMUM NUMBER OF NESTED 'IF's
d86 3
a88 3
	INTEGER   :: IDOSTK(7,MAXPRC),NARGSREC(MAXPRC),LOOPSV(8,MAXPRC)
	INTEGER   :: IARGSENT(NPARG,MAXPRC),IARGSREC(NPARG,MAXPRC)
	INTEGER   :: IFSV(MAXPRC)
d94 1
a94 1
	LOGICAL   :: JUMP,EX,ISDIGI,ISCHAR,DELETIT,LISTIT
d102 1
a102 1
	CHARACTER(LEN=40)     :: CVERS
d106 3
a108 3
	CHARACTER(LEN=5)      :: LABEL 
	CHARACTER(LEN=4)      :: CXNUM,CREG
	CHARACTER(LEN=3)      :: LOGM
d114 1
a114 1
	COMMON /DOC_BUF/ DBUF(MAXREG,MAXKEY,2)
d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.04 ISSUED: 04/22/2013'/
d158 2
a159 2
	DATA RESULM/'results'/
	DATA LOGM/'LOG'/
d163 1
a163 1
	DATA IDOTOP,IFLEVEL/1,0/
d192 1
a192 1
	NLOG     = NLOGP
d200 2
a201 2
	NSTDOUTP  = 6
	NOUT      = NSTDOUTP
a211 1
        DELAY_FREE     = .FALSE.
d243 1
a243 1
	T1 = SECNDS(0.0)
d256 1
a256 1
	COPT = 'I'
d260 1
a260 1
	DO NUMPROCNOWT=1,MAXPRCNAM
d263 1
a263 1
	NUMPRC     = 1
d321 1
a321 1
	IF (IER .NE. 0)
d324 2
a325 2
	OPEN(NLOG,FILE=LOG,STATUS='UNKNOWN',IOSTAT=IER)
	IF (IER .NE. 0) 
d330 1
a330 1
	IF (IER .NE. 0) 
d346 1
a346 1
	   IF (IER .NE. 0) STOP '*** UNABLE TO OPEN RESULTS FILE ***'
d349 2
a350 2
	   WRITE(NDAT,9090)
	   WRITE(NDAT,9091)
d352 2
a353 2
	   WRITE(NDAT,9093)CVERS
	   WRITE(NDAT,9094)CDATT(1:11),CTIM
d355 2
a356 2
	   WRITE(NDAT,9096) PRJEXC(1:3),DATEXC(1:3)
9096	   FORMAT(/' PROJECT EXTENSION: ',A3,'   DATA EXTENSION: ',A3,/)
d393 1
a393 1
	GOTO 5000
d423 2
a424 2
5300	IF (NTRACE .GT. 0 .AND. MYPID .LE. 0) THEN
	   IF (IABSLP .NE. 0 .AND. LOOPREG .NE. 0) THEN
d434 1
a434 1
	IF (FCHAR(:1) .EQ. '@@') GOTO 5600
d440 1
a440 1
	IF (ILBRAK .GT. 0) THEN
d463 1
a463 1
	IF(((.NOT. ISCHAR(FCHAR(1:1)))   .AND.
d474 1
a474 1
     &	    (FCHAR(4:4).EQ.'('   .OR. FCHAR(5:5).EQ.'(' )) GOTO 6800
d480 1
a480 1
	IF (ISCHAR(FCHAR(1:1)) .AND.
d488 1
a488 1
	IF (FCHAR(1:2) .EQ. 'LB' .AND. NLOOP .GE. 1) GOTO 8800
d490 2
a491 2
	IF (FCHAR(1:5) .EQ. 'ENDDO'  .AND. NLOOP .GE. 1) GOTO 8800
	IF (FCHAR(1:6) .EQ. 'END DO' .AND. NLOOP .GE. 1) GOTO 8800
d494 1
a494 1
	IF (FCHAR(1:2) .EQ. 'LB' .AND. NLOOP .LE. 0) GOTO 5000
d535 2
a536 2
6800	CALL ARASQ(FCHAR,NALPH,GLOBAL,IFLAG)
	IF (IFLAG .NE. 0)THEN
d541 1
a541 1
	GOTO 5000
d545 1
a545 1
	STOP '**** FATAL ERROR'
d583 1
a583 1
	IF (ISTOP .GT. MAXPRC) THEN
d589 7
a595 7
	LOOPSV(1,ISTOP) = ILOOP     ! CURRENT LOOP ITERATION
	LOOPSV(2,ISTOP) = IABSLP    ! CURRENT LOOP COUNTER
	LOOPSV(3,ISTOP) = LOOPREG   ! REG. FOR LOOP COUNTER
	LOOPSV(4,ISTOP) = NLOOP     ! NUMBER OF ITERATIONS FOR LOOP
	LOOPSV(6,ISTOP) = IDOTOP    ! LOOP STACK POINTER
	LOOPSV(7,ISTOP) = LBNO      ! LABEL/NDOLINE FOR END OF CURRENT LOOP
	LOOPSV(8,ISTOP) = LOOPINC   ! LOOP COUNTER INCREMENT
d613 7
a619 7
	IDOSTK(1,IDOTOP) = ILOOP      ! CURRENT LOOP ITERATION
	IDOSTK(2,IDOTOP) = IABSLP     ! CURRENT LOOP COUNTER
	IDOSTK(3,IDOTOP) = LOOPREG    ! REG. FOR LOOP COUNTER
	IDOSTK(4,IDOTOP) = NLOOP      ! NUMBER OF ITERATIONS FOR LOOP
	IDOSTK(5,IDOTOP) = ISTOP      ! PROCEDURE STACK LEVEL
	IDOSTK(6,IDOTOP) = LBNO       ! LABEL/NDOLINE FOR END OF CURRENT LOO
	IDOSTK(7,IDOTOP) = LOOPINC    ! LOOP COUNTER INCREMENT
d622 1
a622 1
	IPSTACK(ISTOP) = IBCNT
d628 1
a628 1
6320	     FORMAT(/,' .OPERATION:')
d638 3
a640 3
	   IF (VERBOSE) WRITE(NDAT, *) ' '
	   WRITE(NDAT, 6380) PNAME(1:NPNAME)
6380	   FORMAT('  -- START OF: ',A,'    --')
d701 2
a702 2
	NIN   = 1
	NOUT  = NDAT
d706 2
a707 2
	IF (NLOG .NE. 0) CLOSE(NLOG)
	NLOG = 0
d719 1
a719 1
    	IF (LISTIT) THEN
d747 1
a747 1
	      NLINES = NLINES + 1
d757 1
a757 1
	      IF (NLINES .EQ. 1 .AND. NCHAR .GT. 0) THEN
d759 1
a759 1
	         IF (NCHARM .GT. 0) THEN
d799 1
a799 1
C	         WRITE(NOUT,*)' PUSHING LABEL: ',ILBNO
d804 1
a804 1
	            WRITE(NOUT,*)' --- WARNING TOO MANY LABELS, ',
d829 1
a829 1
	NARGSREC(ISTOP)   = 0
d839 1
a839 1
	IF (PLINE(1:1) .EQ. '(') THEN
d855 2
a856 2
	      IF (NARGREG .NE. NARGREG1) THEN
	        WRITE(NOUT,*) 
d859 1
a859 1
	        CALL ERRT(102, 
d861 1
a861 1
	     ENDIF
d870 1
a870 1
	     WRITE(NOUT,*) 
d873 1
a873 1
	     CALL ERRT(102, 
d875 1
a875 1
	   ENDIF
d883 1
a883 1
	GOTO 5000
d900 1
a900 1
	ENDIF
d904 1
a904 1
	IF (NARGSREC(ISTOP) .GT. 0) THEN
d908 1
a908 1
	ENDIF
d911 7
a917 7
	ILOOP    = LOOPSV(1,ISTOP)    ! CURRENT LOOP ITERATION
	IABSLP   = LOOPSV(2,ISTOP)    ! CURRENT LOOP COUNTER
	LOOPREG  = LOOPSV(3,ISTOP)    ! REG. FOR LOOP COUNTER
	NLOOP    = LOOPSV(4,ISTOP)    ! NUMBER OF ITERATIONS FOR LOOP
	IDOTOP   = LOOPSV(6,ISTOP)    ! LOOP STACK POINTER
	LBNO     = LOOPSV(7,ISTOP)    ! CURRENT LOOP LABEL NO.
	LOOPINC  = LOOPSV(8,ISTOP)    ! LOOP COUNTER INCREMENT
d920 1
a920 1
	IFLEVEL          = IFSV(ISTOP)
d923 1
a923 1
	IBCNT     = IPSTACK(ISTOP)
d925 1
a925 1
	ISTOP     = ISTOP - 1
d934 4
a937 1
	IF (MYPID .LE. 0) THEN
a938 3
	    WRITE(NDAT,10080) PNAME(1:NPNAME)
10080	    FORMAT('  -- END OF: ',A,'  --')
	    IF (VERBOSE) WRITE(NDAT,*) ' '
d944 1
a944 1
	IF (ISTOP .GT. 1) THEN
d950 2
a951 2
	   GOTO 5000
	ENDIF
d956 3
a958 3
	COPT  = 'I'
	IBCNT = 0
	NIN   = 5
d960 1
a960 1
	NLOG  = NLOGP
d969 1
a969 1
	GOTO 5000
d1022 1
a1022 1
C NLOOP IS THE NUMBER OF ITERATIONS FOR THE LOOP (IF < 1, NOT IN LOOP).  
d1100 1
a1100 1
	IDOTOP = IDOTOP + 1      ! LOOP STACK POINTER
d1104 1
a1104 1
	IF (IDOTOP .GT. MAXPRC) THEN
d1121 7
a1127 7
	IDOSTK(1,IDOTOP) = ILOOP      ! CURRENT LOOP ITERATION
	IDOSTK(2,IDOTOP) = IABSLP     ! CURRENT LOOP COUNTER
	IDOSTK(3,IDOTOP) = LOOPREG    ! REG. FOR LOOP COUNTER
	IDOSTK(4,IDOTOP) = NLOOP      ! NUMBER OF ITERATIONS FOR LOOP
	IDOSTK(5,IDOTOP) = ISTOP      ! PROCEDURE STACK LEVEL
	IDOSTK(6,IDOTOP) = LBNO       ! LABEL FOR END OF CURRENT LOOP
	IDOSTK(7,IDOTOP) = LOOPINC    ! LOOP INCREMENT
d1132 1
a1132 1
	GOTO 5000
d1156 2
a1157 2
	ILOOP  = ILOOP  + 1
	IABSLP = IABSLP + LOOPINC
d1163 1
a1163 1
	IF (ILOOP .LE. NLOOP) THEN
d1174 2
a1175 2
	  IDOSTK(1,IDOTOP)    = ILOOP
	  IDOSTK(2,IDOTOP)    = IABSLP
d1197 1
a1197 1
	IF (IDOTOP .LT. 1 .OR. IDOTOP .GT. MAXPRC) THEN
d1203 5
a1207 5
	IABSLP      = IDOSTK(2,IDOTOP)    ! CURRENT LOOP COUNTER
	LOOPREG     = IDOSTK(3,IDOTOP)    ! REGISTER FOR LOOP COUNTER
	NLOOP       = IDOSTK(4,IDOTOP)    ! NUMBER OF ITERATIONS FOR LOOP
	LBNO        = IDOSTK(6,IDOTOP)    ! LOOP LABEL NUMBER
	LOOPINC     = IDOSTK(7,IDOTOP)    ! LOOP COUNT INCREMENT
d1236 1
a1236 1
	GOTO 5000
d1242 1
a1242 1
	   CALL FINDENDIF('ENDIF',IFLEVEL,IRTFLG)
d1262 1
a1262 1
	ELSEIF (LABEL(1:4) .NE. 'ELSE' .AND. .NOT. JUMP) THEN
d1305 1
a1305 1
	IF (.NOT. ISDIGI(LABEL(4:4))) LABEL(4:4) = ' '
d1309 1
a1309 1
	CALL FINDLBQ(LABEL,IDOTOP,NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRT)
d1314 1
a1314 1
	   IF (COPT .EQ. 'I') THEN
d1321 1
a1321 1
	   IF (IDOTOP .GT. MAXPRC .OR. IDOTOP .LE. 0) THEN
d1327 5
a1331 5
	   IABSLP      = IDOSTK(2,IDOTOP)   ! CURRENT LOOP COUNTER
	   LOOPREG     = IDOSTK(3,IDOTOP)   ! REG. FOR LOOP COUNTER
	   NLOOP       = IDOSTK(4,IDOTOP)   ! NUMBER OF ITERATIONS FOR LOOP
	   LBNO        = IDOSTK(6,IDOTOP)   ! LOOP LABEL NUMBER
	   LOOPINC     = IDOSTK(7,IDOTOP)   ! LOOP COUNTER INCREMENT
d1341 1
a1341 1
	GOTO 5100
d1349 1
a1349 1
	GOTO 5100
d1362 1
a1362 1
	GOTO 5100
d1372 1
a1372 1
	   CALL FINDENDIF('ENDIF',IFLEVEL,IRTFLG)
d1385 1
a1385 1
	END
d1571 1
a1571 1
	NFSTRT = INDEX(STR(1:NCHAR),'@@',BACK=.TRUE.) + 1
@


1.424
log
@20.04 version
@
text
@d171 1
a171 1
C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  CODE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@


1.423
log
@version for cp to jpg
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.03 ISSUED: 04/09/2013'/
@


1.422
log
@21.02   'tf ed' no astig
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.02 ISSUED: 03/12/2013'/
@


1.421
log
@20.13
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.01 ISSUED: 02/06/2013'/
@


1.420
log
@VERSION:  UNIX  21.00
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  21.00 ISSUED: 01/03/2013'/
@


1.419
log
@version 21
@
text
@d156 1
a156 2
C       DATA CVERS/'VERSION:  UNIX  20.19 ISSUED: 12/12/2012'/ 
        DATA CVERS/'VERSION:  UNIX  21.00 ISSUED: 01/03/2013'/ 
@


1.418
log
@version 2013
@
text
@d157 1
a157 1
        DATA CVERS/'VERSION:  2013.00  ISSUED: 01/02/2013'/ 
@


1.417
log
@fbs2 wx bug fix
@
text
@d11 1
a11 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d156 2
a157 1
        DATA CVERS/'VERSION:  UNIX  20.19 ISSUED: 12/12/2012'/ 
d297 1
a297 1
 9090   FORMAT('  \\__`O O''__/        SPIDER  --  COPYRIGHT')
d311 1
@


1.416
log
@please cite
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.18 ISSUED: 11/29/2012'/ 
d309 1
a309 1
     &         ' 1996; 116: 190-199.',/)
@


1.415
log
@FQ, ADD2 installed.
@
text
@d287 1
a287 1
        IF (MYPID .LE. 0) THEN
d289 1
d296 5
a300 5
19090   FORMAT(/,' \__`O O''__/        SPIDER  --  COPYRIGHT')
 9091   FORMAT(' ,__xXXXx___        HEALTH RESEARCH INC., ALBANY, NY.') 
 9092   FORMAT('  __xXXXx__')
19093   FORMAT(' /  /xxx\  \        ',A)
19094   FORMAT('   /     \          DATE:    ',A,'    AT  ',A,//)
d302 8
a309 3
 9090   FORMAT(/,' \\__`O O''__/        SPIDER  --  COPYRIGHT')
 9093   FORMAT(' /  /xxx\\  \\        ',A)
 9094   FORMAT('   /     \\          DATE:     ',A,'    AT  ',A,//)
@


1.414
log
@20.17 'VO RA' & 'NORM'
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.17 ISSUED: 10/10/2012'/ 
@


1.413
log
@necho initialized to zero for endit use
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.16 ISSUED:  9/11/2012'/ 
@


1.412
log
@20.16  FSC mask
@
text
@d193 1
d216 1
d986 1
a986 1
8400  DELETIT = FCHAR(1:4) .EQ. 'EN D'
d988 1
a988 1
      IF (MYPID .LE. 0) CALL ENDIT(' COMPLETED',DELETIT,RESULT)
@


1.411
log
@version 20.14   nplans in apmaster=44
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.15 ISSUED:  7/27/2012'/ 
@


1.410
log
@20.14 for raised cosine 'FQ'
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.14 ISSUED:  7/20/2012'/ 
@


1.409
log
@20.13.0  has rot bug fixed
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.13 ISSUED:  6/13/2012'/ 
@


1.408
log
@verion 20.12 no: MA or RT s* bug
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.12 ISSUED:  5/14/2012'/ 
@


1.407
log
@version  gfortran
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.11 ISSUED:  4/15/2012'/ 
@


1.406
log
@20.10 version
@
text
@d127 2
d130 3
a132 1
        INTEGER                    :: ITIME(8)
d134 1
d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  20.10 ISSUED:  4/05/2012'/ 
d221 8
d232 1
a232 1
        IF (ISEED(1) .EQ. 0 .AND. ISEED(2) .EQ. 0) THEN
d237 1
a237 1
           CALL RANDOM_SEED(PUT=ISEED)
d239 1
d369 3
d373 1
d375 1
a375 1
9098          FORMAT(' Current process id: ',I9)
@


1.405
log
@UNIX  20.09 ISSUED:  3/14/2012
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.09 ISSUED:  3/14/2012'/ 
@


1.404
log
@20.08
@
text
@d11 1
a11 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.08 ISSUED:  2/22/2012'/ 
@


1.403
log
@version date
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.07 ISSUED:  1/23/2012'/ 
@


1.402
log
@'IQ VER' support
@
text
@d950 1
a950 1
C     CVERS/'VERSION:  UNIX  20.07 ISSUED:  1/23/2012'/ 
@


1.401
log
@version 20.07 1/23/12
@
text
@d492 1
a492 1
C       HANDLE SHORT LOCAL OPS: 'EN','DO','LB','RE','MD','OF'
d504 2
d946 10
@


1.400
log
@UNIX  20.06
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.06 ISSUED:  1/06/2012'/ 
@


1.399
log
@'RR S' 150 var, IF(a>b), ! comments ,nrms removal
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.05 ISSUED: 12/06/2011'/ 
@


1.398
log
@version has 'CL CLA' factor list
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.04 ISSUED: 11/30/2011'/ 
@


1.397
log
@iray in apshc
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.03 ISSUED: 11/09/2011'/ 
@


1.396
log
@'AP SHC' filename bug, some fbs rotate bugs fixed
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.02 ISSUED: 11/01/2011'/ 
@


1.395
log
@version 20.01 for rot, ququ
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.01 ISSUED: 10/19/2011'/ 
@


1.394
log
@20.0
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  20.00 ISSUED: 10/12/2011'/ 
@


1.393
log
@removed USE_FBP_INTERP
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.13 ISSUED: 09/28/2011'/ 
@


1.392
log
@ifndef SP_NO_VERSION needed for profiling
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.12 ISSUED: 08/30/2011'/ 
a208 1
        USE_FBP_INTERP = .FALSE. ! NEW JUN 2011
@


1.391
log
@ckmirror in ap, apfou support, apref search distance bug fixed, cg ph
@
text
@d314 1
d316 1
@


1.390
log
@use_FBS_INTERP, new version
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.11 ISSUED: 07/25/2011'/ 
@


1.389
log
@USE_FBP_INTERP = .FALSE., 'CP TO OPEND BUG FIXED', 19.10
@
text
@d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.10 ISSUED: 06/16/2011'/ 
d210 1
@


1.388
log
@#ifdef  HAS_IEEE
@
text
@d123 1
a123 1
        COMMON /COMMUN/  BUFC(NCOMSIZ)
d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.09 ISSUED: 05/11/2011'/ 
d198 16
a213 15
        ISTOP       = 1
        ISTOPR      = 1
        IBCNT       = 0
        NLOOP       = 0       ! TOTAL NUMBER OF LOOP ITERATIONS
        ILOOP       = 1       ! CURRENT LOOP ITERATION
        IFOUND      = 1
        NTRACE      = 0
        VERBOSE     = .TRUE.
        DELAY_FREE  = .FALSE.
        SILENT      = .FALSE.
        LEGACYPAR   = .FALSE. ! () IN DO NO LONGER! dec 2010
        MAXDIM      = MAXDI   ! SET SIZE OF COMMON BUFFER
        NUMFFTWTH   = 0       ! NUMBER OF FFTW3 THREADS
        NULL        = CHAR(0)
        NQ12        = CHAR(34) // CHAR(39)   ! QUOTES
d231 1
a231 1
        DO  I=1,5
@


1.387
log
@fftw in aprings plans, lundocredlin errt bug, doc file 1pg13.6
@
text
@d50 1
d56 1
a56 1

d151 1
a151 1
        DATA CVERS/'VERSION:  UNIX  19.08 ISSUED: 04/25/2011'/ 
d963 1
d970 1
a970 1
      call ieee_set_flag( ieee_underflow,     .FALSE. ) ! MAYBE SHUD??)
d972 1
@


1.386
log
@or sh bug fixed
@
text
@d150 1
a150 1
        DATA CVERS/'VERSION:  UNIX  19.07 ISSUED: 04/12/2011'/ 
@


1.385
log
@'AP I' and "bp cg' in mpi bugs fixed
@
text
@d150 1
a150 1
        DATA CVERS/'VERSION:  UNIX  19.06 ISSUED: 04/07/2011'/ 
@


1.384
log
@mpi and mirror bug fix release
@
text
@d11 1
a11 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d150 1
a150 1
        DATA CVERS/'VERSION:  UNIX  19.05 ISSUED: 03/28/2011'/ 
@


1.383
log
@#ifndef __APPLE__
@
text
@d150 1
a150 1
        DATA CVERS/'VERSION:  UNIX  19.04 ISSUED: 03/11/2011'/ 
@


1.382
log
@ ieee no warn add, new version
@
text
@d51 1
d54 2
d962 1
d970 1
@


1.381
log
@rotfirst ap version
@
text
@d50 3
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  19.03 ISSUED: 02/08/2011'/ 
d945 1
a945 2

8900  IF (MYPID .LE. 0) WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
a947 2
CCC   IF (MYPID .LE. 0) WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
C     CLOSE RESULTS & LOG FILE
d958 8
@


1.380
log
@19.02
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  19.02 ISSUED: 01/25/2011'/ 
@


1.379
log
@19.01
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  19.01 ISSUED: 01/06/2011'/ 
@


1.378
log
@LEGACYPAR   = .FALSE. ! () IN DO NO LONGER!
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  19.00 ISSUED: 12/20/2010'/ 
@


1.377
log
@18.20 for 'DOC STAT'
@
text
@d132 2
a133 2
        INTEGER, PARAMETER            :: MAXNUMLAB = 50
        INTEGER, DIMENSION(MAXNUMLAB) :: LABGOT
d136 1
a136 1
        INTEGER, PARAMETER       :: LUNDO = 300   
d138 1
a138 1
        INTEGER, PARAMETER       :: LUNTEXT = 103   
d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.20 ISSUED: 11/23/2010'/ 
d190 1
a190 1
C       INITIALIZE SOME COMMON BLOCK DATA ELEMENTS
d201 1
a201 1
        LEGACYPAR   = .TRUE.  
@


1.376
log
@18.19 doc sort, >2GB inline stacks, ap tool
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.19 ISSUED: 10/27/2010'/ 
@


1.375
log
@/LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.18 ISSUED: 10/22/2010'/ 
@


1.374
log
@18.18
@
text
@d118 1
a118 1
        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE
d183 1
a183 1
        NDAT     = 3
@


1.373
log
@18.17 for tf ed,  vms changes
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.17 ISSUED: 09/14/2010'/ 
@


1.372
log
@18.16 for SD changes
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.16 ISSUED: 08/31/2010'/ 
@


1.371
log
@18.15 for iq sync d
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.15 ISSUED: 08/06/2010'/ 
@


1.370
log
@18.14
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.14 ISSUED: 07/13/2010'/ 
@


1.369
log
@GPL_2010
@
text
@d46 1
a46 1
C
d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.13 ISSUED: 06/17/2010'/ 
@


1.368
log
@18.13
@
text
@d8 1
d10 1
a10 1
C=* Author: J. Frank & A. Leith                                        *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
@


1.367
log
@version 18.12  & CALL SYMPAR_SUB added donotrecurse
@
text
@d143 1
a143 1
        DATA CVERS/'VERSION:  UNIX  18.12 ISSUED: 06/01/2010'/ 
@


1.366
log
@18.11
@
text
@d8 2
a9 2
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
a22 1
C=*                                                                    *
d143 1
a143 1
        DATA CVERS/'VERSION:  UNIX  18.11 ISSUED: 04/20/2010'/ 
d1382 1
d1389 5
d1415 1
a1415 1
      !(6,*) ' Got symparid:',symparid(:nchari),':',nchari
d1418 1
a1418 1
      !write(6,*) 'Queried reg var:', SYMPARID(1:NCHARI), ireg,valdum
d1456 1
d1463 2
a1469 2
            CALL SUBSYMPAR(LINE(IGO:IEND),SYMPARVAL(NCHARV+1:),
     &              NCHARS,0,IRTFLG)
d1471 2
@


1.365
log
@18.10 for AP REF shift bug fix
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.10 ISSUED: 03/23/2010'/ 
@


1.364
log
@FINDLBQ('ENDDO',IDOTOP,NLOOP,IDOSTK,NEWLOOP,IFLEVEL
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.09 ISSUED: 02/26/2010'/ 
@


1.363
log
@version 18.09
@
text
@d1297 1
a1297 1
10797   CALL FINDLBQ('ENDDO',IDOTOP,NLOOP,IDOSTK,NEWLOOP,FLEVEL,IRTFLG)
@


1.362
log
@null unused in equsympar, bug on ibm compiler
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.08 ISSUED: 01/04/2010'/ 
@


1.361
log
@findlbq passes idotop now
@
text
@a1390 1
      NULL      = CHAR(0)
@


1.360
log
@REG_FIND_IREG used
@
text
@d622 1
a622 1
c          write(6,*) 'intial arguments: ',ARG4(1:NLETA)
d647 1
a647 1
c             write(6,*) ' current argument: ',ARGNOW(1:NLETN)
d1192 1
d1252 1
a1252 1
	CALL FINDLBQ(LABEL,NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRT)
d1289 1
a1289 1
10796   CALL FINDLBQ('ENDDO',NLOOP,IDOSTK,NEWLOOP,IFLEVEL,IRT)
d1297 1
a1297 1
10797   CALL FINDLBQ('ENDDO',NLOOP,IDOSTK,NEWLOOP,FLEVEL,IRTFLG)
@


1.359
log
@nested loop exit bug, findlbq, findendif
@
text
@d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.08 ISSUED: 12/30/2009'/ 
d1002 2
a1003 2
           CALL REG_GET_VAR(0,FCHAR(1:ILOCLIM-2),.TRUE.,
     &                      VALUE,LOOPREG,IENDVAR,IERR)
d1013 2
a1014 1
           CALL REG_GET_VAR(0,CREG,.TRUE.,VALUE,LOOPREG,IENDVAR,IERR)
d1188 1
d1237 1
@


1.358
log
@@@@@proc now a procedure
@
text
@d10 1
a10 1
C=* Copyright 1985-2009  Health Research Inc.,                         *
d84 1
d87 1
a87 1
	LOGICAL   :: JUMP,EX,ISDIGI,ISCHAR,DELETIT,INTHELOOP,LISTIT
d144 1
a144 1
        DATA CVERS/'VERSION:  UNIX  18.07 ISSUED: 11/26/2009'/ 
d151 1
a151 1
	DATA IDOTOP,INTHELOOP,IFLEVEL/1,.TRUE.,0/
d395 2
d748 1
d1043 3
d1138 1
d1150 1
d1184 1
a1184 1
	   CALL FINDLBQ('ENDIF',0,0,INTHELOOP,IFLEVEL,IRTFLG)
d1217 1
a1217 2
              CALL FINDLBQ('ELSE',NLOOP,IDOSTK(6,IDOTOP),INTHELOOP,
     &                  IFLEVEL,IRTFLG)
d1239 1
a1239 2
              CALL FINDLBQ('ELSE',NLOOP,IDOSTK(6,IDOTOP),INTHELOOP,
     &                  IFLEVEL,IRTFLG)
d1247 2
a1248 3
C       KEEP READING INPUT LINES TILL LABEL IS FOUND.
C       NO EFFECT ON IFLEVEL
	CALL FINDLBQ(LABEL,NLOOP,IDOSTK(6,IDOTOP),INTHELOOP,IFLEVEL,IRT)
d1251 2
a1252 3
C       IF .NOT. INTHELOOP, WE HAVE PASSED BY CURRENT DO-LOOP LABEL AND
C       MUST POP THE DO-LOOP STACK
        IF (.NOT. INTHELOOP) THEN
d1258 2
a1259 1
           IDOTOP      = IDOTOP - 1      ! LOOP STACK POINTER
d1269 1
d1271 1
a1271 1

d1279 1
a1279 4
C       RESET INTHELOOP FOR NEXT TIME
	INTHELOOP = .TRUE.

C       PROCESS THE OPERATION
d1283 1
a1283 4
10796   CONTINUE
C       KEEP READING INPUT LINES TILL ENDDO IS FOUND. NO EFFECT ON IFLEVEL
	CALL FINDLBQ('ENDDO',NLOOP,IDOSTK(6,IDOTOP),INTHELOOP,
     &               IFLEVEL,IRT)
d1285 1
a1285 2
C       RESET INTHELOOP FOR NEXT TIME
	INTHELOOP = .TRUE.
d1287 1
a1287 1
C       PROCESS THE ENDDO OPERATION
d1291 3
a1293 4
10797   CONTINUE
C       KEEP READING INPUT LINES TILL ENDDO IS FOUND. NO EFFECT ON IFLEVEL
	CALL FINDLBQ('ENDDO',NLOOP,IDOSTK(6,IDOTOP),INTHELOOP,
     &               IFLEVEL,IRTFLG)
d1296 1
a1296 2

C       MAKE THIS LAST ITERATION
d1298 1
a1298 2
C       RESET INTHELOOP FOR NEXT TIME
	INTHELOOP = .TRUE.
d1300 1
a1300 1
C       PROCESS THE ENDDO OPERATION
d1311 1
a1311 1
	   CALL FINDLBQ('ENDIF',0,0,INTHELOOP,IFLEVEL,IRTFLG)
d1324 1
a1325 1
	END
d1484 67
a1614 64

C       -------------  GETPROCFILE ----------------------- GETPROCFILE

C       GET PROCEDURE FILE NAME FROM STR LINE

        SUBROUTINE GETPROCFILE(STR,NCHAR,PNAME,NPNAME,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        CHARACTER(LEN=*)      :: STR,PNAME
        CHARACTER(LEN=MAXNAM) :: PNAMEM
        CHARACTER(LEN=160)    :: MESG
        LOGICAL               :: EX

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       FIND FIRST CHARACTER IN FILENAME
	NFSTRT = INDEX(STR(1:NCHAR),'@@',BACK=.TRUE.) + 1

C       SUBSTITUTE FOR ALL SYM. VAR. IN STR
        !write(6,*) ' Checking: ',STR(NFSTRT:NCHAR)
        CALL SUBSYMPAR(STR(NFSTRT:NCHAR),PNAMEM,NCT,0,IRTFLG)

C       WILL STOP IN FILNAMANDEXT ON ERRT
        CALL FILNAMANDEXT(PNAMEM(:NCT),PRJEXC,PNAME,NPNAME,.TRUE.,IER)

C       TRY TO FIND PROCEDURE IN USER'S DIRECTORY & PROJECT EXTENSION

        !write(6,*) ' Checking: ',pname(NFSTRT:NCHAR)
        IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
        CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)

        IF (.NOT. EX) THEN
C         PROCEDURE FILE DOESN'T EXIST IN USER'S DIRECTORY
          IF (MYPID .LE. 0)  WRITE(NOUT,90) PNAME 
90        FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 

C         TRY AGAIN UNDER 'PROC:*.spi' IN PROC DIR.
C         7/10/88 PROC IS ENV. VAR. FOR DIR. WHERE *.spi FILES ARE al

          CALL MYGETENV('SPPROC_DIR',PNAME,NCHART,
     &                 'dir-for-proc-files',IER)
          IF (IER .NE. 0) CALL ERRT(101,'NO ENVIRONMENT VARIABLE',NE)
          NCHARTN = LNBLNKN(PNAMEM)
          PNAME   = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.spi'
          NPNAME  = NCHART + NCHARTN + 4

          IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
          CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)

          IF (.NOT. EX) THEN
C            THE *.spi FILE DOES NOT EXIST. NOTIFY USER
             MESG = 'PROCEDURE FILE.spi DOES NOT EXIST: '//
     &              PNAME(:NPNAME) 
             CALL ERRT(101,MESG,NE)
             IRTFLG = 1
             RETURN
          ENDIF
        ENDIF

        IRTFLG = 0
        END

@


1.357
log
@support for @@@@proc inlining, cosmetic, version up
@
text
@a91 1
        CHARACTER(LEN=MAXNAM) :: ATATFILE  ! FOR '@@@@' OPERATIONS
a103 2
        CHARACTER(LEN=MAXNAM) :: OFFILE  ! FOR 'OF' OPERATIONS

d117 1
a117 2
C       NINSAVEOF = FLAG FOR '@@@@' OPERATIONS INPUT
        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF
d125 1
a125 1
        COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
d143 1
a143 1
        DATA CVERS/'VERSION:  UNIX  18.07 ISSUED: 11/23/2009'/ 
a187 1
        NINSAVEOF = 0         ! FLAG FOR '@@@@' OPERATIONS INPUT
d191 1
a532 16
        IF (ISATAT) THEN
C          WANT TO INCLUDE ADDITIONAL OPERATIONS IN CURRENT PROCEDURE

C          LOCATE PROCEDURE FILE LISTED IN THE OPERATION LINE
           CALL GETPROCFILE(FCHAR,NCHAR,ATATFILE,NATAT,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 5000

C          OPEN PROCEDURE FILE
           OPEN(LUNTEXT,FILE=ATATFILE,STATUS='OLD',IOSTAT=IER)
           IF (IER .NE. 0) RETURN

           NINSAVEOF = NIN        ! REMEMBER CURRENT OPERATION SOURCE
           NIN       = LUNTEXT    ! SET NEW OPERATION SOURCE FOR RDPR..
           GOTO 5000              ! GET NEXT OPERATION
        ENDIF

d538 4
a541 1
        ISTOP = ISTOP + 1 
d603 1
a603 1
        CALL REG_INIT(ISTOP,IRTFLG)
d607 1
a607 1
C          write(6,*) 'Number of intial arguments: ',numarg
d799 1
d851 1
a851 6
10000   IF (NINSAVEOF > 0) THEN
C          END OF INPUT FROM OPERATIONS TEXT FILE @@@@
           NIN       = NINSAVEOF
           NINSAVEOF = 0
           GOTO 5000
        ELSEIF (COPT .EQ. 'I') THEN
d885 1
d977 1
a977 1
C          MUST COPY FIRST LINE TO INTERACTIVE DO LOOP FILE
a978 1
C          write(6,*) ' saving lundo: ',FCHAR(1:NALPH)
a1052 1

d1069 1
a1069 1
C END OF DO LOOP ------------------------------------------- LB,ENDDO
d1078 1
a1078 1
C          IF NUMBER IN LB## IS NOT THE SAME AS CURRENT DO-LOOP, IGNORE 
d1162 4
a1165 1
        IF (COPT .EQ. 'I' .AND. IDOTOP .EQ. 1) CLOSE(LUNDO)
d1410 1
a1410 1
      !write(6,*) ' Got symparid:',symparid(:nchari),':',nchari
@


1.356
log
@'OF' added op
@
text
@a54 3
C       NNAME : LENGTH OF PROCEDURE FILENAMES IN CHARACTERS
        INTEGER, PARAMETER :: NNAME=80 

d70 1
a70 1
C       WE USUALLY HAVE > 1 GB RAM AVAILABLE ON ALBANY MACHINES
d79 25
a103 24
	INTEGER   IDOSTK(7,MAXPRC),NARGSREC(MAXPRC),LOOPSV(8,MAXPRC)
	INTEGER   IARGSENT(NPARG,MAXPRC),IARGSREC(NPARG,MAXPRC)
	INTEGER   IFSV(MAXPRC)
        INTEGER   NUML(3)
        INTEGER   getpid

        LOGICAL :: USEELSE(MAXIF,MAXPRC)
	LOGICAL :: JUMP,EX,ISDIGI,ISCHAR,DELETIT,INTHELOOP,LISTIT
        LOGICAL :: RES_TO_TERM,GLOBAL

        CHARACTER *(NNAME)    PNAMEM,PNAME
        CHARACTER *(NNAME)    PROCFL(MAXPRCNAM)
        CHARACTER *(NNAME)    RESULT,LOG,SPIRE_FILE

        CHARACTER *160        MESG,PLINE,ARG4,ARGNOW,FCHARNOBLANK
	CHARACTER *40         CVERS
        CHARACTER *12         CDATT
        CHARACTER * 8         ZEIT
        CHARACTER * 7         RESULM
	CHARACTER * 5         LABEL 
	CHARACTER * 4         CXNUM,CREG
	CHARACTER * 3         LOGM
        CHARACTER * 2         NQ12
        CHARACTER * 1         NULL,RESPONSE
d105 1
a105 1
        CHARACTER (LEN=MAXNAM) :: OFFILE  ! FOR 'OF' OPERATIONS
d120 1
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  18.06 ISSUED: 11/18/2009'/ 
d192 1
a192 1
        NINSAVEOF = 0         ! FLAG FOR 'OF' OPERATIONS INPUT
d241 1
a241 1
           PROCFL(NUMPROCNOWT)(:NNAME) = ' '
d248 1
a248 1
        PROCFL(1)(:NNAME) = 'INTERACTIVE'
a490 2
          CASE ('OF')
             GOTO 10794
d516 2
d523 6
a528 1
        IF (ILEFPAR .GT. 0) THEN
d537 2
a538 2
C       FIND FIRST CHARACTER IN FILENAME
	NFSTRT = INDEX(FCHAR(1:NCHAR),'@@') + 1
d540 3
a542 3
C       SUBSTITUTE FOR ALL SYM. VAR.
        !write(6,*) ' Checking: ',FCHAR(NFSTRT:NCHAR)
        CALL SUBSYMPAR(FCHAR(NFSTRT:NCHAR),PNAMEM,NCT,0,IRTFLG)
d544 8
a551 29
C       WILL STOP IN FILNAMANDEXT ON ERRT
        CALL FILNAMANDEXT(PNAMEM(:NCT),PRJEXC,PNAME,NPNAME,.TRUE.,IER)

C       TRY TO FIND PROCEDURE IN USER'S DIRECTORY & PROJECT EXTENSION

        IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
#ifdef USE_MPI
        CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)
#endif

        IF (.NOT. EX) THEN
C         PROCEDURE FILE DOESN'T EXIST IN USER'S DIRECTORY
          IF (MYPID .LE. 0)  WRITE(NOUT,9045) PNAME 
9045      FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 

C         TRY AGAIN UNDER 'PROC:*.spi' IN PROC DIR.
C         7/10/88 PROC IS ENV. VAR. FOR DIR. WHERE *.spi FILES ARE al

          CALL MYGETENV('SPPROC_DIR',PNAME,NCHART,
     &                 'dir-for-proc-files',IER)
          IF (IER .NE. 0) CALL ERRT(101,'NO ENVIRONMENT VARIABLE',NE)
          NCHARTN = LNBLNKN(PNAMEM)
          PNAME   = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.spi'
          NPNAME  = NCHART + NCHARTN + 4

          IF (MYPID .LE. 0) INQUIRE(FILE=PNAME,EXIST=EX)
#ifdef USE_MPI
          CALL BCAST_MPI('SPIDER','EX',EX,1,'L',ICOMM)
#endif
d553 3
a555 7
          IF (.NOT. EX) THEN
C           THE *.spi FILE DOES NOT EXIST. NOTIFY USER
5800        MESG = 'PROCEDURE FILE.spi DOES NOT EXIST: '//PNAME(:NPNAME) 
            CALL ERRT(101,MESG,NE)
            GOTO 5000
          ENDIF
        ENDIF
d688 1
a688 1
           IF (PNAME .EQ. PROCFL(NUMPROCNOW)(:NNAME)) THEN
d709 1
a709 1
           PROCFL(NUMPROCNOW)(:NNAME) = PNAME
d867 6
a872 1
10000   IF (COPT .EQ. 'I') THEN
d924 1
a924 1
           PNAME(1:NNAME) = PROCFL(NUMPROCNOW)
a1345 10
C READ OPERATIONS FROM FILE --------------------------------------- OF
10794   CONTINUE
        LENREC    = 0
        CALL OPAUXFILE(.TRUE.,OFFILE,DATEXC,LUNTEXT,LENREC,
     &                 'O','VARIABLE ASSIGNMENT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        NINSAVEOF = NIN
        NIN       = LUNTEXT
        GOTO 5000
d1570 63
@


1.355
log
@CALL SUBSYMPAR(... to: SUBSTITUTE FOR ALL SYM. VAR
@
text
@d107 2
d122 1
a122 1
        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE
d142 1
d189 5
a193 4
        NSTDINP  = 5
        NIN      = NSTDINP
	NSTDOUTP = 6
	NOUT     = NSTDOUTP
d484 1
a484 1
C       HANDLE SHORT LOCAL OPS: 'EN','DO','LB','RE','MD'
d492 2
d1362 10
@


1.354
log
@equ_sympar changes
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.06 ISSUED: 11/11/2009'/ 
a526 1
C       PNAME IS TEMP NAME TO SEE WHERE PROCEDURE FILE EXISTS
a528 1
        PNAMEM = FCHAR(NFSTRT:NCHAR) 
d530 4
d535 1
a535 1
        CALL FILNAMANDEXT(PNAMEM,PRJEXC,PNAME,NPNAME,.TRUE.,IER)
@


1.353
log
@'cl hc' * bug fixed
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.05 ISSUED: 11/05/2009'/ 
d410 1
d413 7
a419 1
C             REGISTER ASSIGNMENTS SHOULD HAVE RETURNED IRTFLG = 2
d426 1
a426 1
     &      (.NOT. ISDIGI(FCHAR(1:1))))   .OR.
d1413 1
a1413 1
      LOGICAL             :: GLOBAL,LOCAL
d1439 9
d1459 1
a1459 1
         CEND    = LINE(IEND:IEND)
d1483 1
a1483 1
C              MAY BE A REGISTER ASSIGNMENT INSTEAD?
@


1.352
log
@@@^^[  bug fixed on operation line input
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.05 ISSUED: 11/02/2009'/ 
@


1.351
log
@mo 3 cyl. bug & BP 3F sui bug
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.04 ISSUED: 10/01/2009'/ 
@


1.350
log
@equ_sympar
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.03 ISSUED: 08/31/2009'/ 
@


1.349
log
@version=18.03
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.03 ISSUED: 08/28/2009'/ 
d410 1
a410 1
              CALL EQU_SYMPAR(FCHAR(1:NALPH),GLOBAL,IDUM,IRTFLG)
d1388 1
a1388 1
C    EQU_SYMPAR(LINE,GLOBAL,UNUSED,IRTFLG)
d1399 1
a1399 1
      SUBROUTINE EQU_SYMPAR(LINE,GLOBAL,UNUSED,IRTFLG)
d1405 2
a1406 3
      CHARACTER(LEN=1)    :: NULL,NQ1,NQ2,CIGO,CEND
      LOGICAL             :: GLOBAL,LOCAL,WANTSUB,SYMVAROK
      LOGICAL             :: GETANS,UPPER,SAYPRMT,SAYANS,ENDATSEMI,STRIP
d1415 1
d1417 1
a1417 5
      SYMPARID  = NULL
      SYMPARVAL = NULL
      SYMVAROK  = .FALSE.

C     LOCATE FIRST VARIABLE NAME IN LINE (SHOULD HAVE ALEADY BEEN TESTED)
d1421 2
a1422 1
         MSG = 'NO VARIABLE NAME ([NAME]) IN: ' // LINE
d1428 2
a1429 3
      SYMPARID = '<' // LINE(IP1:IP2) // '>' // NULL 
      !NCHARI   = (IP2) - (IP1) + 1 + 2
      NCHARI   =  IP2 - IP1 + 3
d1433 3
a1435 3
      NEQ    = 0      ! = SIGN COUNTER
      NCHARV = 0
      IFIRST = IP2 + 2
a1439 4
         !write(6,*) ' Returned token:',line(igo:iend),':'

         IFIRST = IEND + 1   ! NEXT START FOR TOKEN SEARCH

d1441 3
a1443 2
         CIGO = LINE(IGO:IGO)
         CEND = LINE(IEND:IEND)
d1446 1
a1446 1
C           THIS IS AN EQUAL SIGN             
d1456 1
a1456 1
C           THIS IS QUOTED TEXT STRING             
a1458 1
            SYMBAROK             = .TRUE.
d1462 1
a1462 1
C           THIS IS A [] VARIABLE, IS IT A SYM. STRING VARIABLE?
a1478 15

#ifdef NEVER
            GETANS    = .FALSE.
            UPPER     = .FALSE.
            WANTSUB   = .TRUE.
            SAYPRMT   = .FALSE.
            SAYANS    = .FALSE.
            ENDATSEMI = .TRUE.
            STRIP     = .TRUE.
            CALL RDPR(LINE(IGO:IEND),NCHARR,SYMPARVAL(NCHARV+1:), 
     &                 GETANS,UPPER,
     &                 WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLG)
            NCHARV = NCHARV + NCHARR
          !write(6,*)' Rdpr:',line(igo:iend),':',symparval(:ncharv),':'
#endif
@


1.348
log
@18.02
@
text
@d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.02 ISSUED: 08/19/2009'/ 
d1511 1
a1511 1
      write(6,*) ' Symparval:',symparval(:ncharv),':',ncharv
@


1.347
log
@noFR and big-endian capable
@
text
@d8 5
a12 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
c=* Health Research Incorporated (HRI),                                *   
c=* One University Place, Rensselaer, NY 12144-3455.                   *
C=* Email:  spider@@wadsworth.org                                       *
d14 1
a14 1
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d29 1
a29 1
C  DRIVER OF SPIDER IMAGE PROCESSING SYSTEM.                           *
d42 1
a42 1
C
d145 1
a145 1
        DATA CVERS/'VERSION:  UNIX  18.01 ISSUED: 07/31/2009'/ 
@


1.346
log
@symvar bug
@
text
@d9 3
a11 5
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  18.00 ISSUED: 06/26/2009'/ 
@


1.345
log
@added command line symvar setting
@
text
@d1476 1
d1485 1
a1485 1
            CALL SUBSYMPAR(LINE(IGO+1:IEND-1),SYMPARVAL(NCHARV+1:),
d1487 2
d1515 1
a1515 1
      !write(6,*) ' Symparval:',symparval(:ncharv),':',ncharv
@


1.344
log
@version 17.15
@
text
@d94 1
a94 1
        LOGICAL :: RES_TO_TERM
d108 1
d149 1
a149 1
        DATA CVERS/'VERSION:  UNIX  17.15 ISSUED: 06/22/2009'/ 
d209 1
d387 3
a389 1
5100    IF (NALPH  .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5000 
d402 18
a421 1

d435 1
a435 1
C       IF THE OPERATION STARTS WITH A [] REGISTER, EVALUATE EXPRESSION.
d492 1
a492 1
6800	CALL ARASQ(FCHAR,NALPH,IFLAG)
d673 2
a674 2
C             SET THE REGISTER
              CALL ARASQ(ARGNOW,NLETN,IFLAG)
d1357 3
a1359 2
C    SHRINK:  SUBROUTINE TO SHRINK STRING BY IGNORING ALL
C                 NON-PRINTING CHARACTERS
d1361 3
a1363 3
C    PARAMETERS:   INSTR      INPUT STRING TO BE SHRANK
C                  OUTSTR     OUPUT SHRUNKEN STRING
C                  LENOUT     LENGTH OF SHRUNKEN STRING
d1390 132
@


1.343
log
@version
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.14 ISSUED: 06/12/2009'/ 
@


1.342
log
@*** empty log message ***
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.13 ISSUED: 05/29/2009'/ 
@


1.341
log
@version_for_fi_h
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.13 ISSUED: 05/22/2009'/ 
@


1.340
log
@osx cc copyin/copyout
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.12 ISSUED: 04/28/2009'/ 
@


1.339
log
@fftw 3.2.1 used
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.11 ISSUED: 04/15/2009'/ 
@


1.338
log
@version 17.10, cpfrompe
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.10 ISSUED: 03/24/2009'/ 
@


1.337
log
@ version fixes fmrs -bug, arith osx bug
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.09 ISSUED: 03/06/2009'/ 
@


1.336
log
@normal stop msg & versioon inc
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.08 ISSUED: 02/09/2009'/ 
@


1.335
log
@cpfromccp4 big, bp3f xt bug
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.07 ISSUED: 12/22/2008'/ 
d960 1
a960 1
      STOP '**** SPIDER NORMAL STOP ****'
@


1.334
log
@16th fftw3 plan bug fixed, npix8 in ccp4
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.06 ISSUED: 12/19/2008'/ 
@


1.333
log
@17.05 fix: or leak
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.05 ISSUED: 12/08/2008'/ 
@


1.332
log
@random_seed bug on intel?
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.04 ISSUED: 12/05/2008'/ 
@


1.331
log
@ BCAST COM
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.03 ISSUED: 11/25/2008'/ 
d213 7
a219 1
        CALL RANDOM_SEED(PUT=ISEED)
@


1.330
log
@version 17.02 fixed repcg lununk
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.02 ISSUED: 11/15/2008'/ 
d160 2
a161 2
        LOGICAL            :: USEBCAST
        COMMON /COMM_MPI/USEBCAST
d165 3
a167 1
        USEBCAST = .TRUE.
@


1.329
log
@*** empty log message ***
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.01 ISSUED: 11/10/2008'/ 
@


1.328
log
@version-17
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  17.00 ISSUED: 11/04/2008'/ 
@


1.327
log
@goto 8900 irtflg bug
@
text
@d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  16.08 ISSUED: 10/30/2008'/ 
@


1.326
log
@usebcast
@
text
@d935 1
a935 1
8900  IF (MYPID .LE. 0)  WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
d938 1
d1289 2
a1290 2
     &               IFLEVEL,IRT)
        IF (IRTFLG .NE. 0) GOTO 8900 
@


1.325
log
@mpi changes
@
text
@d137 1
a137 1
        INTEGER, PARAMETER :: MAXNUMLAB = 50
d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  16.07 ISSUED: 10/17/2008'/ 
d160 2
d165 1
d171 1
a171 1
        IF (MYPID .EQ. 0) WRITE(6,*) ' NPROCS,ICOMM = ', NPROCS,ICOMM
@


1.324
log
@version
@
text
@d126 2
a127 1
	INTEGER, ALLOCATABLE, DIMENSION(:) :: ISEEDVAL
d148 1
a148 1
        DATA CVERS/'VERSION:  UNIX  16.06 ISSUED: 09/12/2008'/ 
d163 1
a163 1
        CALL MPI_INIT(IERR)
d165 2
a166 2
        CALL MPI_COMM_RANK(ICOMM, MYPID,  IERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, IERR)
d168 1
a168 1
        IF (mypid .EQ. 0) WRITE(6,*) ' NPROCS = ', NPROCS
d173 1
a173 1
        mypid = -1
d204 5
a208 10
C       SET ISEEDVAL TO INITIAL "RANDOM" VALUE USING CLOCK
	CALL RANDOM_SEED(SIZE=NUMBITS)
	ALLOCATE(ISEEDVAL(NUMBITS))
        CALL MYTIME(ZEIT)
	DO  I=1,NUMBITS	
	   ISEEDVAL(I)= ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &          I*(1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)))
	ENDDO
	CALL RANDOM_SEED(PUT=ISEEDVAL)
	DEALLOCATE(ISEEDVAL)
d254 7
a260 15
        IF (mypid .LE. 0) THEN
C          PRINT OUT HEADING WITH VERSION AND RELEASE DATES
#ifdef sgi
	   WRITE(NOUT,19090)
	   WRITE(NOUT, 9091)
           WRITE(NOUT, 9092)
	   WRITE(NOUT,19093)CVERS
	   WRITE(NOUT,19094)CDATT(1:11),CTIM
#else
	   WRITE(NOUT,9090)
	   WRITE(NOUT,9091)
           WRITE(NOUT,9092)
	   WRITE(NOUT,9093)CVERS
	   WRITE(NOUT,9094)CDATT(1:11),CTIM
#endif
d295 1
a295 1
        IF (mypid .LE. 0) THEN
d376 1
a376 1
5300	IF (NTRACE .GT. 0 .AND. mypid .LE. 0) THEN
d501 6
a506 1
	INQUIRE(FILE=PNAME,EXIST=EX)
d509 2
a510 4
          IF (mypid .LE. 0) THEN
             WRITE(NOUT,9045) PNAME 
9045         FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 
          ENDIF 
d513 1
a513 1
C         7/10/88 PROC IS LOGICAL FOR DIRECTORY WHERE *.spi FILES ARE al
d519 7
a525 2
          PNAME  = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.spi'
          NPNAME = NCHART + NCHARTN + 4
a526 1
          INQUIRE(FILE=PNAME,EXIST=EX)
d580 1
a580 1
          IF (mypid .LE. 0) THEN
d591 1
a591 1
        IF (mypid .LE. 0) THEN
d694 1
a694 1
           IF (VERBOSE .and. mypid .LE. 0) WRITE(NDAT,*) ' '
d704 1
a704 1
              IF (VERBOSE .and. mypid .LE. 0) 
d770 1
a770 1
           IF (VERBOSE .AND. mypid .LE. 0) WRITE(NDAT,*) ' '
d885 1
a885 1
	IF (mypid .LE. 0) THEN
d932 1
a932 1
8900  IF (mypid .LE. 0)  WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
d937 1
a937 1
      IF (mypid .LE. 0) CALL ENDIT(' COMPLETED',DELETIT,RESULT)
d1058 1
a1058 1
        IF (VERBOSE .and. mypid .LE. 0) THEN 
d1114 1
a1114 1
          IF (VERBOSE .AND. mypid .LE. 0) 
d1356 64
@


1.323
log
@FINDLBQ irtflg return
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.05 ISSUED: 08/08/2008'/ 
@


1.322
log
@*** empty log message ***
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.04 ISSUED: 06/30/2008'/ 
d1291 2
@


1.321
log
@ormq, ornq, or2, or2m renamed, wa bug, sd commont
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.03 ISSUED: 06/06/2008'/ 
@


1.320
log
@16.03 dsgr_p? bug fixed
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.02 ISSUED: 06/03/2008'/ 
@


1.319
log
@legacy () returned
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.01 ISSUED: 05/30/2008'/ 
@


1.318
log
@version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.00 ISSUED: 05/19/2008'/ 
d198 1
a198 1
        LEGACYPAR   = .FALSE. ! MAY 2008 () NOT REQUIRED IN LOOPS
@


1.317
log
@LEGACYPAR defalut false
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.15 ISSUED: 05/19/2008'/ 
@


1.316
log
@FMRS_DEPLAN call out of place
@
text
@d198 1
a198 1
        LEGACYPAR   = .TRUE.
@


1.315
log
@FFTW3 plan changes
@
text
@a434 3
C       TSWITCH IS MAIN SELECTION PROGRAM FOR OPERATIONS OUTSIDE MAIN
        CALL TSWITCH(IWHICH,ICOM,MAXDIM,IRTFLG)
          
d438 3
d442 2
a443 2
	IF (IRTFLG .EQ. 0) GOTO 5000

@


1.314
log
@back to 15.15
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.15 ISSUED: 04/09/2008'/ 
d437 4
@


1.313
log
@*** empty log message ***
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.01 ISSUED: 03/14/2008'/ 
@


1.312
log
@version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  16.00 ISSUED: 01/24/2008'/ 
@


1.311
log
@NUMFFTWTH
@
text
@d9 1
a9 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.13 ISSUED: 12/13/2007'/ 
@


1.310
log
@version=15.13
@
text
@d200 1
a200 1

@


1.309
log
@TH F added reg return
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.12 ISSUED: 10/09/2007'/ 
@


1.308
log
@speakc and piping altered
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.11 ISSUED: 09/21/2007'/ 
@


1.307
log
@IPARNUM(ISTOP)    = 0, ELSEIF (FCHAR .EQ. ELSEIF
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.10 ISSUED: 09/05/2007'/ 
@


1.306
log
@version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.09 ISSUED: 07/30/2007'/ 
d781 3
a783 3
        IPNUMSTACK(ISTOP)   = NUMPROCNOW

	NARGSREC(ISTOP)     = 0
d1193 11
d1207 1
a1207 1
C          THIS IS AN IF....THEN....ELSE OPERATION
@


1.305
log
@version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.08 ISSUED: 07/23/2007'/ 
@


1.304
log
@NDOLINE for interactive do loop
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.07 ISSUED: 05/25/2007'/ 
@


1.303
log
@version & mpi integers
@
text
@d123 1
a123 1
        COMMON /LUNDOECHO/ LUNDONOW
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.07 ISSUED: 05/24/2007'/ 
d164 1
a164 1
        CALL MPI_COMM_RANK(ICOMM, MYPID, IERR)
d549 1
a549 1
	LOOPSV(7,ISTOP) = LBNO      ! LABEL/IBCNT FOR END OF CURRENT LOOP
d573 1
a573 1
	IDOSTK(6,IDOTOP) = LBNO       ! LABEL/IBCNT FOR END OF CURRENT LOO
d974 1
d1044 1
a1044 1
C          MAKE NEG. LB# FOR PROCEDURE LINE
d1046 2
d1111 1
a1111 1
             CALL ERRT(101,'END-OF-FILE DURING DO-LOOP SEARCH',NE)
@


1.302
log
@15.06
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.06 ISSUED: 04/18/2007'/ 
a157 1
        INTEGER          :: COMM, RC
d163 3
a165 3
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, IERR)
d946 1
a946 1
      CALL MPI_FINALIZE(RC)
@


1.301
log
@10795   IF (IFLEVEL .GE. 1 for elseif
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.05 ISSUED: 03/27/2007'/ 
@


1.300
log
@new version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.04 ISSUED: 03/21/2007'/ 
d445 8
a452 8
        IF (FCHAR(1:2) .EQ. 'IF'       .OR.
     &      FCHAR(1:2) .EQ. 'GO'       .OR.
     &      FCHAR(1:6) .EQ. 'ELSEIF'   .OR.
     &      FCHAR(1:7) .EQ. 'ELSE IF') GOTO 10800
        IF (FCHAR(1:4) .EQ. 'ELSE')    GOTO 10798
        IF (FCHAR(1:5) .EQ. 'ENDIF')   GOTO 10799
        IF (FCHAR(1:5) .EQ. 'CYCLE')   GOTO 10796
        IF (FCHAR(1:4) .EQ. 'EXIT')    GOTO 10797
d1161 8
@


1.299
log
@bare DO
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.03 ISSUED: 02/27/2007'/ 
@


1.298
log
@*** empty log message ***
@
text
@d9 1
a9 1
C=* Copyright (C) 1985-2006  Health Research Inc.                      *
d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.02 ISSUED: 01/17/2007'/ 
d982 7
@


1.297
log
@version
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.01 ISSUED: 01/05/2007'/ 
@


1.296
log
@notes
@
text
@d147 1
a147 1
        DATA CVERS/'VERSION:  UNIX  15.00 ISSUED: 11/20/2006'/ 
@


1.295
log
@case used for local ops
@
text
@d4 2
a5 2
C SPIDER : (System for Processing Image Data in Electron microscopy    *
C           and Related fields)                                        *
d37 4
a41 3
C                   LUNDO      301         301             LUNDO FILE  *
C                   LUNSPIRE     2           2              SPIRE      *
C                   NLOGP        1           1                LOG      *
a42 3
C                   NSTDOUTP     6           6              STDOUT     *
C                   NDAT         3           3              RESULTS    *
C                   NLOG         1           0                         *
d45 6
a50 1
C                                                                      *
d74 1
a74 6
C       IF YOUR SYSTEM COMPLAINS ABOUT LACK OF SWAP SPACE WHEN YOU
C       TRY TO RUN SPIDER, YOU CAN INCREASE SYSTEM SWAP SPACE, 
C       KILL SOME UNNECESSARY PROCESSES THAT YOU ARE RUNNING,
C       OR DECREASE THE MEMORY NEEDED BY SPIDER.  
C
C       SPACE RESERVATION USED AT ALBANY, NOW REQUESTS ONLY 5 MB. 
@


1.294
log
@enddo, cycle, exit
@
text
@a58 3
C	NUMBER OF OPERATIONS IN LOCAL-SUBMENU
        INTEGER, PARAMETER :: NMENU1 = 8 

a109 1
        CHARACTER * 2         MENU1(NMENU1)
a150 2
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO','MD'/

d447 3
a449 2
        IF (FCHAR(1:2) .EQ. 'IF'     .OR.
     &      FCHAR(1:6) .EQ. 'ELSEIF' .OR.
d456 13
a468 6
	DO IFUNC = 1, NMENU1
          IF (FCHAR(1:2) .EQ. MENU1(IFUNC)(1:2)) THEN
C           OP:   EN,  DO,  LB,  RE,    GO   MD
            GOTO(8400,8600,8800,10000,10800,8500),IFUNC
          ENDIF
        ENDDO
@


1.293
log
@*** empty log message ***
@
text
@d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d38 1
a38 1
C                   LUNDO      301         301             LUNDOC FILE *
d110 2
a111 1
	CHARACTER * 4         LABEL,CXNUM,CREG
d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.20 ISSUED: 11/01/2006'/ 
d164 5
a170 6
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        INTEGER :: COMM, RC
#ifdef MPI_DEBUG
        DOUBLE PRECISION TT0, TT1   
#endif
d176 1
a176 1
        IF (mypid .eq. 0)   WRITE(6,*) ' NPROCS = ', NPROCS
d200 2
a201 2
        ILOOP       = 1
        NLOOP       = 0
d208 1
a208 3

C       SET SIZE OF COMMON BUFFER
        MAXDIM      = MAXDI
d233 1
a233 1
        LOOPREG     = 0
d437 3
d453 7
a459 6
        IF (FCHAR(1:6) .EQ. 'ELSEIF' .OR.FCHAR(1:7) .EQ. 'ELSE IF')THEN
           CALL ERRT(101,'THERE IS NO <ELSEIF> OPERATION IN SPIDER',NE)
           GOTO 5000
        ENDIF
        IF (FCHAR(1:4) .EQ. 'ELSE')  GOTO 10798
        IF (FCHAR(1:5) .EQ. 'ENDIF') GOTO 10799
d463 2
a464 2
C           OP:    EN, DO,  LB,  EX,  RE,   IF,   GO   MD
            GOTO(8400,8600,8800,8900,10000,10800,10800,8500),IFUNC
d545 7
a551 7
	LOOPSV(1,ISTOP) = ILOOP
	LOOPSV(2,ISTOP) = IABSLP
	LOOPSV(3,ISTOP) = LOOPREG
	LOOPSV(4,ISTOP) = NLOOP
	LOOPSV(6,ISTOP) = IDOTOP
	LOOPSV(7,ISTOP) = LBNO
	LOOPSV(8,ISTOP) = LOOPINC
d561 5
a565 5
        ILOOP   = 1
        IABSLP  = 0
        NLOOP   = 0
        LOOPREG = 0
        LOOPINC = 1
d568 8
a575 8
        IDOTOP           = IDOTOP + 1
	IDOSTK(1,IDOTOP) = ILOOP
	IDOSTK(2,IDOTOP) = IABSLP
	IDOSTK(3,IDOTOP) = LOOPREG
	IDOSTK(4,IDOTOP) = NLOOP
	IDOSTK(5,IDOTOP) = ISTOP
	IDOSTK(6,IDOTOP) = 0
	IDOSTK(7,IDOTOP) = LOOPINC
d641 1
a641 1
c           write(6,*) ' current argument: ',ARGNOW(1:NLETN)
d707 1
a707 1
     &             WRITE(NDAT,3960) NLINES, PLINE(:NCHAR)
d710 3
d714 1
a714 3
C                FIND MESG = PLINE WITHOUT WHITESPACE
                 CALL SHRINK(PLINE,MESG,NCHARM)

d743 1
a743 1
                 CALL GETLBNO(PLINE,LBNO,IRTFLG)
d747 1
a747 1
                       IF (LABGOT(I) .EQ. LBNO) THEN
d749 1
a749 1
                          CALL ERRT(102,'DUPLICATE LABEL',LBNO)
d754 1
a754 1
C	         WRITE(NOUT,*)' PUSHING LABEL: ',LBNO
d757 1
a757 1
                    LABGOT(NUMLABS) = LBNO
a778 1

d865 7
a871 7
	ILOOP            = LOOPSV(1,ISTOP)
	IABSLP           = LOOPSV(2,ISTOP)
	LOOPREG          = LOOPSV(3,ISTOP)
	NLOOP            = LOOPSV(4,ISTOP)
	IDOTOP           = LOOPSV(6,ISTOP)
	LBNO             = LOOPSV(7,ISTOP)
	LOOPINC          = LOOPSV(8,ISTOP)
d932 1
a932 1
C     END SPIDER. ---------------------------------------------- EX,EN
a949 1

d973 1
a981 3
C       GET ENDING LABEL NUMBER FOR THIS LOOP
        CALL GETLBNO(FCHAR,LBNO,IRTFLG)

d1008 2
d1025 1
a1025 1
	IDOTOP = IDOTOP + 1
d1034 7
d1042 7
a1048 7
	IDOSTK(1,IDOTOP) = ILOOP
	IDOSTK(2,IDOTOP) = IABSLP
	IDOSTK(3,IDOTOP) = LOOPREG
	IDOSTK(4,IDOTOP) = NLOOP
	IDOSTK(5,IDOTOP) = ISTOP
	IDOSTK(6,IDOTOP) = LBNO
	IDOSTK(7,IDOTOP) = LOOPINC
d1055 1
a1055 2

C END OF DO LOOP -------------------------------------------------- LB
d1061 2
a1062 1
8800    CALL GETLBNO(FCHAR,LBNO,IRTFLG)
d1064 6
a1069 3
C       IF NUMBER IN LB## IS NOT THE SAME AS CURRENT DO-LOOP, IGNORE 
C       THIS LABEL, GO BACK TO INPUT AND READ IN THE NEXT LINE.
        IF (LBNO .NE. IDOSTK(6,IDOTOP)) GOTO 5000
d1099 1
a1099 1
          CALL SEARCHQ(LBNO,IER)
d1116 1
a1116 1
        IDOTOP = IDOTOP - 1
d1122 7
a1128 6
        ILOOP       = IDOSTK(1,IDOTOP)
	IABSLP      = IDOSTK(2,IDOTOP)
	LOOPREG     = IDOSTK(3,IDOTOP)
	NLOOP       = IDOSTK(4,IDOTOP)
	LOOPINC     = IDOSTK(7,IDOTOP)

a1153 22
 
C LOGICAL ELSE -------------------------------------------------- ELSE
10798   CONTINUE
        IF (IFLEVEL .LE. 0) THEN
           CALL ERRT(101,' IN PROGRAM IFLEVEL <= 0',NE)
        ELSEIF (.NOT. USEELSE(ISTOP,IFLEVEL)) THEN
C          DO NOT NEED TO PROCESS THESE OPERATIONS, SKIP THEM
C          KEEP READING INPUT LINES TILL CORRESPONDING ENDIF FOUND
	   CALL FINDLBQ('ENDIF',0,0,INTHELOOP,IFLEVEL,IRTFLG)

        ELSE IF (USEELSE(ISTOP,IFLEVEL)) THEN
C          MUST USE THIS ELSE CLAUSE
           CONTINUE
        ENDIF
        GOTO 5000

C LOGICAL ENDIF ------------------------------------------------ ENDIF
10799   CONTINUE
        IFLEVEL = IFLEVEL - 1
        GOTO 5000
      

d1159 9
d1171 1
d1180 2
a1181 1
           IFLEVEL          = IFLEVEL + 1
d1217 1
a1217 1
           IDOTOP      = IDOTOP - 1
d1223 5
a1227 5
           ILOOP       = IDOSTK(1,IDOTOP)
	   IABSLP      = IDOSTK(2,IDOTOP)
	   LOOPREG     = IDOSTK(3,IDOTOP)
	   NLOOP       = IDOSTK(4,IDOTOP)
	   LOOPINC     = IDOSTK(7,IDOTOP)
d1242 48
@


1.292
log
@io units comments
@
text
@d91 1
a91 1
	INTEGER   IDOSTK(6,MAXPRC),NARGSREC(MAXPRC),LOOPSV(7,MAXPRC)
d94 1
a94 1
        INTEGER   NUML(2)
d152 1
a152 1
        DATA CVERS/'VERSION:  UNIX  14.19 ISSUED: 09/05/2006'/ 
d234 1
d256 2
d259 1
a259 1
        CALL SETSYMPAR(NULL,RESPONSE,.FALSE.,IRTFLG)
a399 2
           WRITE(NSTDOUTP,9020) FCHAR(1:NALPH)
9020       FORMAT(1X,A)
d549 1
d556 1
a556 1
        CALL SETSYMPAR(NULL,RESPONSE,.FALSE.,IRTFLG)
d563 1
d573 1
d869 1
d1003 1
a1003 1
        CALL CHKSTR(FCHAR(ILOCLIM:NLET),NC,'I',NUML,FDUM,2,NVAL,IRTFLG)
d1008 5
a1012 3
        IABSLP           = NUML(1)
        NLOOP            = NUML(2) - IABSLP + 1

d1040 1
d1067 1
a1067 1
	IABSLP = IABSLP + 1
d1115 1
d1226 1
@


1.291
log
@added debrakreg echo, & ia64 mrali_ss bug
@
text
@d36 11
a46 11
C  LUN ASSIGNMENTS: LUN  USUAL   SOURCE  IN PROC. SOURCE     SINK      *
C                   NLOGP    1                                         *
C                   NLOG     1   NLOGP       0                         *
C                   NDAT     3                             RESULT/TERM *
C                   NIN      5               5                         *
C                   NSTDINP  5                               INPUT     *
C                   NOUT     6               3     NDAT      OUTPUT    *
C                   NSTDOUTP 6                               OUTPUT    *
C                   NDOC     4                                         *
C                   LUNDO  301                                         *
C                   LUNSPIRE 2                                         *
d189 1
a189 1
C       NDAT IS FOR RESULTS FILE,  NDAT = 3 WHEN RESULTS FILE IS IN USE
@


1.290
log
@FCHARNOBLANK &version
@
text
@d152 1
a152 1
        DATA CVERS/'VERSION:  UNIX  14.18 ISSUED: 07/20/2006'/ 
@


1.289
log
@legacypar and version increase
@
text
@d105 1
a105 2
        CHARACTER *160        MESG,PLINE,ARG4,ARGNOW
        CHARACTER *80         COMMENTFUNC,FRPROMPT
d152 1
a152 1
        DATA CVERS/'VERSION:  UNIX  14.17 ISSUED: 06/27/2006'/ 
d972 1
a972 1
        COMMENTFUNC = FCHAR  
d1034 3
a1036 3
       IF (VERBOSE .and. mypid .LE. 0) 
     &     WRITE(NOUT, 8860) COMMENTFUNC,IABSLP

@


1.288
log
@initial register assignment x11
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.16 ISSUED: 03/30/2006'/ 
d208 1
@


1.287
log
@trace output bug
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.15 ISSUED: 03/24/2006'/ 
d625 8
a632 2
                 ARGNOW = '[' // ARG4(IGO:IGO+NTOEQ) // ']' //
     &                           ARG4(IGO+NTOEQ+1:IEND)                  
d635 1
a635 1
C             write(6,*) ' current argument: ',ARGNOW(1:NLETN)
@


1.286
log
@new version number
@
text
@d106 1
a106 1
        CHARACTER *80         COMMENTFUNC,FRPROMPT,CLINE
d400 3
a402 7
              IF (LOOPREG .LT. 103) THEN 
                 WRITE(NSTDOUTP,9040) LOOPREG,IABSLP
9040             FORMAT('  LOOP COUNTER (',I3,') = ',I8)
              ELSE
                 WRITE(NSTDOUTP,9041) CHAR(LOOPREG-103+100),IABSLP
9041             FORMAT('  LOOP INDEX (',A,') = ',I8)
              ENDIF
@


1.285
log
@new version number
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.14 ISSUED: 03/08/2006'/ 
@


1.284
log
@END OF: pname bug
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.13 ISSUED: 02/22/2006'/ 
@


1.283
log
@initial reg. handling bug
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.12 ISSUED: 02/15/2006'/ 
d249 2
a250 2
        IPNUMSTACK(ISTOP)          = NUMPROCNOW
        PROCFL(NUMPROCNOW)(:NNAME) = 'INTERACTIVE'
d890 1
a890 1
           PNAME(1:NNAME) = PROCFL(ISTOP)
@


1.282
log
@new version number
@
text
@d105 1
a105 1
        CHARACTER *160        MESG,PLINE,ARG4
d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.11 ISSUED: 02/13/2006'/ 
d602 35
a636 4
           DO NARG = 4,NUMARG
              CALL getarg(NARG,ARG4)
              NLET4 = lnblnk(ARG4)
              CALL ARASQ(ARG4,NLET4,IFLAG)
d639 1
a639 1
                 MESG = 'INVALID INITIAL REGISTERS: ' // ARG4(:NLET4)
d641 1
d643 1
@


1.281
log
@new version number
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.10 ISSUED: 02/07/2006'/ 
@


1.280
log
@new version number
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.09 ISSUED: 02/02/2006'/ 
@


1.279
log
@maxseln-nparg
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  14.08 ISSUED: 01/25/2006'/ 
@


1.278
log
@new version number
@
text
@a73 3
C	MAXIMUM NUMBER OF REGISTER ARGUMENTS SENT TO A PROCEDURE
        INTEGER, PARAMETER :: MAXNSEL = 24    ! FOR REGISTER LIST 

@


1.277
log
@new version number
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.07 ISSUED: 01/23/2006'/ 
@


1.276
log
@new version number
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.06 ISSUED: 01/12/2006'/ 
@


1.275
log
@test for loopreg .eq. 0
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.05 ISSUED: 01/11/2006'/ 
@


1.274
log
@NT getpid
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.04 ISSUED: 01/04/2006'/ 
d1188 3
a1190 1
           CALL REG_SET_BYNUM(LOOPREG,REAL(IABSLP),IRTFLG)
@


1.273
log
@moved initial reg set from initunix
@
text
@d356 3
d363 1
a363 1

@


1.272
log
@new version number
@
text
@d108 1
a108 1
        CHARACTER *160        MESG,PLINE
d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.03 ISSUED: 12/30/2005'/ 
a388 1
        NUMARG  = 0
d600 15
@


1.271
log
@version for long fchar
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.02 ISSUED: 12/21/2005'/ 
@


1.270
log
@new version number
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.01 ISSUED: 12/19/2005'/ 
@


1.269
log
@added if (mypid .le. 0) to synchronize write to standard out
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.00 ISSUED: 12/10/2005'/ 
@


1.268
log
@native named registers
@
text
@d670 1
a670 1
                       WRITE(NOUT,*) 
@


1.267
log
@no getpid in windows
@
text
@d56 2
a57 6
C       NNAME     LENGTH OF PROCEDURE FILENAMES IN CHARACTERS
        PARAMETER (NNAME=80)

C	DEFAULT NUMBER OF ACCESSIBLE REGISTERS (23 ADDITIONAL REGISTERS
C       ARE ALLOCATED FOR OLD-STYLE DO-LOOP INDICES)
	PARAMETER (NDEFNUMREGS = 103) 
d60 1
a60 1
	PARAMETER (NMENU1 = 8) 
d63 1
a63 1
	PARAMETER (MAXREG=7)    
d69 1
a69 1
	PARAMETER (NPARG=24)     
d72 4
a75 1
	PARAMETER (MAXIF=20)     
a93 2
	REAL      ARGSAV(NPARG)

d114 1
a114 1
	CHARACTER * 4         LABEL,CXNUM
d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  14.00 ISSUED: 11/15/2005'/ 
d255 2
a256 5
C       INITIALIZE DEFAULT NUMBER (MAXPARAM) OF REGISTERS
        CALL REG_BUILD(NDEFNUMREGS,IRTFLG)

C       SET ERROR FLAG TO NONE IN REGISTERS
        CALL REG_SET(9,0.0,.TRUE.,IRTFLG)
a257 3
C       INITIALIZE REGISTER INFO FOR GLOBAL REGISTERS
        CALL REG_SET_BANK(1,IRTFLG)

a355 1
#ifndef SP_NT
d360 1
a360 1
#endif
d388 1
a388 1
C       GET THE NEXT OPERATION
d392 1
a392 3
C       -999 DOES NOT CONVERT INPUT TO UPPERCASE
        IRTFLG = -999
        CALL RDPRMC(FCHAR,NALPH,.TRUE.,'OPERATION',NULL,IRTFLG)
d430 2
a431 4
C       IF THE OPERATION STARTS WITH A REGISTER, EVALUATE EXPRESSION.
C         (RECOGNIZED BY 'X<DIGIT>')
        IF ((FCHAR(1:1) .EQ. 'X' .OR. FCHAR(1:1) .EQ. 'x') .AND.
     &      (ISDIGI(FCHAR(2:2)))) GOTO 6800
d439 1
a439 1
        CALL SSUPCAS(FCHAR)
d442 1
a442 2
	IF ((FCHAR(1:2) .EQ. 'LB' .OR. (FCHAR(1:2) .EQ. 'lb')) .AND. 
     &       NLOOP .GE. 1) GOTO 8800
d445 1
a445 2
	IF ((FCHAR(1:2) .EQ. 'LB' .OR. (FCHAR(1:2) .EQ. 'lb')) .AND. 
     &       NLOOP .LE. 0) GOTO 5000
d449 2
a450 4
	IF (IRTFLG .EQ. 0) THEN
C          OPERATION FOUND OUTSIDE OF SPIDER MAIN, GET NEXT OPERATION
           GOTO 5000
        ENDIF
d470 2
a471 3
C       ANY REMAINING OPERATION IS ASSUMED TO BE ARITHMETIC EXPRESSION
6800	CALL SSUPCAS(FCHAR)
        CALL ARASQ(FCHAR,NALPH,IFLAG)
d481 1
a481 1
	STOP '**** SHOULD NEVER GET HERE FATAL ERROR'
d492 10
a501 3
C       REGISTER LIST SAVED IN IARGSENT
        NCHAR = NALPH
        CALL FROMTOQ(FCHAR,NCHAR,IARGSENT(1,ISTOP+1),NARGREG,NPARG)
d505 2
a506 3
	NFSTRT = 1
	IF (FCHAR(:1) .EQ. '@@') NFSTRT = 2
        PNAMEM = FCHAR(NFSTRT:NCHAR) // NULL
a545 3
C       SAVE THE REGISTERS FROM CALLING PROCEDURE
        CALL REG_SET_BANK(ISTOP,IRTFLG)

d598 2
a599 2
C       RESET ERROR FLAGS FOR PROCEDURE RUNS ONLY, SET THE LUNS
	CALL REG_SET(9,0.0,.TRUE.,IRTFLG)
d662 1
a662 1
C                   CHECK FOR OLD STYLE REGISTER ARGUMENTS []
d667 1
a667 1
C                      MODERNIZE OLD STYLE REGISTER ARGUMENTS 
d740 15
a754 10
C          SUBSTITUTE FOR ANY ARGUMENT TRANSFER
           CALL RDPR(PLINE,NCHAR,PLINE,
     &          .FALSE.,.FALSE.,.TRUE.,.FALSE.,.FALSE.,.TRUE., IRTFLG)

           IF ((PLINE(2:2) .EQ. 'X' .OR. PLINE(2:2) .EQ. 'x') .AND.
     &         ISDIGI(PLINE(3:3)) .AND. NUMARG .LE. 0) THEN

C            REGISTER TRANSFER
	     CALL FROMTOQ(PLINE,NUMCHR,IARGSREC(1,ISTOP),NARGREG1,NPARG)
	     IF (NARGREG .NE. NARGREG1) THEN
d764 3
a766 5
C            UPDATE THIS PROCEDURES REGISTERS FROM CALLER'S REGISTERS
  	     DO I = 1, NARGREG
               CALL REG_GET_BANKED(ISTOP,IARGSENT(I,ISTOP),RVAL,IRTFLG)
                CALL REG_SET(IARGSREC(I,ISTOP),RVAL,.TRUE.,IRTFLG)
             ENDDO
d793 1
a793 1
           CALL ERRT(13,'SPIDER',NE)
d804 3
a806 16
C           SAVE REGISTER VALUES SPECIFIED IN RECEIVED ARGUMENT LIST
	    DO I=1,NARGSREC(ISTOP)
C              ARGSAV(I) = PARAM(IARGSREC(I,ISTOP))
               CALL REG_GET(IARGSREC(I,ISTOP),ARGSAV(I),.TRUE.,IRTFLG)
            ENDDO
	ENDIF

C       RECOVER ORIGINAL SET OF REGISTERS FROM LOWER PROCEDURE LEVEL
        CALL REG_GET_BANK(ISTOP,IRTFLG)

C       NOW OVERWRITE ORIGINAL REGISTERS PASSED ON TO PROCEDURE
	IF (NARGSREC(ISTOP) .GT. 0) THEN
	   DO I=1,NARGSREC(ISTOP)
C             PARAM(IARGSENT(I,ISTOP)) = ARGSAV(I)
              CALL REG_SET(IARGSENT(I,ISTOP),ARGSAV(I),.TRUE.,IRTFLG)
           ENDDO
d827 2
a828 1
        CALL REG_SET(LOOPREG,REAL(IABSLP),.TRUE.,IRTFLG)
d883 1
a883 1
      IF (mypid .LE. 0) CALL ENDIT('COMPLETED',DELETIT,RESULT)
d913 1
a913 1
              CALL ERRT(101,'UNABLE TO OPEN SCRATCH DO-LOOP FILE',NE)
d931 3
a933 3
C          NEW STYLE LOOP INDEX (X11...), GET REGISTER NUMBER FROM TOKEN
           CALL REGPARSE(FCHAR(1:ILOCLIM-2),LOOPREG,
     &                   IGOR,IENDR,.TRUE.,IERR)
d940 4
a943 3
C          CONVERT DO LOOP VARIABLE TO AN INTEGER (E.G. A --> 104)
           CALL INDEXTOREG(FCHAR(ILOCLIM-2:ILOCLIM-2),.FALSE.,
     &                     LOOPREG,IDUM)
a950 1
C          ERROR
d956 10
a965 3
        CALL REG_SET(LOOPREG,REAL(IABSLP),.TRUE.,IRTFLG)
C       PUT IABSLP IN REGISTER X0 ALSO
        CALL REG_SET(0,REAL(IABSLP),.TRUE.,IRTFLG)
d1013 3
a1015 1
        CALL REG_SET(0,REAL(IABSLP),.TRUE.,IRTFLG)
d1023 2
a1024 1
          CALL REG_SET(LOOPREG,REAL(IABSLP),.TRUE.,IRTFLG)
d1060 4
a1063 2
        CALL REG_SET(0,REAL(IABSLP),.TRUE.,IRTFLG)
        CALL REG_SET(LOOPREG,REAL(IABSLP),.TRUE.,IRTFLG)
d1170 2
a1171 2
           CALL REG_SET(0,REAL(IABSLP),.TRUE.,IRTFLG)
           CALL REG_SET(LOOPREG,REAL(IABSLP),.TRUE.,IRTFLG)
@


1.266
log
@named register support
@
text
@d365 1
d370 1
a370 1

@


1.265
log
@version 13 for GPL
@
text
@d140 1
a140 1
C       FOR LOCAL SYMBOLIC PARAMETER HANDLING 
d159 1
a159 2
        DATA CVERS/'VERSION:  UNIX  13.00 ISSUED: 10/19/2005'/ 

d264 4
a267 1
C       INITIALIZE SYMBOLIC PARAMETER INFO FOR INITIAL PROCEDURE = 1
d400 1
d570 2
a571 2
        IFSV(ISTOP)    = IFLEVEL
        IFLEVEL        = 0
d573 1
a573 1
C       INITIALIZE SYMBOLIC PARAMETER INFO FOR NEW PROCEDURE
a590 1

d652 3
a654 3
           NLINES  = 0
           NCHARS  = 1
           NUMLABS = 0
d670 27
d698 3
a700 3
              IF ((PLINE(1:1) .EQ. 'L' .or. PLINE(1:1) .EQ. 'l') .AND.
     &            (PLINE(2:2) .EQ. 'B' .or. PLINE(2:2) .EQ. 'b') .AND.
     &            ISDIGI(PLINE(3:3)) ) THEN
d722 1
a722 1
              ENDIF ! END OF: IF ((PLINE(1:1) .EQ. 'L' ......
d754 25
a778 4
	IF ((PLINE(:1) .EQ. '[' .OR. PLINE(:1) .EQ. '(') .AND. 
     &     (PLINE(2:2) .EQ. 'X' .OR. PLINE(2:2) .EQ. 'x') .AND.
     &      ISDIGI(PLINE(3:3)) .AND. NUMARG .LE. 0) THEN
          PLINE(2:2) = 'X'
d780 1
a780 2
	  CALL FROMTOQ(PLINE,NUMCHR,IARGSREC(1,ISTOP),NARGREG1,NPARG)
	  IF (NARGREG .NE. NARGREG1) THEN
d783 1
a783 1
     &                     ' <> ARGUMENTS IN PROCEDURE:',NARGREG1
d786 1
a786 10
	  ENDIF
C         STORE NUMBER OF CURRENT REGISTERS SENT TO THIS PROC.
          NARGSREC(ISTOP) = NARGREG1

C         UPDATE THIS PROCEDURES REGISTERS FROM CALLER'S REGISTERS
  	  DO I = 1, NARGREG
C            PARAM(IARGSREC(I,ISTOP)) = PRAMSV(ISTOP,IARGSENT(I,ISTOP))
             CALL REG_GET_BANKED(ISTOP,IARGSENT(I,ISTOP),RVAL,IRTFLG)
             CALL REG_SET(IARGSREC(I,ISTOP),RVAL,.TRUE.,IRTFLG)
          ENDDO
d788 1
a788 1
        ELSEIF ((PLINE(:1) .NE. '[' .AND. PLINE(:1) .NE. '(')) THEN
d792 1
a792 8

        ELSEIF (PLINE(:1) .EQ. '[' .OR. PLINE(:1) .EQ. '(') THEN
	     WRITE(NOUT,*) 
     &       '*** REGISTER ARGUMENTS SENT TO PROCEDURE:',NARGREG,
     &       ' BUT NO REGISTER ARGUMENTS IN PROCEDURE'
	     CALL ERRT(102, 
     &          'WRONG NUMBER OF REGISTERS SENT TO PROCEDURE',NARGREG)
	ENDIF
d1195 34
@


1.264
log
@new version number
@
text
@d4 2
a5 2
C SPIDER : (System for Processing Image Data in Electron microscopy 
C           and Related fields)                                              *
d159 1
a159 1
        DATA CVERS/'VERSION:  UNIX  12.06 ISSUED: 10/19/2005'/ 
@


1.263
log
@GPL License fixed
@
text
@d159 1
a159 1
        DATA CVERS/'VERSION:  UNIX  12.05 ISSUED: 09/26/2005'/ 
@


1.262
log
@HRI GPL License used
@
text
@a7 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 6

C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.261
log
@new version number
@
text
@d9 24
@


1.260
log
@new version number
@
text
@d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  12.04 ISSUED: 09/12/2005'/ 
@


1.259
log
@added pid to spire output
@
text
@d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  12.03 ISSUED: 09/09/2005'/ 
@


1.258
log
@new version number
@
text
@d69 1
a69 1
C       WE USUALLY HAVE > 128 MB RAM AVAILABLE ON ALBANY MACHINES
d84 1
d346 5
@


1.257
log
@UNIX  12.02
@
text
@d141 1
a141 1
        DATA CVERS/'VERSION:  UNIX  12.02 ISSUED: 08/16/2005'/ 
@


1.256
log
@ lundocredalli overflow bug fixed
@
text
@d4 2
a5 2
C SPIDER : 
C (System for Processing Image Data in Electron microscopy and Related fields)                                              *
d141 1
a141 1
        DATA CVERS/'VERSION:  UNIX  12.01 ISSUED: 07/22/2005'/ 
@


1.255
log
@spireout version
@
text
@d4 2
a5 1
C SPIDER : (System for Processing Image Data in Electron microscopy and Related fields)                                              *
d9 1
a9 1
C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
d141 1
a141 1
        DATA CVERS/'VERSION:  UNIX  12.00 ISSUED: 06/27/2005'/ 
@


1.254
log
@*** empty log message ***
@
text
@d4 1
a4 1
C MAIN SPIDER ROUTINE                                                  *
a254 1
        NUMARG = 0
@


1.253
log
@VERSION:
@
text
@a18 2
C                   NSTDINP  5                               INPUT     *
C                   NSTDOUTP 6                               OUTPUT    *
d20 2
d23 1
d25 2
a26 2
C                   NDAT     3                             RESULT/TERM *
C                   NLOG     1   NLOGP       0                         *
d28 1
a28 1
C                   NDOC     4                                         *
d70 1
a70 2
        PARAMETER (MAXDI = 5000000)

d90 1
a90 1
        CHARACTER *(NNAME)    RESULT,LOG
d132 5
d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  11.12 ISSUED: 04/12/2005'/ 
a141 1
C       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DATA STATEMENTS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
a148 3
C       LOGICAL UNIT NUMBERS DEFINED HERE
        DATA LUNDO/300/

d253 5
d260 1
a260 1
#ifdef SGI
d262 2
a263 2
	   WRITE(NOUT,19091)
           WRITE(NOUT,19092)
d274 3
a276 9
9090    FORMAT(/,' \\__`O O''__/        SPIDER  --  COPYRIGHT 1993')
9091    FORMAT(' ,__xXXXx___        HEALTH RESEARCH INC., ALBANY, NY.') 
9092    FORMAT('  __xXXXx__')
9093    FORMAT(' /  /xxx\\  \\        ',A)
9094    FORMAT('   /     \\          DATE:     ',A,'    AT  ',A,//)

19090   FORMAT(/,' \__`O O''__/        SPIDER  --  COPYRIGHT 1993')
19091   FORMAT(' ,__xXXXx___        HEALTH RESEARCH INC., ALBANY, NY.') 
19092   FORMAT('  __xXXXx__')
d280 4
a285 4
        NUMARG = 0
C       GET DATEXC, RESULTS FILE VERSION, FIRST OP & REGISTER SETTING
        CALL INITUNIX(NUMARG,FCHAR,NALPH,CXNUM)

d288 1
a288 1
           FCHAR(1:3) = 'NC'// CHAR(0)
d329 3
a331 1
C          FLUSH RESULTS FILE TO ENSURE THAT IT iS CREATED NOW
d333 15
d388 1
a388 1
9040             FORMAT(1X,' LOOP COUNTER (',I3,') = ',I8)
d391 1
a391 1
9041             FORMAT(1X,' LOOP INDEX (',A,') = ',I8)
d839 1
a839 1
C     SET OPTIONS ---------------------------------------------- MD
d850 3
a852 1
      IF (mypid .LE. 0)  CALL ENDIT('COMPLETED',DELETIT,RESULT)
d857 1
a857 1
8405  FORMAT(1X,'TOTAL TIME = ', 1PE11.3)  
d861 2
@


1.252
log
@Added MPI_Wtime to time the entire MPI run
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.11 ISSUED: 12/09/2004'/ 
@


1.251
log
@argument transfer without x error
@
text
@d156 3
a158 1

d165 1
d835 5
@


1.250
log
@*** empty log message ***
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.10 ISSUED: 11/19/2004'/ 
d705 1
a705 1
        ELSE IF ((PLINE(:1) .NE. '[' .AND. PLINE(:1) .NE. '(')) THEN
d709 7
@


1.249
log
@version
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.9  ISSUED: 10/20/2004'/ 
@


1.248
log
@version incremented (many  mpi changes)
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.8  ISSUED:  9/30/2004'/ 
@


1.247
log
@WRITE(NOUT,*)' PUSHING LABEL: ',LBNO comment out
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.7  ISSUED:  9/20/2004'/ 
@


1.246
log
@version
@
text
@d641 1
a641 1
	            WRITE(NOUT,*)' PUSHING LABEL: ',LBNO
@


1.245
log
@error if duplicate labels encountered in batch
@
text
@d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.6  ISSUED:  9/15/2004'/ 
@


1.244
log
@version
@
text
@d15 2
a16 3
C  DRIVER OF SPIDER IMAGE PROCESSING SYSTEM.   J. FRANK                *
C  PLEASE UPDATE VERSION STATEMENT (MARKED BY CHERE) EVERY TIME        *
C  THE VERSION IS CHANGED!                                             *
a26 1
C                   LUNPIP 302                                         *
d113 1
a113 1
        PARAMETER        (NCOMSIZ = 8000)
d128 4
d135 1
a135 1
        DATA CVERS/'VERSION:  UNIX  11.5  ISSUED:  8/18/2004'/ 
d607 3
a609 2
           NLINES = 0
           NCHARS = 1
d624 27
@


1.243
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.4  ISSUED:  8/05/2004'/ 
@


1.242
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.4  ISSUED:  7/28/2004'/ 
@


1.241
log
@version 11.3
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.3  ISSUED:  7/14/2004'/ 
@


1.240
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.2  ISSUED:  6/12/2004'/ 
@


1.239
log
@loop counter I8, version incremented
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.1  ISSUED:  4/06/2004'/ 
@


1.238
log
@11.0 (new doc file format)
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  11.0  ISSUED:  2/02/2004'/ 
d366 1
a366 1
9040             FORMAT(1X,' LOOP COUNTER (',I3,') = ',I5)
d369 1
a369 1
9041             FORMAT(1X,' LOOP INDEX (',A,') = ',I5)
d932 1
a932 1
8860      FORMAT(5X,A20,'    / ',I5)
@


1.237
log
@version 10.2
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  10.2  ISSUED:  1/14/2004'/ 
@


1.236
log
@'MD' moved to spider.f
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  10.1  ISSUED: 12/03/2003'/ 
@


1.235
log
@LE --> mypid
@
text
@d19 8
a26 8
C  LUN ASSIGNMENTS: LUN  USUAL   SOURCE  IN PROCEDURE SOURCE  SINK     *
C                   NIN      5                  5                      *
C                   NDISK    1                                         *
C                   NOUT     6                  3     NDAT   OUTPUT    *
C                   NDAT     3                               RESULT    *
C                   ITIN     5                               INPUT     *
C                   ITI      6                               OUTPUT    *
C                   NLOG     1   NDISK          0                      *
d47 1
a47 1
	PARAMETER (NMENU1 = 7) 
d86 3
a88 2
        LOGICAL   USEELSE(MAXIF,MAXPRC)
	LOGICAL   JUMP,EX,ISDIGI,ISCHAR,DELETIT,INTHELOOP,LISTIT
d125 1
a125 1
        COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  10.0  ISSUED: 11/24/2003'/ 
d137 1
a137 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO'/
d141 1
d168 11
a178 8
C       NDISK IS FOR LOG FILE,  NLOG = NDISK WHEN LOG IS IN USE
        NDISK = 1  
	NLOG  = NDISK
        NDAT  = 3
        ITIN  = 5
        NIN   = ITIN
	ITI   = 6
	NOUT  = ITI
d361 1
a361 1
           WRITE(ITI,9020) FCHAR(1:NALPH)
d365 1
a365 1
                 WRITE(ITI,9040) LOOPREG,IABSLP
d368 1
a368 1
                 WRITE(ITI,9041) CHAR(LOOPREG-103+100),IABSLP
d434 2
a435 2
C           OP:    EN,   DO,   LB,   EX,    RE,    IF,    GO
            GOTO(8400, 8600, 8800, 8900, 10000, 10800, 10800),IFUNC
d767 2
a768 2
        NOUT  = 6
	NLOG  = NDISK
d780 5
@


1.234
log
@NLOG & version increment
@
text
@d647 1
a647 1
	IF ((PLINE(:1) .EQ. '[' .OR. PLINE(:1) .eq. '(') .AND. 
d870 1
a870 1
       IF (VERBOSE .and. LE .eq. 0) 
@


1.233
log
@mypid wrong on entry msg.
@
text
@d124 2
a125 2
        COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,NLOG,IPSTACK,
     &                     IPNUMSTACK,IPARNUM
d132 1
a132 1
        DATA CVERS/'VERSION:  UNIX  9.13  ISSUED: 9/16/2003'/ 
@


1.232
log
@mpi bug
@
text
@d132 1
a132 1
        DATA CVERS/'VERSION:  UNIX  9.12  ISSUED: 9/08/2003'/ 
d242 1
a242 1
        IF (mypid .EQ. 0) THEN
@


1.231
log
@mpi
@
text
@d150 2
a151 2
        include        'mpif.h'
        integer        ierr, comm, mypid, nprocs, rc
d154 3
a156 3
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid, ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
d158 1
a158 1
        if (mypid .eq. 0)   write(6,*) ' nprocs = ', nprocs
d784 3
a786 1
      IF (mypid .EQ. 0) CALL MPI_FINALIZE(RC)
@


1.230
log
@double results name removed
@
text
@d132 1
a132 1
        DATA CVERS/'VERSION:  UNIX  9.11  ISSUED: 9/04/2003'/ 
d158 1
a158 3
        if (mypid .eq. 0) then
           write(6,*) ' nprocs = ', nprocs
        end if
d160 3
d242 2
a243 4
#ifdef USE_MPI
        if (mypid .eq. 0) then
#endif
C       PRINT OUT HEADING WITH VERSION AND RELEASE DATES
d245 5
a249 5
	WRITE(NOUT,19090)
	WRITE(NOUT,19091)
        WRITE(NOUT,19092)
	WRITE(NOUT,19093)CVERS
	WRITE(NOUT,19094)CDATT(1:11),CTIM
d251 5
a255 5
	WRITE(NOUT,9090)
	WRITE(NOUT,9091)
        WRITE(NOUT,9092)
	WRITE(NOUT,9093)CVERS
	WRITE(NOUT,9094)CDATT(1:11),CTIM
d270 1
a270 3
#ifdef USE_MPI
        endif
#endif
d297 1
a297 2
#ifdef USE_MPI
        if (mypid .eq. 0) then
a298 4
        endif
#else
        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,CXNUM)
#endif
d300 8
a307 11
#ifdef USE_MPI
        if (mypid .eq. 0) then
#endif
        INQUIRE(FILE=RESULT,EXIST=EX)
        IF (EX) THEN
           OPEN(NDAT,FILE=RESULT,STATUS='OLD',POSITION='APPEND',
     &          IOSTAT=IER)
        ELSE
           OPEN(NDAT,FILE=RESULT,STATUS='REPLACE',IOSTAT=IER)
        ENDIF
	IF (IER .NE. 0) STOP '*** UNABLE TO OPEN RESULTS FILE ***'
d309 6
a314 12
C       PRINT OUT HEADING WITH VERSION AND RELEASE DATES
	WRITE(NDAT,9090)
	WRITE(NDAT,9091)
        WRITE(NDAT,9092)
	WRITE(NDAT,9093)CVERS
	WRITE(NDAT,9094)CDATT(1:11),CTIM

	WRITE(NDAT,9096) PRJEXC(1:3),DATEXC(1:3)
9096	FORMAT(/' PROJECT EXTENSION: ',A3,'   DATA EXTENSION: ',A3,/)
#ifdef USE_MPI
        endif
#endif
d316 2
d319 1
a319 3
C       FLUSH RESULTS FILE TO ENSURE THAT IT EXISTS NOW
#ifdef USE_MPI
        if (mypid .eq. 0) then
d321 1
a321 4
        endif
#else
        CALL FLUSHRESULTS
#endif
d355 1
a355 4
5300	IF (NTRACE .GT. 0) THEN
#ifdef USE_MPI
           if (mypid .eq. 0) then
#endif
a366 3
#ifdef USE_MPI
           endif
#endif
d474 1
a474 2
#ifdef USE_MPI
          if (mypid .eq. 0) then
d476 2
a477 5
          endif 
#else
          WRITE(NOUT,9045) PNAME 
#endif
9045      FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 
d544 6
a549 10
#ifdef USE_MPI
          if (mypid .eq. 0) then
#endif
          WRITE(NDAT, 6320)
6320	  FORMAT(/,' .OPERATION:')
          WRITE(NDAT, 6340) FCHAR(1:80)
6340      FORMAT(5X,A)
#ifdef USE_MPI
          endif
#endif
d555 1
a555 2
#ifdef USE_MPI
        if (mypid .eq. 0) then
d558 2
a559 6
        endif 
#else
	IF (VERBOSE) WRITE(NDAT, *) ' '
	WRITE(NDAT, 6380) PNAME(1:NPNAME)
#endif
6380	FORMAT('  -- START OF: ',A,'    --')
d602 3
a604 5
#ifdef USE_MPI
           IF (VERBOSE .and. mypid .eq. 0) WRITE(NDAT,*) ' '
#else 
           IF (VERBOSE) WRITE(NDAT,*) ' '
#endif
d612 2
a613 5
#ifdef USE_MPI
              IF (VERBOSE .and. mypid .eq. 0) 
     &             WRITE(NDAT,3960) NLINES, PLINE(:NCHAR)
#else
              IF (VERBOSE) 
a614 1
#endif
d623 3
a625 5
#ifdef USE_MPI
           IF (VERBOSE .and. mypid .eq. 0) WRITE(NDAT,*) ' '
#else
           IF (VERBOSE) WRITE(NDAT,*) ' '
#endif
d737 6
a742 4
	IF (VERBOSE) WRITE(NDAT,*) ' '
	WRITE(NDAT,10080) PNAME(1:NPNAME)
10080	FORMAT('  -- END OF: ',A,'  --')
	IF (VERBOSE) WRITE(NDAT,*) ' '
d779 2
a780 8
#ifdef USE_MPI
8900  continue
      if (mypid .eq. 0) then
         WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
      endif
#else    
8900  WRITE(NOUT,*) '*** GOOD BYE, SELAMAT JALAN'
#endif
d783 2
a784 8
#ifdef USE_MPI
      if (mypid .eq. 0) then
         CALL ENDIT('COMPLETED',DELETIT,RESULT)
      endif
      call MPI_FINALIZE(RC)
#else
      CALL ENDIT('COMPLETED',DELETIT,RESULT)
#endif
d868 1
a868 2
#ifdef USE_MPI
        IF (VERBOSE .and. mypid .eq. 0) 
a869 3
#else
        IF (VERBOSE) WRITE(NOUT, 8860) COMMENTFUNC,IABSLP
#endif
d918 1
a918 2
#ifdef USE_MPI
          IF (VERBOSE .and. mypid .eq. 0) 
a919 3
#else
          IF (VERBOSE) WRITE(NOUT, 8860) FCHAR(1:20),IABSLP
#endif
@


1.229
log
@useelse stack added
@
text
@a310 2

        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,CXNUM)
@


1.228
log
@yang's changes for mpi
@
text
@d58 3
d86 1
a86 1
        LOGICAL   USEELSE(MAXPRC)
d1034 1
a1034 2
        ENDIF
        IF (.NOT. USEELSE(IFLEVEL)) THEN
d1039 1
a1039 1
        ELSE IF (USEELSE(IFLEVEL)) THEN
d1077 1
a1077 1
           USEELSE(IFLEVEL) = JUMP
@


1.227
log
@if then els  stack overflow bug fixed (old bug??)
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  9.11  ISSUED: 8/18/2003'/ 
d146 15
d238 3
d268 4
d297 12
d328 3
a331 3
        MAXDIMMB = MAXDIM / 1000000
        WRITE(NDAT,9095) MAXDIMMB
9095    FORMAT(' YOU HAVE           ',I5,' MB OF COMMON BLOCK MEMORY')
d334 5
d340 1
d375 3
d389 3
d499 5
d505 1
d573 3
d580 3
d588 6
d596 1
d640 3
d644 1
d652 4
d658 1
d667 3
d671 1
d823 6
d830 1
d833 6
d840 1
d924 4
d929 1
d978 4
d983 1
@


1.226
log
@version increase
@
text
@d80 1
d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  9.10  ISSUED: 8/07/2003'/ 
d193 1
d493 4
d515 1
d691 3
@


1.225
log
@new version
@
text
@d128 1
a128 1
        DATA CVERS/'VERSION:  UNIX  9.06  ISSUED: 7/17/2003'/ 
@


1.224
log
@version
@
text
@d128 1
a128 1
        DATA CVERS/'VERSION:  UNIX  9.05  ISSUED: 6/07/2003'/ 
@


1.223
log
@ignores () on initial batch from command line
@
text
@d128 1
a128 1
        DATA CVERS/'VERSION:  UNIX  9.04  ISSUED: 4/02/2003'/ 
@


1.222
log
@version
@
text
@a30 1
C        0         2         3         4         5         6         7 *
d37 1
a37 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ PARAMETER  INITIALIZATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d74 1
a74 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  DECLARATIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d125 1
a125 1
C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ VERSION INITIALIZATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d128 1
a128 1
        DATA CVERS/'VERSION:  UNIX  9.03  ISSUED: 3/24/2003'/ 
d130 1
a130 1
C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DATA STATEMENTS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d143 1
a143 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  CODE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d222 7
d230 6
a236 2
 
	WRITE(NOUT,9091)
a237 2

        WRITE(NOUT,9092)
a238 2

	WRITE(NOUT,9093)CVERS
d240 1
a240 3

	WRITE(NOUT,9094)CDATT(1:11),CTIM
9094    FORMAT('   /     \\          DATE:    ',A,'    AT  ',A,//)
d242 5
d249 1
a249 1
C       GET DATEXC, START & RESCHEDULE PROCEDURES
d304 1
a304 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ OPERATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d323 2
a324 1
        SILENT      = .FALSE.
d326 1
a326 1
         IRTFLG = -999
d425 1
a425 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START PROCEDURE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d610 1
a610 1
     &      ISDIGI(PLINE(3:3))) THEN
d618 2
a619 1
	     CALL ERRT(101,'REGISTER ARGUMENTS SENT TO PROC. WRONG',NE)
d631 2
a632 1
        ELSE
d640 1
a640 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ RETURN FROM PROCEDURE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d642 1
a642 1
C RETURN FROM PROCEDURE------------------------------------------- RE
@


1.221
log
@version
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  9.02  ISSUED: 3/04/2003'/ 
@


1.220
log
@new version for opfilec
@
text
@d8 1
a8 1
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  9.01  ISSUED: 2/25/2003'/ 
@


1.219
log
@indexed stacks release 9.0
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  9.00  ISSUED: 1/23/2003'/ 
@


1.218
log
@endit gets result file name
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.09  ISSUED: 1/2/2003'/ 
@


1.217
log
@new version
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.08  ISSUED: 12/30/2002'/ 
d412 1
a412 1
9999    CALL ENDIT('SHOULD NEVER GET HERE',.FALSE.)
d725 2
a726 1
      CALL ENDIT('COMPLETED',DELETIT)
@


1.216
log
@version 8.07
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.07  ISSUED: 11/20/2002'/ 
@


1.215
log
@NPARG --> 24
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.06  ISSUED: 10/10/2002'/ 
@


1.214
log
@version incremented
@
text
@d57 1
a57 1
	PARAMETER (NPARG=12)     
a80 1
        REAL      FREGST(7)
d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.05  ISSUED: 10/07/2002'/ 
@


1.213
log
@[] --> () & <> --> []
@
text
@d130 1
a130 1
        DATA CVERS/'VERSION:  UNIX  8.04  ISSUED:  9/12/2002'/ 
@


1.212
log
@comment & version increment
@
text
@d130 1
a130 1
        DATA CVERS/'VERSION:  UNIX  8.03  ISSUED:  9/11/2002'/ 
d595 1
a595 1
           CALL ERRT(101,'*** COULD NOT READ FIRST LINE OF PROC.',NDUM)
d599 1
a599 1
	IF (PLINE(:1) .EQ. '[' .AND. 
@


1.211
log
@version incremented
@
text
@d102 2
a103 1
C       DBUF = DOCUMENT BUFFER FOR DOCUMENT IN-CORE IMAGE(S) 
d130 1
a130 1
        DATA CVERS/'VERSION:  UNIX  8.02  ISSUED:  7/14/2002'/ 
@


1.210
log
@onunix common removed
@
text
@d129 1
a129 1
        DATA CVERS/'VERSION:  UNIX  8.01  ISSUED:  7/02/2002'/ 
@


1.209
log
@iparnum
@
text
@a101 3
	LOGICAL        ONSUN,ONUNIX,ONSGI,ONOSF
        COMMON /OPSYS/ ONSUN,ONUNIX,ONSGI,ONOSF

a165 9
        ONSUN       = .FALSE.
        ONUNIX      = .TRUE.
#ifndef __osf__
        ONSGI       = .TRUE.
        ONOSF       = .FALSE.
#else
        ONSGI       = .FALSE.
        ONOSF       = .TRUE.
#endif
@


1.208
log
@DELAY_FREE
@
text
@d122 2
a123 3
C       FOR SYMBOLIC PARAMETER HANDLING, (IWHERE IS UNUSED) 
        INTEGER, DIMENSION(MAXPRC) :: IPSTACK
        INTEGER, DIMENSION(MAXPRC) :: IPNUMSTACK
d125 1
a125 1
     &                       IPNUMSTACK
@


1.207
log
@sympar version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  8.00  ISSUED:  6/27/2002'/ 
d168 1
a168 1
        N_MOSAIC    = 0
@


1.206
log
@version 8 !!
@
text
@d8 1
a8 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d122 1
a122 1
C       FOR SYMBOLIC PARAMETER HANDLING 
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  8.00  ISSUED:  6/26/2002'/ 
a513 3

C       SET LINE OFFSET IN CALLER FOR USE IN SOLICITATIONS
        IWHERE = IBCNT
@


1.205
log
@new version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.17  ISSUED:  6/14/2002'/ 
d228 2
a229 2
C       INITIALIZE SYMBOLIC PARAMETER INFO FOR NEW PROCEDURE
        CALL SETSYMPAR(NULL,RESPONSE,NCHAR,IRTFLG)
d495 1
a495 1
        CALL SETSYMPAR(NULL,RESPONSE,NCHAR,IRTFLG)
@


1.204
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.16  ISSUED:  5/17/2002'/ 
@


1.203
log
@version incremented & output formatting
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.15  ISSUED:  3/19/2002'/ 
@


1.202
log
@verbose & cosmetic
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.14  ISSUED:  3/07/2002'/ 
d700 1
a700 1
	WRITE(NDAT,10080) PNAME
@


1.201
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.13  ISSUED:  2/27/2002'/ 
d529 1
d531 1
a531 1
6380	FORMAT(/,' -- START OF: ',A,'    --')
d699 1
d701 2
a702 1
10080	FORMAT(/,' END OF: ',A/)
d739 1
a739 1
8900  WRITE(NOUT,*) '*** ATTEMPTED TERMINATION ASSUMED'
@


1.200
log
@version
@
text
@d97 1
a97 1
	CHARACTER * 4         LABEL,FMT,CXNUM
d100 1
a100 1
        CHARACTER * 1         NULL,DUM,RESPONSE
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.12  ISSUED:  2/13/2002'/ 
a135 3

C       FORMAT FOR INTERNAL READ/WRITE
        DATA FMT/'(I )'/
@


1.199
log
@version 7.11
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.11  ISSUED:  1/30/2002'/ 
@


1.198
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.10  ISSUED: 11/19/2001'/ 
@


1.197
log
@version incremented
@
text
@d24 1
a24 1
C                   ITIN     5                               INPUT    *
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.09  ISSUED: 11/13/2001'/ 
@


1.196
log
@NECHO --> NOUT
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.08  ISSUED: 07/31/2001'/ 
@


1.195
log
@Perl scripting version
@
text
@a23 1
C                   NECHO    6                  3     NDAT   ECHO      *
a161 1
	NECHO = NOUT
a540 1
	NECHO = NDAT
a722 1
        NECHO = NOUT
@


1.194
log
@reg_pipe added
@
text
@d20 1
a20 1
C                   NIN      5                  5     NDISK            *
d29 1
d134 1
a134 1
        DATA CVERS/'VERSION:  UNIX  7.07  ISSUED: 06/15/2001'/ 
d155 1
@


1.193
log
@version
@
text
@d108 1
a108 1
        COMMON /DRIV1_COM/ T1,LOOPREG
@


1.192
log
@version
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.06  ISSUED: 06/06/2001'/ 
@


1.191
log
@increased pline size
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.04  ISSUED: 04/16/2001'/ 
@


1.190
log
@N_VERBOSE --> VERBOSE
@
text
@d91 2
a92 2
        CHARACTER *160        MESG
        CHARACTER *80         COMMENTFUNC,FRPROMPT,PLINE,CLINE
@


1.189
log
@version incremented
@
text
@d170 1
a170 1
        N_VERBOSE   = 1
d577 1
a577 1
           IF (N_VERBOSE .EQ. 1) WRITE(NDAT,*) ' '
d585 1
a585 1
              IF (N_VERBOSE .EQ. 1) 
d595 1
a595 1
           IF (N_VERBOSE .EQ. 1) WRITE(NDAT,*) ' '
d827 1
a827 1
        IF (N_VERBOSE .EQ. 1) WRITE(NOUT, 8860) COMMENTFUNC,IABSLP
d876 1
a876 1
          IF (N_VERBOSE .EQ. 1) WRITE(NOUT, 8860) FCHAR(1:20),IABSLP
@


1.188
log
@version incremented
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.03  ISSUED: 04/09/2001'/ 
@


1.187
log
@driv1 parameters wrong
@
text
@d8 1
a8 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.02  ISSUED: 03/19/2001'/ 
d943 1
a943 4
10800   CALL FILNAMSUB(FCHAR,NALPH,.FALSE.,FDUM,IER)
        IF (IER .NE. 0)  GOTO 5000

        CALL LOGIFQ(FCHAR,LABEL,JUMP,IER)
@


1.186
log
@REESPONSE needed CHAR definition for NT compiler
@
text
@d262 1
a262 1
           CALL DRIV1(MAXDIM,IRTRET)
@


1.185
log
@renamed SPIDER procs to .spi
@
text
@d100 1
a100 1
        CHARACTER * 1         NULL,DUM
@


1.184
log
@version
@
text
@d4 1
a4 1
C MAIN SPIDER SUBROUTINE                                               *
d67 1
a67 1
C       WE USUALLY HAVE > 96 MB RAM AVAILABLE ON ALBANY MACHINES
d460 2
a461 3
C         TRY AGAIN UNDER 'PROC:*.SYS' IN PROC DIR.
C         SET FLAG INDICATING THAT WE DO HAVE A 'SYS' EXTENSION
C         7/10/88 PROC IS LOGICAL FOR DIRECTORY WHERE *.SYS FILES ARE al
d465 1
a465 1
          IF (IER .NE. 0) CALL ERRT(101,'NO ENVIRONMENT VAR',NE)
d467 1
a467 1
          PNAME  = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.sys'
d472 2
a473 3
C           THE *.SYS FILE DOES NOT EXIST. NOTIFY USER
5800        MESG = 'PROCEDURE FILE.SYS DOES NOT EXIST: ' // 
     &             PNAME(:NPNAME) 
@


1.183
log
@CALL INDEXTOREG( parameters
@
text
@d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.01  ISSUED: 02/22/2001'/ 
d798 1
a798 1
        NC      = NLET - ILOCLIM + 1 
@


1.182
log
@silent needs to be reset for each op
@
text
@d792 2
a793 1
           IDUM = INDEXTOREG(FCHAR(ILOCLIM-2:ILOCLIM-2),.FALSE.,LOOPREG)
@


1.181
log
@changes for ?xxxx? anywhere
@
text
@d313 2
a314 2
C       GET THE OPERATION
5000	IRTFLG = -999
d330 3
@


1.180
log
@DECOMMENT(RESPONSE(1:NCHAR)
@
text
@d48 1
a48 1
	PARAMETER (NMENU1 = 9) 
a78 1
	INTEGER   IPSTACK(MAXPRC)
d91 1
a91 1
        CHARACTER *160        MESG,RESPONSE
d122 5
a126 6
        CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) :: QSTRQSTK
        INTEGER, DIMENSION (NQSTRSIZ,MAXPRC) :: IGOQSTRSTK,IENDQSTRSTK
        INTEGER, DIMENSION (MAXPRC)         ::  NQSTRNOWSTK,LENQSTRSTK
        COMMON /QSTR_STUFF1/ ISTOP
        COMMON /QSTR_STUFF2/ IGOQSTRSTK,IENDQSTRSTK,NQSTRNOWSTK
        COMMON /QSTR_STUFF3/ QSTRQSTK
a127 2
        INTEGER,   DIMENSION(MAXPRC)     :: IPNUMSTACK
 
d133 1
a133 1
        DATA CVERS/'VERSION:  UNIX  7.00  ISSUED: 01/23/2001'/ 
d140 1
a140 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO','FR','RR'/
d231 2
a232 4
C       SET INITIAL SYMBOLIC PARAMETER INFO 
	LENQSTRSTK(1)  = 0
        NQSTRNOWSTK(1) = 0
        QSTRQSTK(1)    = ' '
d410 1
a410 3
            GOTO(8400, 8600, 8800, 8900, 10000, 10800, 10800,
     &           8500, 8500),IFUNC
C           OP:    FR,   RR
d497 1
a497 3
	LENQSTRSTK(ISTOP)  = 0
        NQSTRNOWSTK(ISTOP) = 0
        QSTRQSTK(ISTOP)    = ' '
a744 168
C     FR (SYMBOLIC PARAMETER SETTING ) ---------------------------- FR

C     GET "?-----? STRING
8500  INOUPPER = -999
      CALL RDPRMC(FRPROMPT,NUMCHR,.TRUE.,
     &            'SYMBOLIC PARAMETER PROMPT & NUMBER',NULL,INOUPPER)
      IF (INOUPPER .NE. 0) GOTO 5000

      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'?','?',.FALSE.,.FALSE., 
     &                   IGO,IEND,NCHARQ)
      IF (IGO .LE. 0) GOTO 5000

C     GET RESPONSE TO ?---? FRPROMPT
      IF (.NOT. FROMBATCH) THEN
C        CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS FRPROMPT
         WRITE(ITI,2330)  FRPROMPT(IGO:IEND)
2330     FORMAT('$',A)
         READ(ITIN,90) RESPONSE
90       FORMAT(A)

C        FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
         CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)           
         
      ELSE
C        NOT FROM INTERACTIVE MODE
C        GET RESPONSE TO ?---? FRPROMPT, FROM PROCEDURE FILE
         CALL PROC_GETPLINE(IWHERE+1,IPNUMSTACK(ISTOP-1),RESPONSE,
     &                      NCHAR,IRTFLG)

C        SAVE IWHERE FOR FURTHER READS
         IWHERE         = IWHERE + 1
         IPSTACK(ISTOP) = IWHERE

C        FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
         CALL DECOMMENT(RESPONSE(1:NCHAR),NCHAR,LOCSEMI)           
      ENDIF
      RESPONSE(NCHAR+1:) = ' '

C     RESPONSE MAY CONTAIN PARAMETER SUBSTITUTION FROM HIGHER PROCS.
      ILEVEL = ISTOP - 1
      DO 
        IF (ILEVEL .LE. 0) EXIT

C       FIND START AND END OF PARAMETER STRING IN RESPONSE 
        IP1 = INDEX(RESPONSE(1:NCHAR),'<')
      
        IF (IP1 .LE. 0 .OR. .NOT. ISDIGI(RESPONSE(IP1+1:IP1+1))) EXIT
C       '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
        CALL SUBSYMPAR(RESPONSE,LOCSEMI,NCHAR,ILEVEL,IRTFLG)

        ILEVEL = ILEVEL - 1

      ENDDO

      IF (RESPONSE(:1) .EQ. 'X' .OR. RESPONSE(2:2) .EQ. 'X' .OR.
     &    RESPONSE(:1) .EQ. 'x' .OR. RESPONSE(2:2) .EQ. 'x') THEN
C         ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

         CALL CHKSTR(RESPONSE,NCHAR,'RE',IDUM,FREGST,7,INUM,IRTFLG)
         IF (IRTFLG .NE. 0) CALL ERRT(101,'ERROR IN REGISTER SUB.',NE)

C        FIX PRECISION ERROR HERE!!!!!
         ITEMP = MIN(INUM,6)
         WRITE(RESPONSE(1:80),2621) (FREGST(I),I=1,ITEMP)
2621     FORMAT(6(1PG12.5,' '))
         NCHAR            = INUM * 13 + 1
         RESPONSE(NCHAR:) = ' '

      ELSE
C        MAY WANT TO SUBSTITUTE. FOR REGS, SEE IF NEW STYLE SUB.

         CALL CHARINSIDE(RESPONSE(1:NCHAR),'{','}',.TRUE.,.FALSE., 
     &                     IGOSUB,IENDSUB,NSUB)

C        ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REG

         IF ((NCHAR .GE. 2 .AND. ISDIGI(RESPONSE(NCHAR:NCHAR))).AND. 
     &       (RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'X'  .OR. 
     &        RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'x')) THEN
C           OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-2) // '000{---' // 
     &                 RESPONSE(NCHAR-1:NCHAR) // '}'
            NCHAR  = NCHAR + 8
            NSUB   = 1

         ELSEIF((NCHAR .GE. 3 .AND. 
     &           ISDIGI(RESPONSE(NCHAR:NCHAR))).AND.
     &          (RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'X'  .OR. 
     &           RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'x') .AND.
     &           ISDIGI(RESPONSE(NCHAR-1:NCHAR-1))) THEN
C           OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-3) // '000{---' //
     &                 RESPONSE(NCHAR-2:NCHAR) // '}' 
            NCHAR = NCHAR + 8
            NSUB  = 1
         ENDIF
      ENDIF

      IF (NSUB .GT. 0) THEN
C        HAVE EITHER OLD OR NEW STYLE REGISTER SUBSTITUTION

C        PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C        SUBSTITUTE FOR {+++X??} OR {---X??} IN RESPONSE STRING
C        WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
         CALL FILNAMSUB(RESPONSE,NCHAR,.TRUE.,ISTOP,IRTFLG)
      ENDIF


C     FIND START AND END OF PARAMETER STRING IN INPUT (IF ANY)
      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'<','>',.TRUE.,.FALSE.,
     &                IP1,IP2,NCM1)

      IF (IP1 .LE. 0) THEN  
C        NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRNOW
         NQSTR = NQSTRNOWSTK(ISTOP) + 1
      ELSE
C        <#> IS AVAILABLE IN QUERY STRING
         READ(FRPROMPT(IP1:IP2),93,IOSTAT=IRTFLG) NQSTR
93       FORMAT(I10)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(101,'UNABLE TO READ PARAMETER NUMBER',NDUM)
            GOTO 5000
         ENDIF
      ENDIF

      IF ((LENQSTRSTK(ISTOP) + NCHAR) .GT. MAXQSTR) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(30,'SPIDER',NE)
         GOTO 10000
      ELSEIF (NQSTR .GE. NQSTRSIZ) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(102,'NQSTRSIZ OVERFLOW OF SYMBOLIC PARAMETERS',
     &                NQSTR)
         GOTO 10000
      ENDIF

C     PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
      IGOQSTRSTK(NQSTR,ISTOP)  = LENQSTRSTK(ISTOP) + 1
      LENQSTRSTK(ISTOP)        = LENQSTRSTK(ISTOP) + NCHAR 
      IENDQSTRSTK(NQSTR,ISTOP) = LENQSTRSTK(ISTOP)
      QSTRQSTK(ISTOP)
     &        (IGOQSTRSTK(NQSTR,ISTOP):IENDQSTRSTK(NQSTR,ISTOP)) =
     &        RESPONSE(1:NCHAR)
      IF (NQSTR .GT. NQSTRNOWSTK(ISTOP)) NQSTRNOWSTK(ISTOP) = NQSTR

      IF (FCHAR(4:4) .EQ. 'T') THEN
C        TEST OF FILENAME SUBSTITUTION MECHANISM
         IRTFLG = -999
         CALL RDPRMC(CLINE,NLET2,.FALSE.,'CORRECT NAME',NULL,IRTFLG)
         IF (IRTFLG .EQ. 0 .AND. 
     &       RESPONSE(1:NCHAR) .NE. CLINE(1:NLET2)) THEN
            WRITE(NOUT,*) '*** ERROR IN FILENAME FORMATION!!!'
            WRITE(NOUT,9065) RESPONSE(1:NCHAR),CLINE(1:NLET2)
9065        FORMAT( '*** GOT: ',A,'  SHOULD BE: ',A/)
            CALL ERRT(100,' ',NE)
         ENDIF
      ELSEIF (FCHAR(1:2) .EQ. 'RR') THEN
C        RR  SUBSTITUTION
         RESPONSE(1:NCHAR+1) = '~' // RESPONSE(1:NCHAR)
         CALL READRQ(RESPONSE)
      ENDIF
C     END OF ?*******?  PROCEDURE QUESTION EVALUATION SECTION 
      IF (NECHO .NE .0) WRITE(NECHO,90) RESPONSE
      IF (NLOG .NE. 0)  WRITE(NLOG,90) RESPONSE

      GOTO 5000


a1018 24


C      *********************** DECOMMENT ********************************

       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,LOCSEMI)

C      REMOVES COMMENT AND ANY TRAILING BLANKS

       CHARACTER *(*) CINPUT

       NCHAROUT = LNBLNKN(CINPUT)

C      IGNORE SEMICOLON DENOTED COMMENT AT END OF CINPUT STRING
       LOCSEMI = INDEX(CINPUT,';')

       IF (LOCSEMI .EQ. 1) THEN
          NCHAROUT = 0

       ELSEIF (LOCSEMI .GT. 1) THEN
C         STRIP COMMENT & TRAILING BLANKS
          NCHAROUT = LNBLNKN(CINPUT(1:LOCSEMI-1))
       ENDIF
       RETURN
       END
@


1.179
log
@QSTR_STUFF align
@
text
@d774 3
d787 3
a790 3

C     FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
      CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)           
@


1.178
log
@removed unused common comment
@
text
@d126 3
a128 3
        INTEGER, DIMENSION (3)         ::  I64PAD
        COMMON /QSTR_STUFF/ ISTOP,I64PAD,IGOQSTRSTK,IENDQSTRSTK,
     &                      NQSTRNOWSTK,QSTRQSTK
@


1.177
log
@QSTR pad & sys proc name bug fixed
@
text
@a74 2
        COMMON   BUF(MAXDI)

@


1.176
log
@indextoreg parameters
@
text
@d75 1
a75 1
c         COMMON   BUF(MAXDI)
d128 2
a129 1
        COMMON /QSTR_STUFF/ ISTOP,IDUM1,IGOQSTRSTK,IENDQSTRSTK,
d475 2
a476 1
          PNAME = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.sys'// NULL
d481 2
a482 1
5800        MESG = 'PROCEDURE FILE.SYS DOES NOT EXIST: ' // PNAME 
@


1.175
log
@cdat whould only print 11 char
@
text
@d963 1
a963 1
           IDUM = INDEXTOREG(FCHAR(ILOCLIM-2:ILOCLIM-2),LOOPREG)
@


1.174
log
@incore procedurres version 7.00
@
text
@d302 1
a302 1
	WRITE(NDAT,9094)CDATT,CTIM
@


1.173
log
@version incremented
@
text
@d19 2
a20 2
C  LUN ASSIGNMENTS: LUN  USUAL   SOURCE  IN PROCEDURE SOURCE  SINK      *
C                   NIN      5                  1     NDISK  B* FILE   *
d25 1
d27 3
a29 5
C                   ITIN     5                               INPUT     *
C                   NPROC    1   NDISK          0     ?      NDISK     *
C                   LUNDO  301                                                                    *
C                   NDOC     4
C                   NINTMP   2
a42 3
C	MAXIMUM NUMBER OF  DIFFERENT PROCEDURE FILES USED IN A RUN
	PARAMETER (MAXPRCNAM = 40) 

d56 1
a56 1
C	MAXIMUM NUMBER OF PROCEDURE REGISTER ARGUMENTS
d71 5
a75 1
        COMMON   BUF(MAXDI)
a92 1
        CHARACTER *(NNAME)    PNAMESTACK(MAXPRC),PNAMECALLER
a122 1
	INTEGER  BIT_SIZE
d128 6
a133 2
        COMMON /QSTR_STUFF/ ISTOP,IGOQSTRSTK,IENDQSTRSTK,NQSTRNOWSTK,
     &                      QSTRQSTK
d138 1
a138 1
        DATA CVERS/'VERSION:  UNIX  6.45  ISSUED: 01/10/2001'/ 
d151 1
a151 1
        DATA NDISK/1/,LUNDO/300/,NINTMP/2/
d158 3
a160 2
C       INITIALIZE COMMON BLOCK LUNS  
	NPROC = 0
d162 4
a165 2
	NIN   = 5
	NOUT  = 6
a166 2
	ITI   = NOUT
	ITIN  = NIN
d209 1
a209 1
          IDOSTK(I,1) = 1
d217 9
d227 2
a228 1
        PNAMESTACK(ISTOP)   = 'INTERACTIVE'
a234 7

C       INITIALIZE PROCFL & NUMPRC USED TO TRACK OF PROCEDURE LISTING:
C       PROCEDURES LISTED IN THE RESULTS FILE ON FIRST OCCURRENCE ONLY
	DO L1=1,MAXPRCNAM
           PROCFL(L1)(:NNAME) = ' '
        ENDDO
	NUMPRC = 0
a260 3
        MAXDIMMB = MAXDIM / 1000000
        WRITE(NOUT,9095) MAXDIMMB
9095    FORMAT(' YOU HAVE           ',I5,' MB OF COMMON BLOCK MEMORY')
d277 1
a277 2
	NPROC = NDISK
	OPEN(NPROC,FILE=LOG,STATUS='UNKNOWN',IOSTAT=IER)
d307 1
d309 1
d311 2
a312 6
C       CLOSE AND REOPEN RESULTS FILE TO ENSURE THAT EXISTS NOW
C       AND OVERRIDE OUTPUT BUFFERING (FOR MULTI-PROCESS WORK) 
        CLOSE(NDAT)
        OPEN(NDAT,FILE=RESULT,STATUS='UNKNOWN',IOSTAT=IER)
	IF (IER .NE. 0) 
     &     STOP '*** UNABLE TO RE-OPEN RESULTS FILE ***'
d332 1
a332 1
              IF (NLOOP .LE. 0) LUNDOWNOW = 0
d336 1
a336 1
C       GET THE OPERATION
d428 1
a428 1
           MESG = 'UNDEFINED EXPRESSION: ' // FCHAR
a443 4
C       FIND FIRST CHARACTER IN FILENAME
	NFSTRT = 1
	IF (FCHAR(:1) .EQ. '@@') NFSTRT = 2

d451 3
d485 1
a485 1
C       INCREMENT PROCEDURE LEVEL COUNTER
d489 1
a489 3
           WRITE(NOUT,6170) MAXPRC
6170       FORMAT(' *** PROCEDURE NESTING LEVEL (',I3,') EXCEEDED')
           CALL ERRT(101,'PROCEDURE NESTING LEVEL EXCEEDED',NE)
a491 5
C       PUT INFO FROM CALLING PROCEDURE  ON THE STACKS

C       PUT THE NEW PROCEDURE FILE ON THE STACK
        PNAMESTACK(ISTOP)   = PNAME

a525 3
C       PNAMECALLER IS LAST USED PROCEDURE FILE-NEEDED FOR 
C       SOLICITATIONS IN OPERATION "FR".  
        PNAMECALLER = PNAMESTACK(ISTOP-1)
d546 1
a546 1
C       SET ALL THE LUNS & CURRENT POCEDURE LINE COUNTER
d553 2
a554 7
	IF (NPROC .NE. 0) CLOSE(NPROC)
	NPROC = 0

C       CLOSE THE PREVIOUS PROCEDURE
	CLOSE(NIN)
C       OPEN NEW PROCEDURE FILE.
	OPEN(NIN,FILE=PNAME,STATUS='UNKNOWN')
d556 1
a556 1
C       LIST PROCEDURE FILE ON FIRST CALL ONLY.
d558 3
a560 4
C       SEE IF PROCEDURE ALREADY LISTED
        DO L1 = 1, NUMPRC 
           IF (PNAME .EQ. PROCFL(L1)(:NNAME)) THEN
C            DON'T NEED TO COPY PROC FILE INTO RESULTS FILE
d562 1
d567 4
a570 14
           IF (N_VERBOSE .EQ. 1) THEN
C             WRITE OUT THE PROCEDURE OPERATIONS
	      IPCARD = 0
	      WRITE(NDAT,*) ' '
              DO 
                 READ(NIN,3950,IOSTAT=IERR) PLINE
3950             FORMAT(A)
                 IF (IERR .NE. 0) EXIT
	         IPCARD = IPCARD + 1
	         WRITE(NDAT,3960) IPCARD, PLINE
3960             FORMAT(3X,I4,4X,A)
              ENDDO
              WRITE(NDAT,*) ' '
           ENDIF
d572 1
a572 1
           REWIND NIN
d574 3
a576 2
C             TOO MANY PROCEDURE NAMES
              CALL ERRT(21,'SPIDER',NE)
d578 31
a608 1
	   ENDIF
a609 2
           NUMPRC = NUMPRC + 1
           PROCFL(NUMPRC)(:NNAME) = PNAME
d612 2
a613 1
	NARGSREC(ISTOP) = 0
d615 6
a620 3
C       READ FIRST LINE OF PROCEDURE TO CHECK FOR ARGUMENT TRANSFER
        READ(NIN,90,IOSTAT=IERR) PLINE
        IF (IERR .NE. 0) THEN
d624 1
a624 1
        IBCNT = IBCNT + 1
a629 2
C         FIND LAST NON-BLANK            
          NUMCHR = lnblnk(PLINE)
a648 1
          BACKSPACE(NIN)
a705 3
C       RETRIEVE PNAMECALLER INFO FROM LOWER PROCEDURE LEVEL 
        PNAMECALLER = PNAMESTACK(ISTOP)

d713 3
a715 3
C       CLOSE CURRENT PROCEDURE FILE
	CLOSE(NIN)
          
d718 1
a718 2
           PNAME(1:NNAME) = PNAMESTACK(ISTOP)(1:NNAME)
	   OPEN(NIN,FILE=PNAME,STATUS='UNKNOWN')
d720 1
a720 1
C          OFFSET INPUT FOR SOLICITATIONS THAT WERE DONE BY
a721 5
           IF (IBCNT .GT. 0) THEN
	      DO I=1,IBCNT
                 READ(NIN, 90) DUM
              ENDDO
           ENDIF
d733 1
a733 1
	NPROC = NDISK
d736 1
a736 1
        OPEN(NPROC,FILE=LOG,STATUS='OLD',
a768 1

d772 2
a773 1

d776 3
a778 7
C        GET RESPONSE TO ?---? FRPROMPT, FROM FILE
         OPEN(NINTMP,FILE=PNAMECALLER,STATUS='UNKNOWN') 
         DO I = 1, IWHERE + 1
            READ(NINTMP,90) RESPONSE
90          FORMAT(A)
         ENDDO
         CLOSE(NINTMP)
d781 1
a781 1
         IWHERE = IWHERE + 1
d914 1
a914 1
      IF (NPROC .NE. 0 .AND. NPROC .NE. NECHO) WRITE(NPROC,90) RESPONSE
a1032 1
          REWIND NIN
d1217 2
@


1.172
log
@charinside parameters changed
@
text
@d66 1
a66 2
C       OR DECREASE THE MEMORY NEEDED BY SPIDER.  ALTER MAXDI
C       BELOW TO DECREASE MEMORY. 
d136 1
a136 1
        DATA CVERS/'VERSION:  UNIX  6.44  ISSUED: 01/04/2001'/ 
@


1.171
log
@MEMALLOCABLE removed
@
text
@d768 1
a768 1
      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'?','?',.FALSE., 
d805 1
a805 1
        CALL CHARINSIDE(RESPONSE(1:NCHAR),'<','>',.FALSE.,IP1,IP2,NCT)
d809 1
a809 2
        CALL SUBSYMPAR(RESPONSE,LOCSEMI,NCHAR,IP1,IP2,
     &                 ILEVEL,IRTFLG)
d832 1
a832 1
         CALL CHARINSIDE(RESPONSE(1:NCHAR),'{','}',.TRUE., 
d870 2
a871 1
      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'<','>',.TRUE.,IP1,IP2,NCM1)
@


1.170
log
@" --> '
@
text
@d108 1
a108 1
        COMMON /OPSYS/ ONSUN,ONUNIX,ONSGI,ONOSF,MEMALLOCABLE
d137 1
a137 1
        DATA CVERS/'VERSION:  UNIX  6.43  ISSUED: 12/18/2000'/ 
a306 3

        IF (MEMALLOCABLE .GT. 0) WRITE(NDAT,9097) MEMALLOCABLE
9097    FORMAT(' YOU HAVE REQUESTED ',I5,' MB OF RUN_TIME MEMORY'/)
@


1.169
log
@time --> mytime
@
text
@d746 1
a746 1
     &        ACCESS="SEQUENTIAL",POSITION="APPEND")
@


1.168
log
@added trap for elseif
@
text
@d137 1
a137 1
        DATA CVERS/'VERSION:  UNIX  6.42  ISSUED: 11/01/2000'/ 
d194 1
a194 1
        CALL TIME(ZEIT)
d196 2
a197 2
	ISEEDVAL(I)= ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &       I*(1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)))
d238 1
a238 1
        CALL TIME(CTIM)
@


1.167
log
@bad driv1 parameters bug fixed
@
text
@d410 5
@


1.166
log
@versioning on command line & can append to results file
@
text
@d137 1
a137 1
        DATA CVERS/'VERSION:  UNIX  6.41  ISSUED: 10/18/2000'/ 
d267 1
a267 1
           CALL DRIV1(MAXDIM)
@


1.165
log
@put MAXPRC in CMLIMIT now
@
text
@d102 1
a102 1
	CHARACTER * 4         LABEL,FMT
d113 1
a113 2
        CHARACTER * 4      CXNUM
        COMMON /DRIV1_COM/ T1,LOOPREG,CXNUM
d137 1
a137 1
        DATA CVERS/'VERSION:  UNIX  6.40  ISSUED: 09/18/2000'/ 
a192 2
C       ARGUMENT OF BIT_SIZE HAS TO BE ANY INTEGER VARIABLE
	NUMBITS=NUMBITS/BIT_SIZE(ILOOP)
d262 1
a262 1
        CALL INITUNIX(NUMARG,FCHAR,NALPH)
d287 7
a293 1
        OPEN(NDAT,FILE=RESULT,STATUS='UNKNOWN',IOSTAT=IER)
@


1.164
log
@corrected procX removal
@
text
@a40 4
C       MAXIMUM NESTING FOR PROCEDURES & DO LOOPS & IF...THEN CLAUSES
C       DANGER MAXPRC IS ALSO SET IN setreg.f!!
        PARAMETER (MAXPRC = 20) 

@


1.163
log
@corrected procX removal
@
text
@d41 4
a47 4
C	MAXIMUM NESTING FOR PROCEDURES & DO LOOPS & IF...THEN CLAUSES
C       DANGER MAXPRC IS ALSO SET IN setreg.f!!
	PARAMETER (MAXPRC = 20) 

d117 1
a117 1
	CHARACTER * 4         CXNUM
d133 5
a137 6
        CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) ::  QSTRQSTK
        CHARACTER(LEN=MAXQSTR)                ::  QSTRQ
        INTEGER, DIMENSION (NQSTRSIZ,MAXPRC)  ::  IGOQSTRSTK,IENDQSTRSTK
        INTEGER, DIMENSION (NQSTRSIZ)         ::  IGOQSTR,IENDQSTR
        INTEGER, DIMENSION (MAXPRC)           ::  NQSTRNOWSTK,LENQSTRSTK
        COMMON /QSTR_STUFF/ IGOQSTR,IENDQSTR,NQSTRNOW,QSTRQ
d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  6.40  ISSUED: 10/12/2000'/ 
a150 2
        DATA ISTOP/0/

d172 1
d198 2
a199 1

d222 2
d239 3
a241 3
	LENQSTR  = 0
        NQSTRNOW = 0
        QSTRQ    = ' '
a460 1

d511 4
a514 13
C       SAVE SYMBOLIC PARAMETER INFO FOR CALLING PROCEDURE 
        QSTRQSTK(ISTOP)    = QSTRQ
        NQSTRNOWSTK(ISTOP) = NQSTRNOW
        LENQSTRSTK(ISTOP)  = LENQSTR
        DO I = 1,NQSTRNOW
           IGOQSTRSTK(I,ISTOP)  = IGOQSTR(I)
           IENDQSTRSTK(I,ISTOP) = IENDQSTR(I)
        ENDDO

C       RE-SET SYMBOLIC PARAMETER INFO FOR NEW PROCEDURE
	LENQSTR  = 0
        NQSTRNOW = 0
        QSTRQ    = ' '
d536 3
a538 5
	IF (ISTOP .GT. 1) THEN
           PNAMECALLER = PNAMESTACK(ISTOP-1)
C          SET LINE OFFSET IN CALLER FOR USE IN SOLICITATIONS
           IWHERE = IBCNT
        ENDIF
d583 1
a583 1
           IF (N_VERBOSE .EQ. 1 .AND. LISTIT) THEN
d617 1
a617 1

d645 1
d661 1
a661 1
        ELSEIF (ISTOP .LE. 0) THEN
d697 1
a697 1
	IBCNT            = IPSTACK(ISTOP)
a698 9
C       RETRIEVE SYMBOLIC PARAMETER INFO FROM LOWER PROCEDURE LEVEL 
        QSTRQ    = QSTRQSTK(ISTOP)
        NQSTRNOW = NQSTRNOWSTK(ISTOP) 
        LENQSTR  = LENQSTRSTK(ISTOP) 
        DO I = 1,NQSTRNOW
           IGOQSTR(I)  = IGOQSTRSTK(I,ISTOP)  
           IENDQSTR(I) = IENDQSTRSTK(I,ISTOP) 
        ENDDO

d700 1
a700 1
        FROMBATCH = ISTOP .GT. 1
d703 1
a703 3
	IF (ISTOP .GT. 1) THEN
           PNAMECALLER = PNAMESTACK(ISTOP)
        ENDIF
d715 1
a715 1
	IF (ISTOP .GT. 0) THEN
d730 1
a730 1
C       GO BACK TO INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
d752 1
a752 1
C       END SPIDER. -------------------------------------------- EX,EN
d754 12
a765 21
8900    WRITE(NOUT,*) '*** ATTEMPTED TERMINATION ASSUMED'
8400	DELETIT = FCHAR(1:4) .EQ. 'EN D'
        CALL ENDIT('COMPLETED',DELETIT)
	STOP '**** SPIDER NORMAL STOP ****'

C       FR (SYMBOLIC PARAMETER SETTING ) -------------------------- FR

C     GET "-----? STRING
8500  CALL RDPR('SYMBOLIC PARAMETER PROMPT & NUMBER',NUMCHR,FRPROMPT,
     &          .FALSE.,.TRUE.,IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 5000
      IF (NECHO .NE. 0) WRITE(NECHO,90) FRPROMPT(1:NUMCHR)
      IF (NPROC .NE. 0) WRITE(NPROC,90) FRPROMPT(1:NUMCHR)

      ISEMICOL = INDEX(FRPROMPT(1:NUMCHR),';')
      IF (ISEMICOL .GT. 0) THEN
C        POSSIBLE COMMENT PRESENT, IGNORE COMMENTS AFTER ?....? 
         CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'?','?',.FALSE.,
     &                     IDUM,IQ2,NDUM)
         IF (ISEMICOL .GT. IQ2) NUMCHR = ISEMICOL - 1
      ENDIF
d789 2
a790 1
         IWHERE         = IWHERE + 1
d796 1
d798 17
d868 1
d874 1
a874 1
         NQSTR = NQSTRNOW + 1
d885 1
a885 1
      IF ((LENQSTR + NCHAR) .GT. MAXQSTR) THEN
d897 7
a903 5
      IGOQSTR(NQSTR)  = LENQSTR + 1
      LENQSTR         = LENQSTR + NCHAR 
      IENDQSTR(NQSTR) = LENQSTR
      QSTRQ(IGOQSTR(NQSTR):IENDQSTR(NQSTR)) = RESPONSE(1:NCHAR)
      IF (NQSTR .GT. NQSTRNOW) NQSTRNOW = NQSTR
d922 2
d1207 1
a1207 1
       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,ILOCSEMI)
@


1.162
log
@no proxX vearsion
@
text
@d44 4
d117 1
a117 1
        CHARACTER * 4      CXNUM
d133 6
a138 5
        CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) :: QSTRQSTK
        INTEGER, DIMENSION (NQSTRSIZ,MAXPRC) :: IGOQSTRSTK,IENDQSTRSTK
        INTEGER, DIMENSION (MAXPRC)         ::  NQSTRNOWSTK,LENQSTRSTK
        COMMON /QSTR_STUFF/ ISTOP,IGOQSTRSTK,IENDQSTRSTK,NQSTRNOWSTK,
     &                      QSTRQSTK
d152 2
a174 1
        ISTOP       = 1
d200 1
a200 2
C       ARGUMENT OF BIT_SIZE HAS TO BE ANY INTEGER VARIABLE
	NUMBITS=NUMBITS/BIT_SIZE(ILOOP)
a222 2
C       PUT THE STARTING PROCEDURE FILE NAME ON THE STACK
        PNAMESTACK(ISTOP)   = 'INTERACTIVE'
d238 3
a240 3
	LENQSTRSTK(1)  = 0
        NQSTRNOWSTK(1) = 0
        QSTRQSTK(1)    = ' '
d460 1
d511 13
a523 4
C       INITIALIZE SYMBOLIC PARAMETER INFO FOR NEW PROCEDURE
	LENQSTRSTK(ISTOP)  = 0
        NQSTRNOWSTK(ISTOP) = 0
        QSTRQSTK(ISTOP)    = ' '
d545 5
a549 3
        PNAMECALLER = PNAMESTACK(ISTOP-1)
C       SET LINE OFFSET IN CALLER FOR USE IN SOLICITATIONS
        IWHERE = IBCNT
d594 1
a594 1
           IF (N_VERBOSE .EQ. 1) THEN
d628 1
a628 1
        IBCNT = IBCNT + 1
a655 1
          IBCNT = IBCNT - 1
d671 1
a671 1
        ELSEIF (ISTOP .LE. 1) THEN
d707 10
a716 1
	IBCNT     = IPSTACK(ISTOP)
d719 1
a719 1
        FROMBATCH = ISTOP .GT. 2
d722 3
a724 1
        PNAMECALLER = PNAMESTACK(ISTOP)
d736 1
a736 1
	IF (ISTOP .GT. 1) THEN
d751 1
a751 1
C       INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
d773 1
a773 1
C     END SPIDER. ---------------------------------------------- EX,EN
d775 21
a795 12
8900  WRITE(NOUT,*) '*** ATTEMPTED TERMINATION ASSUMED'
8400  DELETIT = FCHAR(1:4) .EQ. 'EN D'
      CALL ENDIT('COMPLETED',DELETIT)
      STOP '**** SPIDER NORMAL STOP ****'

C     FR (SYMBOLIC PARAMETER SETTING ) ---------------------------- FR

C     GET "?-----? STRING
8500  INOUPPER = -999
      CALL RDPRMC(FRPROMPT,NUMCHR,.TRUE.,
     &            'SYMBOLIC PARAMETER PROMPT & NUMBER',NULL,INOUPPER)
      IF (INOUPPER .NE. 0) GOTO 5000
d819 1
a819 2
C        SAVE IWHERE FOR FURTHER READS
         IWHERE = IWHERE + 1
a824 6
      RESPONSE(NCHAR+1:) = ' '

C     RESPONSE MAY CONTAIN PARAMETER SUBSTITUTION FROM HIGHER PROCS.
      ILEVEL = ISTOP - 1
      DO 
        IF (ILEVEL .LE. 0) EXIT
a825 12
C       FIND START AND END OF PARAMETER STRING IN RESPONSE 
        CALL CHARINSIDE(RESPONSE(1:NCHAR),'<','>',.FALSE.,IP1,IP2,NCT)
      
        IF (IP1 .LE. 0 .OR. .NOT. ISDIGI(RESPONSE(IP1+1:IP1+1))) EXIT
C       '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
        CALL SUBSYMPAR(RESPONSE,LOCSEMI,NCHAR,IP1,IP2,
     &                 ILEVEL,IRTFLG)

        ILEVEL = ILEVEL - 1

      ENDDO

a878 1

d884 1
a884 1
         NQSTR = NQSTRNOWSTK(ISTOP) + 1
d895 1
a895 1
      IF ((LENQSTRSTK(ISTOP) + NCHAR) .GT. MAXQSTR) THEN
d907 5
a911 7
      IGOQSTRSTK(NQSTR,ISTOP)  = LENQSTRSTK(ISTOP) + 1
      LENQSTRSTK(ISTOP)        = LENQSTRSTK(ISTOP) + NCHAR 
      IENDQSTRSTK(NQSTR,ISTOP) = LENQSTRSTK(ISTOP)
      QSTRQSTK(ISTOP)
     &        (IGOQSTRSTK(NQSTR,ISTOP):IENDQSTRSTK(NQSTR,ISTOP)) =
     &        RESPONSE(1:NCHAR)
      IF (NQSTR .GT. NQSTRNOWSTK(ISTOP)) NQSTRNOWSTK(ISTOP) = NQSTR
a929 2
      IF (NECHO .NE .0) WRITE(NECHO,90) RESPONSE
      IF (NPROC .NE. 0 .AND. NPROC .NE. NECHO) WRITE(NPROC,90) RESPONSE
d1213 1
a1213 1
       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,LOCSEMI)
@


1.161
log
@removed: NUMBITS=NUMBITS/BIT_SIZE(ILOOP)
@
text
@a20 1
C                   NUNIN    7                               B*X FILE  *
d29 2
d41 5
a45 3
C	MAXIMUM NESTING FOR PROCEDURES & DO LOOPS & IF...THEN CLAUSES
C       DANGER MAXPRC IS ALSO SET IN setreg.f!!
	PARAMETER (MAXPRC    = 20) 
a50 3
C	MAXIMUM NUMBER OF  PROCEDURE NAMES USED IN A RUN
	PARAMETER (MAXPRCNAM = 40) 

d52 1
a52 1
	PARAMETER (NMENU1 = 7) 
a53 3
C	SIZE OF ARRAY FOR STORING PROCEDURE PARAMETER INPUT
	PARAMETER (MAXQSTRQ=2000)  

a62 3
C       NNAME     LENGTH OF PROCEDURE FILENAMES IN BYTES
        PARAMETER (NNAME=80)

a80 2
	REAL      PSTACK(MAXPRC)
        LOGICAL   USEELSE(MAXPRC)
d82 3
a84 2
	INTEGER   IDOSTK(6,MAXPRC),NARGSREC(MAXPRC)
	INTEGER   LOOPSV(7,MAXPRC)
a85 1
	INTEGER   IARGSENT(NPARG,MAXPRC),IARGSREC(NPARG,MAXPRC)
d88 1
d91 1
a91 2
	CHARACTER *(MAXQSTRQ) QSTRQ
        CHARACTER *(NNAME)    TNAMEM,TNAME
d93 2
a94 2
        CHARACTER *(NNAME)    RESULT,LOG,BNAME
        CHARACTER *(NNAME)    FSTACK(MAXPRC),PNAMEC
d96 2
a97 2
        CHARACTER *160        MESG,FUNCNU
        CHARACTER *80         REFUNC,TREFUNC,COMMENTFUNC
a98 2
        CHARACTER * 2         MENU1(NMENU1)
        CHARACTER * 8         RESULM
d101 4
a104 2
	CHARACTER * 4         LOGM,LABEL,FMT
        CHARACTER * 2         LABLSV(MAXPRC)
d113 2
a114 2
	CHARACTER * 4         XNUM
        COMMON /DRIV1_COM/ T1,LOOPREG,XNUM
d129 6
d138 1
a138 1
        DATA CVERS/'VERSION:  UNIX  6.38  ISSUED: 09/06/2000'/ 
d145 1
a145 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO'/
d147 2
a148 1
        DATA ISTOP/0/
a149 3
	DATA RESULM/'results '/
	DATA LOGM/'LOG '/

d151 1
a151 1
        DATA NUNIN/7/,NDISK/1/,LUNDO/300/
d168 1
a190 2
	RESULM(8:8) = CHAR(0)
	LOGM(4:4)   = CHAR(0)
a193 1

d195 1
d218 2
d233 6
a238 6
       
C       INITIALIZE QSTRQ WITH '@@' CHARACTERS
        DO I = 1,MAXQSTRQ
           QSTRQ(I:I) = '@@'
        ENDDO

d289 1
a289 1
        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,XNUM)
d412 4
a415 2
C           OP:     EN,   DO,   LB,   EX,    RE,    IF,    GO
            GOTO (8400, 8600, 8800, 8900, 10000, 10800, 10800), IFUNC
d433 1
a433 17

C       END HANDLING PROCEDURE ---------------------------------------
3600	REWIND NUNIN
	CLOSE(NIN)
	CLOSE(NUNIN)
	OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')

 	IF (LENQSTRQ .GE. 1) THEN
	   DO I = 1, LENQSTRQ
              QSTRQ(I:I) = '@@'
           ENDDO
        ENDIF
	LENQSTRQ = 0
        NQSTRQ   = 0
        GOTO 5000

C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ PROCEDURE START @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d435 1
a435 2
C       COMMAND MUST BE PROCEDURE NAME.
C       SET FLAG FOR PROCEDURE OR INTERACTIVE MODE WHEN PROCEDURE WAS CALLED
d437 2
a438 1
5600    FROMBATCH = (COPT .EQ. 'B')
d440 1
a440 1
C       FIND FIRST POSSIBLE CHARACTER IN FILENAME
d450 2
a451 2
C       TNAME IS TEMP NAME TO SEE WHERE PROCEDURE FILE EXISTS
        TNAMEM = FCHAR(NFSTRT:NCHAR) // NULL
d454 1
a454 1
        CALL FILNAMANDEXT(TNAMEM,PRJEXC,TNAME,NTNAME,.TRUE.,IER)
a455 5
C       PUT TNAME INTO BNAME, CREATE NAME OF TEMPORARY 
C       PROCEDURE FILE BY PUTTING LETTER 'XNNN' BEFORE PERIOD.
        BNAME = TNAME(1:NTNAME-4) // XNUM // 
     &          TNAME(NTNAME-3:NTNAME) // NULL

d457 1
a457 2

	INQUIRE(FILE=TNAME,EXIST=EX)
d460 1
a460 1
          WRITE(NOUT,9045) TNAME 
d467 1
a467 1
          CALL MYGETENV('SPPROC_DIR',TNAME,NCHART,
d470 2
a471 2
          NCHARTN = LNBLNKN(TNAMEM)
          TNAME = TNAME(:NCHART) // TNAMEM(:NCHARTN) // '.sys'// NULL
d473 1
a473 1
          INQUIRE(FILE=TNAME,EXIST=EX)
d476 1
a476 1
5800        MESG = 'PROCEDURE FILE.SYS DOES NOT EXIST: ' // TNAME 
a492 1
C       OK- PNAMEC IS LAST USED PROCEDURE FILE-NEEDED FOR SOLICITATIONS.  
d494 1
a494 1
6200    FSTACK(ISTOP) = BNAME
d507 5
d528 1
a528 3
	PSTACK(ISTOP) = IBCNT
	IF (ISTOP .GT. 1) THEN
           PNAMEC(:NNAME) = FSTACK(ISTOP-1)(:NNAME)
d530 5
a534 3
C          OFFSET NOW EQUAL TO POINTER
           IWHERE = IBCNT
        ENDIF
d547 1
a547 1
	WRITE(NDAT, 6380) TNAME(1:NTNAME)
d553 1
a553 6
C       SET ALL THE LUNS, AND OPEN THE PROCEDURE FILE.
C       CLOSE THE LOG FILE IF INTERACTIVE,
C       CLOSE THE PREVIOUS PROCEDURE ,
C       LIST PROCEDURE FILE ON FIRST CALL ONLY.

        IBCNT = 0
d557 4
d563 1
d565 2
a566 1
	OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')
d568 1
d572 1
a572 1
           IF (TNAME .EQ. PROCFL(L1)(:NNAME)) THEN
d575 1
a575 2
             CLOSE(NUNIN)
           ENDIF
d579 1
a579 1
           IF (N_VERBOSE .EQ. 1 .AND. LISTIT) THEN
a582 1
              IERR = 0
d584 1
a584 1
                 READ(NIN,3950,IOSTAT=IERR) REFUNC
d588 1
a588 1
	         WRITE(NDAT,3960) IPCARD, REFUNC
d602 1
a602 1
           PROCFL(NUMPRC)(:NNAME) = TNAME
a604 10
        OPEN(NUNIN,FILE=BNAME,STATUS='UNKNOWN')

C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ READING PROCEDURE LINE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C       IPCNT  IS POSITION IN CURRENT PROCEDURE
C       IWHERE IS POSITION IN PREVIOUS PROCEDURE
C       LENQSTRQ IS THE INDEX FOR THE QSTRQ ARRAY
	LENQSTRQ        = 0
        NQSTRQ          = 0
	IPCNT           = 0
d608 10
a617 1
        READ(NIN,2389,END=3600) REFUNC
a618 5
	IF (REFUNC(:1) .EQ. '[' .AND. 
     &     (REFUNC(2:2) .EQ. 'X' .OR. REFUNC(2:2) .EQ. 'x') .AND.
     &      ISDIGI(REFUNC(3:3))) THEN
          REFUNC(2:2) = 'X'

d620 2
a621 2
          NUMCHR = lnblnk(REFUNC)
	  CALL FROMTOQ(REFUNC,NUMCHR,IARGSREC(1,ISTOP),NARGREG1,NPARG)
a631 1

a637 8
C         PUT SEMICOLON IN FRONT OF DUMMY ARGUMENT LIST => COMMENT NOW
          REFUNC(1:NUMCHR+1) = ';' // REFUNC(1:NUMCHR)

C         COPY THIS NEW COMMENT TO OUTPUT FILE THEN READ NEXT LINE
          WRITE(NUNIN,2301) REFUNC

C         IPCNT INCREMENT NEEDED BELOW
	  IPCNT  = IPCNT + 1
d641 1
a641 1
 
d644 1
a644 105

2200    READ(NIN,2389,END=3600) REFUNC

C       FIND LAST NON-BLANK BEFORE ANY COMMENT
        CALL DECOMMENT(REFUNC,NUMCHR,ILOCSEMI)

C       PRESERVE COMMENT
        COMMENTFUNC = ' '  
        IF (ILOCSEMI .GT. 0) COMMENTFUNC = REFUNC(ILOCSEMI:)
           
C       INCREMENT NUMBER OF LINES IN PROCEDURE
	IPCNT  = IPCNT + 1

        FUNCNU(1:160) = ' '

        IF (REFUNC(1:1) .NE. '?') THEN
C          NOT PROCEDURE QUESTION, SEE IF SYMBOLIC SUB. NEEDED

C          FIND START AND END OF PARAMETER STRING IN INPUT 
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'<','>',.FALSE.,
     &                        IP1,IP2,NCT)

           IF (IP1 .LE. 0 .OR. IP2 .LE. IP1 .OR. 
     &        .NOT. ISDIGI(REFUNC(IP1+1:IP1+1))) THEN
C             NO SYMBOLIC SUBSTITUTION, COPY ENTIRE REFUNC STRING

C             CHANGE 'do lb' TO UPPERCASE TO SPEED UP LOOPS IN SEARCHQ
              TREFUNC = REFUNC
              CALL SSUPCAS(TREFUNC(1:NUMCHR))
              IGO = INDEX(TREFUNC(1:NUMCHR),'DO LB')
              IF (IGO .GT. 0) THEN
                 WRITE(NUNIN,2301) TREFUNC(1:NUMCHR)
              ELSE     
                 WRITE(NUNIN,2301) REFUNC(1:NUMCHR)
2301             FORMAT(A)
              ENDIF

              GOTO 2200
           ENDIF

C          '<' AND DIGIT => SYMBOLIC PARAMETER SUBSTITUTION NEEDED ----

C          SCAN THE QSTRQ ARRAY TO FIND STRING FOR SUBSTITUTION.
           TREFUNC          = REFUNC
           TREFUNC(IP1:IP1) = '#'
           TREFUNC(IP2:IP2) = '#'
           IPQ1             = INDEX(QSTRQ(1:LENQSTRQ),TREFUNC(IP1:IP2))

           IF (IPQ1 .LE. 0) THEN
C             UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER  
              WRITE(NDAT,*) 'CAN NOT FIND SYMBOLIC REFERENCE FOR: ',
     &                  REFUNC(IP1:IP2)
              WRITE(NDAT,*) '  ' 
              WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES ARE:---------'
              WRITE(NDAT,2301) QSTRQ(1:LENQSTRQ)

              CALL ERRT(100,'SPIDER',NE)
C             STOPS IN ERRT!!
	      GOTO 9999
           ENDIF

C          COPY STRING BEFORE < (IF ANY) INTO FUNCNU
           IF (IP1 .GT. 1) FUNCNU(1:IP1-1) = REFUNC(1:IP1-1)

C          FIND THIS PARAMETER NUMBER IN QSTRQ, THEN
C          COPY CORRESPONDING QSTRQ STRING TO FUNCNU
           NGO     = INDEX(QSTRQ(IPQ1+1:LENQSTRQ),'#') + IPQ1 + 1
           NEND    = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 3
           NOCHAR  = NEND - NGO + 1

           FUNCNU(IP1:NOCHAR+IP1) = QSTRQ(NGO:NEND)
           NOCHAR                 = NOCHAR + IP1 - 1

C          STRIP THE PARAMETER STUFF FROM REFUNC STRING (FOR SIMPLICITY)       
           REFUNC(1:) = REFUNC(IP2+1:NUMCHR)
           NUMCHR     = NUMCHR - IP2 

C          HANDLE REGISTER OR INDEX AFTER <?>
	   IF (REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x') THEN
              IEND = VERIFY(REFUNC(2:NUMCHR),'0123456789')
              IF (IEND .EQ. 0) THEN
C                SYM. PARAMETER & REG. SUBSTITUTION (<??>X? OR <?>X??..) 
                 FUNCNU(NOCHAR+1:NOCHAR+NUMCHR+5) = 
     &                '{---' // REFUNC(1:NUMCHR) // '}' 
              ENDIF
           ELSEIF (ISCHAR(REFUNC(NUMCHR:NUMCHR)) .AND.
     &            (NUMCHR .EQ. 1 .OR. ISDIGI(REFUNC(1:1)))) THEN 
C             SYM. PARAMETER & LOOP INDEX SUBSTITUTION 
C            (E.G. <??>i OR <??>0I OR <??>0?I OR <??>0*I )
             FUNCNU(NOCHAR+1:NOCHAR+6) = 
     &            '{---' // REFUNC(NUMCHR:NUMCHR) // '}' 

          ELSE
C             COPY WHATEVER REMAINS AFTER SYMBOLIC PARAMETER
              FUNCNU(NOCHAR+1:) = REFUNC(1:)
          ENDIF

          NOCHAR = LNBLNKN(FUNCNU)
          WRITE(NUNIN,90) FUNCNU(1:NOCHAR), COMMENTFUNC

C         END SYMBOLIC PARAMETER SUBSTITUTION SECTION -----------------
          GOTO 2200
        ENDIF

C ------  ? *********** ?  PROCEDURE QUESTION EVALUATION SECTION ------
a645 6
	NUMCHR                = NUMCHR + 1
	REFUNC(NUMCHR:NUMCHR) = ' '
	IF (.NOT. FROMBATCH) THEN
C          CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS PROMPT
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'?','?',.FALSE., 
     &                  IGO,IEND,NCHARQ)
a646 136
	   WRITE(ITI,2330)  REFUNC(IGO:IEND)
2330	   FORMAT('$',A)
C          INPUT RESPONSE TO ?---? PROMPT

           READ(ITIN,2389) FUNCNU

	ELSE
C          DID NOT COME FROM INTERACTIVE MODE
C          GET RESPONSE TO ?---? PROMPT, FROM FILE
	   CLOSE(NIN)

	   OPEN(NIN,FILE=PNAMEC,STATUS='UNKNOWN')
	   DO I = 1, IWHERE
              READ(NIN,90) DUM
           ENDDO

           READ(NIN,2389) FUNCNU
2389       FORMAT(A)
           CLOSE(NIN)

           IWHERE        = IWHERE + 1
	   PSTACK(ISTOP) = IWHERE

           OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')

C          RESET INPUT FILE TO CURRNT LINE 
	   DO K = 1, IPCNT
              READ(NIN,90) DUM
           ENDDO
        ENDIF

C       FIND LAST NON-BLANK            
        NCHAR = lnblnk(FUNCNU)

	IF (FUNCNU(:1) .EQ. 'X' .OR. FUNCNU(:2) .EQ. 'X' .OR.
     &	    FUNCNU(:1) .EQ. 'x' .OR. FUNCNU(:2) .EQ. 'x') THEN
C          ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

	   CALL CHKSTR(FUNCNU,NCHAR,'RE',IDUM,FREGST,7,INUM,IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
             CALL ERRT(101,'#2 ERROR IN REGISTER SUBSTITUTION',NE)
           ENDIF

           ITEMP = MIN(INUM,6)
           WRITE(FUNCNU(1:80),2621) (FREGST(I),I=1,ITEMP)
2621       FORMAT(6(1PG12.5,' '))
           NCHAR            = INUM * 13 + 1
           FUNCNU(NCHAR:80) = ' '

        ELSE
C          MAY WANT TO SUBSTITUTE FOR REGISTERS, SEE IF NEW STYLE SUB.

           CALL CHARINSIDE(FUNCNU(1:NCHAR),'{','}',.TRUE., 
     &                     IGOSUB,IENDSUB,NSUB)

C          ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REGISTER

           IF ((NCHAR .GE. 2 .AND. ISDIGI(FUNCNU(NCHAR:NCHAR))) .AND.
     &         (FUNCNU(NCHAR-1:NCHAR-1) .EQ. 'X'  .OR. 
     &          FUNCNU(NCHAR-1:NCHAR-1) .EQ. 'x')) THEN
C              OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
               FUNCNU = FUNCNU(1:NCHAR-2) // '000{---' // 
     &                     FUNCNU(NCHAR-1:NCHAR) // '}'
               NCHAR  = NCHAR + 8
               NSUB   = 1

           ELSEIF((NCHAR .GE. 3 .AND. ISDIGI(FUNCNU(NCHAR:NCHAR))).AND.
     &            (FUNCNU(NCHAR-2:NCHAR-2) .EQ. 'X'  .OR. 
     &             FUNCNU(NCHAR-2:NCHAR-2) .EQ. 'x') .AND.
     &             ISDIGI(FUNCNU(NCHAR-1:NCHAR-1))) THEN
C              OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
               FUNCNU = FUNCNU(1:NCHAR-3) // '000{---' //
     &                  FUNCNU(NCHAR-2:NCHAR) // '}' 
               NCHAR = NCHAR + 8
               NSUB  = 1
           ENDIF

           IF (NSUB .GT. 0) THEN
C             HAVE OLD/NEW STYLE REGISTER SUBSTITUTION

C             PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C             SUBSTITUTE FOR {+++X??} OR {---X??} IN FUNCNU STRING
C             WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
              CALL FILNAMSUB(FUNCNU,NCHAR,.TRUE.,ISTOP,IRTFLG)
           ENDIF
        ENDIF

        IF ((LENQSTRQ + NCHAR + NQSTRQ + 4) .GE. MAXQSTRQ) THEN
C          OVERUN OF QSTRQ ARRAY, (I ADDED SOME SLOP FOR USE OF NQSTRQ)
	   CALL ERRT(30,'SPIDER',NE)
	   GOTO 3600
	ENDIF

C       PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
        NQSTRQ = NQSTRQ   + 1
        IQGO   = LENQSTRQ + 1

C       FIND START AND END OF PARAMETER STRING IN INPUT (IF ANY)

        ISEMICOL = INDEX(REFUNC(1:NUMCHR),';')
        IF (ISEMICOL .GT. 0) THEN
C          POSSIBLE COMMENT PRESENT, IGNORE COMMENTS AFTER ?....? 
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'?','?',.FALSE.,
     &                     IDUM,IQ2,NDUM)
           IF (ISEMICOL .GT. IQ2) NUMCHR = ISEMICOL - 1
        ENDIF
  
        CALL CHARINSIDE(REFUNC(1:NUMCHR),'<','>',.TRUE.,IP1,IP2,NCM1)

        QSTRQ(IQGO:IQGO) = '#'

        IF (NCM1 .LT. 0) THEN
C          NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRQ
           NCM1 = NUMDIG(NQSTRQ,1) - 1
           WRITE(FMT(3:3),8002) NCM1 + 1
8002       FORMAT(I1)
           WRITE(QSTRQ(IQGO+1:IQGO+NCM1+1),FMT) NQSTRQ
        ELSE
C          <#> AVAILABLE IN QUERY STRING
           NCM1 = NCM1 - 1
           QSTRQ(IQGO+1:IQGO+1+NCM1) = REFUNC(IP1:IP2)
        ENDIF
        QSTRQ(IQGO+NCM1+2:IQGO+NCM1+2)       = '#'
        QSTRQ(IQGO+NCM1+3:IQGO+NCM1+3+NCHAR) = FUNCNU(1:NCHAR)
        LENQSTRQ = LENQSTRQ + NCM1 + 3 + NCHAR + 1
        QSTRQ(LENQSTRQ:LENQSTRQ+1) = '^#'

C       NO SUBSTITUTION -- COPY FROM PROCEDURE FILE
	WRITE(NUNIN,90) FUNCNU(1:NCHAR)
90      FORMAT(A,A)
	GOTO 2200

C ------  END OF ?*******?  PROCEDURE QUESTION EVALUATION SECTION -----



a650 1

d657 1
a657 1
        ELSEIF (ISTOP .LE. 0) THEN
d691 11
a701 2
	IBCNT            = PSTACK(ISTOP)
	ISTOP            = ISTOP - 1
d703 6
a709 5

C       TAKE 'X' OUT FOR PRINTING
        ITX = INDEX(BNAME,XNUM)
	WRITE(NDAT,10080) BNAME(1:ITX-1),BNAME(ITX+4:)
10080	FORMAT(/,' END OF: ',A,A/)
d711 4
a714 5
C       SIGNAL END OF CURRENT PROCEDURE 
	IF (ISTOP .GT. 0) THEN
C          NEW BNAME IS NAME AT TOP OF STACK.
           BNAME(1:NNAME) = FSTACK(ISTOP)(1:NNAME)
	   OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')
d717 6
a722 5
C          PROCEDURE CALLED BY THIS PROCEDURE
           IF (IBCNT .EQ. 0) GOTO 5000
	   DO I=1,IBCNT
              READ(NIN, 90) DUM
           ENDDO
d726 1
a726 7
        IF (BNAME(1:1).EQ.'B' .AND. ISDIGI(BNAME(2:2))) THEN
C          LAST FILE WAS A BATCH FILE, USER FORGOT 'EN'
           CALL ERRT(101,'NO "EN"  ENCOUNTERED. TERMINATION ASSUMED',NE)
           GOTO 9999
        ENDIF

C       GO BACK TO INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
a727 1
C       REDEFINE LUNS IF INTERACTIVE USE
d736 1
a736 3
C       USE APPEND, SINCE WE WANT TO ADD ON TO FROM BEFORE
C       SAVE REGISTERS, GET THE OPTION

d748 84
a831 1
C       END SPIDER. -------------------------------------------- EX,EN
d833 87
a919 4
8900    WRITE(NOUT,*) '*** ATTEMPTED TERMINATION ASSUMED'
8400	DELETIT = FCHAR(1:4) .EQ. 'EN D'
        CALL ENDIT('COMPLETED',DELETIT)
	STOP '**** SPIDER NORMAL STOP ****'
d921 1
d924 1
a1199 19
C      *********************** SUBCHAR ********** (unused) ********

       SUBROUTINE SUBCHAR(INSERT,ORIGINAL,LOC,IRTFLG)

       CHARACTER *(*) INSERT, ORIGINAL

       LENI = LEN(INSERT)
       LENO = LEN(ORIGINAL)

       LENUSED = LNBLNKN(LENO)
       IF (LENI + LENUSED .GT. LENO) THEN
C         OVERFLOW
          CALL ERRT(101,'STRING OVERFLOW',NDUM)
          IRTFLG = 1
          RETURN
       ENDIF
 
       ORIGINAL(LOC+LENI:) = ORIGINAL(LOC:)
       ORIGINAL(LOC:LOC+LENI-1) = INSERT
a1200 3
       IRTFLG = 0
       RETURN
       END
d1203 1
a1203 1
       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,ILOCSEMI)
@


1.160
log
@xnum in common
@
text
@d199 1
a200 1
	NUMBITS=NUMBITS/BIT_SIZE(ILOOP)
@


1.159
log
@reverted to pre procX version
@
text
@d111 1
a111 1
	CHARACTER * 4         LOGM,LABEL,FMT,XNUM
d121 2
a122 1
        COMMON /DRIV1_COM/ T1,LOOPREG
@


1.158
log
@polar_cc & topalar
@
text
@d21 1
a29 2
C                   NDOC     4
C                   NINTMP   2
a39 3
C       NNAME     LENGTH OF PROCEDURE FILENAMES IN CHARACTERS
        PARAMETER (NNAME=80)

d42 1
a42 4
	PARAMETER (MAXPRC = 20) 

C	MAXIMUM NUMBER OF  DIFFERENT PROCEDURE FILES USED IN A RUN
	PARAMETER (MAXPRCNAM = 40) 
d48 3
d52 4
a55 1
	PARAMETER (NMENU1 = 9) 
d66 3
d87 2
d90 3
a92 2
	INTEGER   IPSTACK(MAXPRC)
	INTEGER   IDOSTK(6,MAXPRC),NARGSREC(MAXPRC),LOOPSV(7,MAXPRC)
a93 1
        REAL      FREGST(7)
a95 1
        LOGICAL   USEELSE(MAXPRC)
d98 2
a99 1
        CHARACTER *(NNAME)    PNAMEM,PNAME
d101 2
a102 2
        CHARACTER *(NNAME)    RESULT,LOG
        CHARACTER *(NNAME)    PNAMESTACK(MAXPRC),PNAMECALLER
d104 2
a105 2
        CHARACTER *160        MESG,RESPONSE
        CHARACTER *80         COMMENTFUNC,FRPROMPT,PLINE,CLINE
d107 2
d111 2
a112 4
        CHARACTER * 7         RESULM
	CHARACTER * 4         LABEL,FMT,CXNUM
	CHARACTER * 3         LOGM
        CHARACTER * 2         MENU1(NMENU1)
a135 7
        CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) ::  QSTRQSTK
        CHARACTER(LEN=MAXQSTR)                ::  QSTRQ
        INTEGER, DIMENSION (NQSTRSIZ,MAXPRC)  ::  IGOQSTRSTK,IENDQSTRSTK
        INTEGER, DIMENSION (NQSTRSIZ)         ::  IGOQSTR,IENDQSTR
        INTEGER, DIMENSION (MAXPRC)           ::  NQSTRNOWSTK,LENQSTRSTK
        COMMON /QSTR_STUFF/ IGOQSTR,IENDQSTR,NQSTRNOW,QSTRQ

d139 1
a139 1
        DATA CVERS/'VERSION:  UNIX  6.40  ISSUED: 09/18/2000'/ 
d146 1
a146 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO','FR','RR'/
d150 2
a151 2
	DATA RESULM/'results'/
	DATA LOGM/'LOG'/
d154 1
a154 1
        DATA NDISK/1/,LUNDO/300/,NINTMP/2/
d193 2
d235 6
a240 6
 
C       SET INITIAL SYMBOLIC PARAMETER INFO 
	LENQSTR  = 0
        NQSTRNOW = 0
        QSTRQ    = ' '
      
d291 1
a291 1
        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,CXNUM)
d414 2
a415 4
C           OP:    EN,   DO,   LB,   EX,    RE,    IF,    GO
            GOTO(8400, 8600, 8800, 8900, 10000, 10800, 10800,
     &           8500, 8500),IFUNC
C           OP:    FR,   RR
d433 17
a449 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ START PROCEDURE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d451 2
a452 1
5600    CONTINUE
d454 1
a454 2
C       SET FLAG FOR PROCEDURE/INTERACTIVE MODE WHEN PROCEDURE WAS CALLED
        FROMBATCH = (COPT .EQ. 'B')
d456 1
a456 1
C       FIND FIRST CHARACTER IN FILENAME
d466 2
a467 2
C       PNAME IS TEMP NAME TO SEE WHERE PROCEDURE FILE EXISTS
        PNAMEM = FCHAR(NFSTRT:NCHAR) // NULL
d470 1
a470 1
        CALL FILNAMANDEXT(PNAMEM,PRJEXC,PNAME,NPNAME,.TRUE.,IER)
d472 5
d479 1
a479 1
	INQUIRE(FILE=PNAME,EXIST=EX)
d482 1
a482 1
          WRITE(NOUT,9045) PNAME 
d489 1
a489 1
          CALL MYGETENV('SPPROC_DIR',PNAME,NCHART,
d492 2
a493 2
          NCHARTN = LNBLNKN(PNAMEM)
          PNAME = PNAME(:NCHART) // PNAMEM(:NCHARTN) // '.sys'// NULL
d495 1
a495 1
          INQUIRE(FILE=PNAME,EXIST=EX)
d498 1
a498 1
5800        MESG = 'PROCEDURE FILE.SYS DOES NOT EXIST: ' // PNAME 
d515 1
d517 1
a517 1
        PNAMESTACK(ISTOP)   = PNAME
a529 14
C       SAVE SYMBOLIC PARAMETER INFO FOR CALLING PROCEDURE 
        QSTRQSTK(ISTOP)    = QSTRQ
        NQSTRNOWSTK(ISTOP) = NQSTRNOW
        LENQSTRSTK(ISTOP)  = LENQSTR
        DO I = 1,NQSTRNOW
           IGOQSTRSTK(I,ISTOP)  = IGOQSTR(I)
           IENDQSTRSTK(I,ISTOP) = IENDQSTR(I)
        ENDDO

C       RE-SET SYMBOLIC PARAMETER INFO FOR NEW PROCEDURE
	LENQSTR  = 0
        NQSTRNOW = 0
        QSTRQ    = ' '

d546 3
a548 1
	IPSTACK(ISTOP) = IBCNT
d550 1
a550 5
C       PNAMECALLER IS LAST USED PROCEDURE FILE-NEEDED FOR 
C       SOLICITATIONS IN OPERATION "FR".  
	IF (ISTOP .GT. 1) THEN
           PNAMECALLER = PNAMESTACK(ISTOP-1)
C          SET LINE OFFSET IN CALLER FOR USE IN SOLICITATIONS
d565 1
a565 1
	WRITE(NDAT, 6380) PNAME(1:NPNAME)
d571 6
a576 1
C       SET ALL THE LUNS & CURRENT POCEDURE LINE COUNTER
a579 4
        IBCNT = 0

C       CLOSE THE LOG FILE IF INTERACTIVE,
	IF (NPROC .NE. 0) CLOSE(NPROC)
a581 1
C       CLOSE THE PREVIOUS PROCEDURE
d583 1
a583 2
C       OPEN NEW PROCEDURE FILE.
	OPEN(NIN,FILE=PNAME,STATUS='UNKNOWN')
a584 1
C       LIST PROCEDURE FILE ON FIRST CALL ONLY.
d588 1
a588 1
           IF (PNAME .EQ. PROCFL(L1)(:NNAME)) THEN
d591 2
a592 1
          ENDIF
d596 1
a596 1
           IF (N_VERBOSE .EQ. 1) THEN
d600 1
d602 1
a602 1
                 READ(NIN,3950,IOSTAT=IERR) PLINE
d606 1
a606 1
	         WRITE(NDAT,3960) IPCARD, PLINE
d620 1
a620 1
           PROCFL(NUMPRC)(:NNAME) = PNAME
d623 10
d636 6
a641 10
        READ(NIN,90,IOSTAT=IERR) PLINE
        IF (IERR .NE. 0) THEN
           CALL ERRT(101,'*** COULD NOT READ FIRST LINE OF PROC.',NDUM)
           GOTO 10000
        ENDIF
        IBCNT = IBCNT + 1
	IF (PLINE(:1) .EQ. '[' .AND. 
     &     (PLINE(2:2) .EQ. 'X' .OR. PLINE(2:2) .EQ. 'x') .AND.
     &      ISDIGI(PLINE(3:3))) THEN
          PLINE(2:2) = 'X'
d644 2
a645 2
          NUMCHR = lnblnk(PLINE)
	  CALL FROMTOQ(PLINE,NUMCHR,IARGSREC(1,ISTOP),NARGREG1,NPARG)
d656 1
d663 8
d674 207
a880 1
          IBCNT = IBCNT - 1
d883 41
a923 1
	GOTO 5000
d930 1
d971 2
a972 22

C       RETRIEVE PROCEDURE INFO FROM LOWER PROCEDURE LEVEL
	IBCNT            = IPSTACK(ISTOP)

C       RETRIEVE SYMBOLIC PARAMETER INFO FROM LOWER PROCEDURE LEVEL 
        QSTRQ    = QSTRQSTK(ISTOP)
        NQSTRNOW = NQSTRNOWSTK(ISTOP) 
        LENQSTR  = LENQSTRSTK(ISTOP) 
        DO I = 1,NQSTRNOW
           IGOQSTR(I)  = IGOQSTRSTK(I,ISTOP)  
           IENDQSTR(I) = IENDQSTRSTK(I,ISTOP) 
        ENDDO

	ISTOP     = ISTOP - 1
        FROMBATCH = ISTOP .GT. 1

C       RETRIEVE PNAMECALLER INFO FROM LOWER PROCEDURE LEVEL 
	IF (ISTOP .GT. 1) THEN
           PNAMECALLER = PNAMESTACK(ISTOP)
        ENDIF

C       SET CURRENT LOOPREG IN THIS PROCEDURE.
d974 1
d976 5
a981 6
	WRITE(NDAT,10080) PNAME
10080	FORMAT(/,' END OF: ',A/)

C       CLOSE CURRENT PROCEDURE FILE
	CLOSE(NIN)
          
d983 3
a985 3
C          NEW PROCEDURE NAME IS NOW PNAME AT TOP OF STACK.
           PNAME(1:NNAME) = PNAMESTACK(ISTOP)(1:NNAME)
	   OPEN(NIN,FILE=PNAME,STATUS='UNKNOWN')
d988 5
a992 6
C          PROCEDURE PRIOR TO CALLING A CHILD PROCEDURE
           IF (IBCNT .GT. 0) THEN
	      DO I=1,IBCNT
                 READ(NIN, 90) DUM
              ENDDO
           ENDIF
d996 7
a1002 1
C       INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
d1004 1
d1013 3
a1015 1
C       USE APPEND FOR LOG FILE, SINCE WE WANT TO ADD ON TO FROM BEFORE
a1033 1
C       FR (SYMBOLIC PARAMETER SETTING ) -------------------------- FR
a1034 147
C     GET "-----? STRING
8500  CALL RDPR('SYMBOLIC PARAMETER PROMPT & NUMBER',NUMCHR,FRPROMPT,
     &          .FALSE.,.TRUE.,IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 5000
      IF (NECHO .NE. 0) WRITE(NECHO,90) FRPROMPT(1:NUMCHR)
      IF (NPROC .NE. 0) WRITE(NPROC,90) FRPROMPT(1:NUMCHR)

      ISEMICOL = INDEX(FRPROMPT(1:NUMCHR),';')
      IF (ISEMICOL .GT. 0) THEN
C        POSSIBLE COMMENT PRESENT, IGNORE COMMENTS AFTER ?....? 
         CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'?','?',.FALSE.,
     &                     IDUM,IQ2,NDUM)
         IF (ISEMICOL .GT. IQ2) NUMCHR = ISEMICOL - 1
      ENDIF

      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'?','?',.FALSE., 
     &                   IGO,IEND,NCHARQ)
      IF (IGO .LE. 0) GOTO 5000

C     GET RESPONSE TO ?---? FRPROMPT
      IF (.NOT. FROMBATCH) THEN
C        CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS FRPROMPT

         WRITE(ITI,2330)  FRPROMPT(IGO:IEND)
2330     FORMAT('$',A)
         READ(ITIN,90) RESPONSE

      ELSE
C        NOT FROM INTERACTIVE MODE
C        GET RESPONSE TO ?---? FRPROMPT, FROM FILE
         OPEN(NINTMP,FILE=PNAMECALLER,STATUS='UNKNOWN') 
         DO I = 1, IWHERE + 1
            READ(NINTMP,90) RESPONSE
90          FORMAT(A)
         ENDDO
         CLOSE(NINTMP)

         IPSTACK(ISTOP) = IWHERE + 1
      ENDIF

C     FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
      CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)           

      IF (RESPONSE(:1) .EQ. 'X' .OR. RESPONSE(2:2) .EQ. 'X' .OR.
     &    RESPONSE(:1) .EQ. 'x' .OR. RESPONSE(2:2) .EQ. 'x') THEN
C         ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

         CALL CHKSTR(RESPONSE,NCHAR,'RE',IDUM,FREGST,7,INUM,IRTFLG)
         IF (IRTFLG .NE. 0) CALL ERRT(101,'ERROR IN REGISTER SUB.',NE)

C        FIX PRECISION ERROR HERE!!!!!
         ITEMP = MIN(INUM,6)
         WRITE(RESPONSE(1:80),2621) (FREGST(I),I=1,ITEMP)
2621     FORMAT(6(1PG12.5,' '))
         NCHAR            = INUM * 13 + 1
         RESPONSE(NCHAR:) = ' '

      ELSE
C        MAY WANT TO SUBSTITUTE. FOR REGS, SEE IF NEW STYLE SUB.

         CALL CHARINSIDE(RESPONSE(1:NCHAR),'{','}',.TRUE., 
     &                     IGOSUB,IENDSUB,NSUB)

C        ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REG

         IF ((NCHAR .GE. 2 .AND. ISDIGI(RESPONSE(NCHAR:NCHAR))).AND. 
     &       (RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'X'  .OR. 
     &        RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'x')) THEN
C           OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-2) // '000{---' // 
     &                 RESPONSE(NCHAR-1:NCHAR) // '}'
            NCHAR  = NCHAR + 8
            NSUB   = 1

         ELSEIF((NCHAR .GE. 3 .AND. 
     &           ISDIGI(RESPONSE(NCHAR:NCHAR))).AND.
     &          (RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'X'  .OR. 
     &           RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'x') .AND.
     &           ISDIGI(RESPONSE(NCHAR-1:NCHAR-1))) THEN
C           OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-3) // '000{---' //
     &                 RESPONSE(NCHAR-2:NCHAR) // '}' 
            NCHAR = NCHAR + 8
            NSUB  = 1
         ENDIF
      ENDIF

      IF (NSUB .GT. 0) THEN
C        HAVE EITHER OLD OR NEW STYLE REGISTER SUBSTITUTION

C        PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C        SUBSTITUTE FOR {+++X??} OR {---X??} IN RESPONSE STRING
C        WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
         CALL FILNAMSUB(RESPONSE,NCHAR,.TRUE.,ISTOP,IRTFLG)
      ENDIF

C     FIND START AND END OF PARAMETER STRING IN INPUT (IF ANY)
      CALL CHARINSIDE(FRPROMPT(1:NUMCHR),'<','>',.TRUE.,IP1,IP2,NCM1)

      IF (IP1 .LE. 0) THEN  
C        NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRNOW
         NQSTR = NQSTRNOW + 1
      ELSE
C        <#> IS AVAILABLE IN QUERY STRING
         READ(FRPROMPT(IP1:IP2),93,IOSTAT=IRTFLG) NQSTR
93       FORMAT(I10)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(101,'UNABLE TO READ PARAMETER NUMBER',NDUM)
            GOTO 5000
         ENDIF
      ENDIF

      IF ((LENQSTR + NCHAR) .GT. MAXQSTR) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(30,'SPIDER',NE)
         GOTO 10000
      ELSEIF (NQSTR .GE. NQSTRSIZ) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(102,'NQSTRSIZ OVERFLOW OF SYMBOLIC PARAMETERS',
     &                NQSTR)
         GOTO 10000
      ENDIF

C     PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
      IGOQSTR(NQSTR)  = LENQSTR + 1
      LENQSTR         = LENQSTR + NCHAR 
      IENDQSTR(NQSTR) = LENQSTR
      QSTRQ(IGOQSTR(NQSTR):IENDQSTR(NQSTR)) = RESPONSE(1:NCHAR)
      IF (NQSTR .GT. NQSTRNOW) NQSTRNOW = NQSTR

      IF (FCHAR(4:4) .EQ. 'T') THEN
C        TEST OF FILENAME SUBSTITUTION MECHANISM
         IRTFLG = -999
         CALL RDPRMC(CLINE,NLET2,.FALSE.,'CORRECT NAME',NULL,IRTFLG)
         IF (IRTFLG .EQ. 0 .AND. 
     &       RESPONSE(1:NCHAR) .NE. CLINE(1:NLET2)) THEN
            WRITE(NOUT,*) '*** ERROR IN FILENAME FORMATION!!!'
            WRITE(NOUT,9065) RESPONSE(1:NCHAR),CLINE(1:NLET2)
9065        FORMAT( '*** GOT: ',A,'  SHOULD BE: ',A/)
            CALL ERRT(100,' ',NE)
         ENDIF
      ELSEIF (FCHAR(1:2) .EQ. 'RR') THEN
C        RR  SUBSTITUTION
         RESPONSE(1:NCHAR+1) = '~' // RESPONSE(1:NCHAR)
         CALL READRQ(RESPONSE)
      ENDIF
C     END OF ?*******?  PROCEDURE QUESTION EVALUATION SECTION 
a1035 4
      GOTO 5000



d1311 19
d1331 3
@


1.157
log
@Bpname changes
@
text
@d594 1
a594 1
           IF (N_VERBOSE .EQ. 1 .AND. LISTIT) THEN
d628 1
a628 1

d656 1
d752 1
a752 1
C       GO BACK TO INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
d820 1
a820 2
         IWHERE         = IWHERE + 1
         IPSTACK(ISTOP) = IWHERE
@


1.156
log
@*X. file input shorten line lenght some
@
text
@a20 1
C                   NUNIN    7                               B*X FILE  *
d29 2
d41 3
d46 4
a49 1
	PARAMETER (MAXPRC    = 20) 
a54 3
C	MAXIMUM NUMBER OF  PROCEDURE NAMES USED IN A RUN
	PARAMETER (MAXPRCNAM = 40) 

d56 1
a56 4
	PARAMETER (NMENU1 = 7) 

C	SIZE OF ARRAY FOR STORING PROCEDURE PARAMETER INPUT
	PARAMETER (MAXQSTRQ=2000)  
a66 3
C       NNAME     LENGTH OF PROCEDURE FILENAMES IN BYTES
        PARAMETER (NNAME=80)

a84 2
	REAL      PSTACK(MAXPRC)
        LOGICAL   USEELSE(MAXPRC)
d86 3
a88 2
	INTEGER   IDOSTK(6,MAXPRC),NARGSREC(MAXPRC)
	INTEGER   LOOPSV(7,MAXPRC)
a89 1
	INTEGER   IARGSENT(NPARG,MAXPRC),IARGSREC(NPARG,MAXPRC)
d92 1
d95 1
a95 2
	CHARACTER *(MAXQSTRQ) QSTRQ
        CHARACTER *(NNAME)    TNAMEM,TNAME
d97 2
a98 2
        CHARACTER *(NNAME)    RESULT,LOG,BNAME
        CHARACTER *(NNAME)    FSTACK(MAXPRC),PNAMEC
d100 2
a101 2
        CHARACTER *160        MESG,FUNCNU
        CHARACTER *80         REFUNC,TREFUNC,COMMENTFUNC
a102 2
        CHARACTER * 2         MENU1(NMENU1)
        CHARACTER * 8         RESULM
d105 4
a108 2
	CHARACTER * 4         LOGM,LABEL,FMT,XNUM
        CHARACTER * 2         LABLSV(MAXPRC)
d132 7
d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  6.38  ISSUED: 09/06/2000'/ 
d149 1
a149 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF','GO'/
d153 2
a154 2
	DATA RESULM/'results '/
	DATA LOGM/'LOG '/
d157 1
a157 1
        DATA NUNIN/7/,NDISK/1/,LUNDO/300/
a195 2
	RESULM(8:8) = CHAR(0)
	LOGM(4:4)   = CHAR(0)
d236 6
a241 6
       
C       INITIALIZE QSTRQ WITH '@@' CHARACTERS
        DO I = 1,MAXQSTRQ
           QSTRQ(I:I) = '@@'
        ENDDO

d292 1
a292 1
        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT,XNUM)
d415 4
a418 2
C           OP:     EN,   DO,   LB,   EX,    RE,    IF,    GO
            GOTO (8400, 8600, 8800, 8900, 10000, 10800, 10800), IFUNC
d436 1
a436 17

C       END HANDLING PROCEDURE ---------------------------------------
3600	REWIND NUNIN
	CLOSE(NIN)
	CLOSE(NUNIN)
	OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')

 	IF (LENQSTRQ .GE. 1) THEN
	   DO I = 1, LENQSTRQ
              QSTRQ(I:I) = '@@'
           ENDDO
        ENDIF
	LENQSTRQ = 0
        NQSTRQ   = 0
        GOTO 5000

C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ PROCEDURE START @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d438 1
a438 2
C       COMMAND MUST BE PROCEDURE NAME.
C       SET FLAG FOR PROCEDURE OR INTERACTIVE MODE WHEN PROCEDURE WAS CALLED
d440 2
a441 1
5600    FROMBATCH = (COPT .EQ. 'B')
d443 1
a443 1
C       FIND FIRST POSSIBLE CHARACTER IN FILENAME
d453 2
a454 2
C       TNAME IS TEMP NAME TO SEE WHERE PROCEDURE FILE EXISTS
        TNAMEM = FCHAR(NFSTRT:NCHAR) // NULL
d457 1
a457 1
        CALL FILNAMANDEXT(TNAMEM,PRJEXC,TNAME,NTNAME,.TRUE.,IER)
a458 5
C       PUT TNAME INTO BNAME, CREATE NAME OF TEMPORARY 
C       PROCEDURE FILE BY PUTTING LETTER 'XNNN' BEFORE PERIOD.
        BNAME = TNAME(1:NTNAME-4) // XNUM // 
     &          TNAME(NTNAME-3:NTNAME) // NULL

d461 1
a461 1
	INQUIRE(FILE=TNAME,EXIST=EX)
d464 1
a464 1
          WRITE(NOUT,9045) TNAME 
d471 1
a471 1
          CALL MYGETENV('SPPROC_DIR',TNAME,NCHART,
d474 2
a475 2
          NCHARTN = LNBLNKN(TNAMEM)
          TNAME = TNAME(:NCHART) // TNAMEM(:NCHARTN) // '.sys'// NULL
d477 1
a477 1
          INQUIRE(FILE=TNAME,EXIST=EX)
d480 1
a480 1
5800        MESG = 'PROCEDURE FILE.SYS DOES NOT EXIST: ' // TNAME 
a496 1
C       OK- PNAMEC IS LAST USED PROCEDURE FILE-NEEDED FOR SOLICITATIONS.  
d498 1
a498 1
6200    FSTACK(ISTOP) = BNAME
d511 14
d541 4
a544 1
	PSTACK(ISTOP) = IBCNT
d546 2
a547 3
           PNAMEC(:NNAME) = FSTACK(ISTOP-1)(:NNAME)

C          OFFSET NOW EQUAL TO POINTER
d562 1
a562 1
	WRITE(NDAT, 6380) TNAME(1:NTNAME)
d568 1
a568 6
C       SET ALL THE LUNS, AND OPEN THE PROCEDURE FILE.
C       CLOSE THE LOG FILE IF INTERACTIVE,
C       CLOSE THE PREVIOUS PROCEDURE ,
C       LIST PROCEDURE FILE ON FIRST CALL ONLY.

        IBCNT = 0
d572 4
d578 1
d580 2
a581 1
	OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')
d583 1
d587 1
a587 1
           IF (TNAME .EQ. PROCFL(L1)(:NNAME)) THEN
d590 1
a590 2
             CLOSE(NUNIN)
           ENDIF
a597 1
              IERR = 0
d599 1
a599 1
                 READ(NIN,3950,IOSTAT=IERR) REFUNC
d603 1
a603 1
	         WRITE(NDAT,3960) IPCARD, REFUNC
d617 1
a617 1
           PROCFL(NUMPRC)(:NNAME) = TNAME
a619 10
        OPEN(NUNIN,FILE=BNAME,STATUS='UNKNOWN')

C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ READING PROCEDURE LINE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C       IPCNT  IS POSITION IN CURRENT PROCEDURE
C       IWHERE IS POSITION IN PREVIOUS PROCEDURE
C       LENQSTRQ IS THE INDEX FOR THE QSTRQ ARRAY
	LENQSTRQ        = 0
        NQSTRQ          = 0
	IPCNT           = 0
d623 5
a627 1
        READ(NIN,2389,END=3600) REFUNC
d629 4
a632 4
	IF (REFUNC(:1) .EQ. '[' .AND. 
     &     (REFUNC(2:2) .EQ. 'X' .OR. REFUNC(2:2) .EQ. 'x') .AND.
     &      ISDIGI(REFUNC(3:3))) THEN
          REFUNC(2:2) = 'X'
d635 2
a636 2
          NUMCHR = lnblnk(REFUNC)
	  CALL FROMTOQ(REFUNC,NUMCHR,IARGSREC(1,ISTOP),NARGREG1,NPARG)
a646 1

a652 8
C         PUT SEMICOLON IN FRONT OF DUMMY ARGUMENT LIST => COMMENT NOW
          REFUNC(1:NUMCHR+1) = ';' // REFUNC(1:NUMCHR)

C         COPY THIS NEW COMMENT TO OUTPUT FILE THEN READ NEXT LINE
          WRITE(NUNIN,2301) REFUNC

C         IPCNT INCREMENT NEEDED BELOW
	  IPCNT  = IPCNT + 1
a655 1
 
d658 1
a658 116

2200    READ(NIN,2389,END=3600) REFUNC

C       FIND LAST NON-BLANK BEFORE ANY COMMENT
        CALL DECOMMENT(REFUNC,NUMCHR,ILOCSEMI)

C       PRESERVE COMMENT
        COMMENTFUNC = ' '  
        IF (ILOCSEMI .GT. 0) COMMENTFUNC = REFUNC(ILOCSEMI:)
           
C       INCREMENT NUMBER OF LINES IN PROCEDURE
	IPCNT  = IPCNT + 1

        FUNCNU(1:160) = ' '

        IF (REFUNC(1:1) .NE. '?') THEN
C          NOT PROCEDURE QUESTION, SEE IF SYMBOLIC SUB. NEEDED

C          FIND START AND END OF PARAMETER STRING IN INPUT 
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'<','>',.FALSE.,
     &                        IP1,IP2,NCT)

           IF (IP1 .LE. 0 .OR. IP2 .LE. IP1 .OR. 
     &        .NOT. ISDIGI(REFUNC(IP1+1:IP1+1))) THEN
C             NO SYMBOLIC SUBSTITUTION, COPY ENTIRE REFUNC STRING

C             CHANGE 'do lb' TO UPPERCASE TO SPEED UP LOOPS IN SEARCHQ
              TREFUNC = REFUNC
              CALL SSUPCAS(TREFUNC(1:NUMCHR))
              IGO = INDEX(TREFUNC(1:NUMCHR),'DO LB')
              IF (IGO .GT. 0) THEN
                 WRITE(NUNIN,2301) TREFUNC(1:NUMCHR)
              ELSE     
                 WRITE(NUNIN,2301) REFUNC(1:NUMCHR)
2301             FORMAT(A)
              ENDIF

              GOTO 2200
           ENDIF

C          '<' AND DIGIT => SYMBOLIC PARAMETER SUBSTITUTION NEEDED ----

C          SCAN THE QSTRQ ARRAY TO FIND STRING FOR SUBSTITUTION.
           TREFUNC          = REFUNC
           TREFUNC(IP1:IP1) = '#'
           TREFUNC(IP2:IP2) = '#'
           IPQ1             = INDEX(QSTRQ(1:LENQSTRQ),TREFUNC(IP1:IP2))

           IF (IPQ1 .LE. 0) THEN
C             UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER  
              WRITE(NDAT,*) 'CAN NOT FIND SYMBOLIC REFERENCE FOR: ',
     &                  REFUNC(IP1:IP2)
              WRITE(NDAT,*) '  ' 
              WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES ARE:---------'
              WRITE(NDAT,2301) QSTRQ(1:LENQSTRQ)

              CALL ERRT(100,'SPIDER',NE)
C             STOPS IN ERRT!!
	      GOTO 9999
           ENDIF

C          COPY STRING BEFORE < (IF ANY) INTO FUNCNU
           IF (IP1 .GT. 1) FUNCNU(1:IP1-1) = REFUNC(1:IP1-1)

C          FIND THIS PARAMETER NUMBER IN QSTRQ, THEN
C          COPY CORRESPONDING QSTRQ STRING TO FUNCNU
           NGO     = INDEX(QSTRQ(IPQ1+1:LENQSTRQ),'#') + IPQ1 + 1
           NEND    = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 3
           NOCHAR  = NEND - NGO + 1

           FUNCNU(IP1:NOCHAR+IP1) = QSTRQ(NGO:NEND)
           NOCHAR                 = NOCHAR + IP1 - 1

C          STRIP THE PARAMETER STUFF FROM REFUNC STRING (FOR SIMPLICITY)       
           REFUNC(1:) = REFUNC(IP2+1:NUMCHR)
           NUMCHR     = NUMCHR - IP2 

C          HANDLE REGISTER OR INDEX AFTER <?>
	   IF (REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x') THEN
              IEND = VERIFY(REFUNC(2:NUMCHR),'0123456789')
              IF (IEND .EQ. 0) THEN
C                SYM. PARAMETER & REG. SUBSTITUTION (<??>X? OR <?>X??..) 
                 FUNCNU(NOCHAR+1:NOCHAR+NUMCHR+5) = 
     &                '{---' // REFUNC(1:NUMCHR) // '}' 
              ENDIF
           ELSEIF (ISCHAR(REFUNC(NUMCHR:NUMCHR)) .AND.
     &            (NUMCHR .EQ. 1 .OR. ISDIGI(REFUNC(1:1)))) THEN 
C             SYM. PARAMETER & LOOP INDEX SUBSTITUTION 
C            (E.G. <??>i OR <??>0I OR <??>0?I OR <??>0*I )
             FUNCNU(NOCHAR+1:NOCHAR+6) = 
     &            '{---' // REFUNC(NUMCHR:NUMCHR) // '}' 

          ELSE
C             COPY WHATEVER REMAINS AFTER SYMBOLIC PARAMETER
              FUNCNU(NOCHAR+1:) = REFUNC(1:)
          ENDIF

          NOCHAR = LNBLNKN(FUNCNU)
          WRITE(NUNIN,90) FUNCNU(1:NOCHAR), COMMENTFUNC

C         END SYMBOLIC PARAMETER SUBSTITUTION SECTION -----------------
          GOTO 2200
        ENDIF

C ------  ? *********** ?  PROCEDURE QUESTION EVALUATION SECTION ------

	NUMCHR                = NUMCHR + 1
	REFUNC(NUMCHR:NUMCHR) = ' '
	IF (.NOT. FROMBATCH) THEN
C          CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS PROMPT
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'?','?',.FALSE., 
     &                  IGO,IEND,NCHARQ)

	   WRITE(ITI,2330)  REFUNC(IGO:IEND)
2330	   FORMAT('$',A)
C          INPUT RESPONSE TO ?---? PROMPT
a659 1
           READ(ITIN,2389) FUNCNU
a660 130
	ELSE
C          DID NOT COME FROM INTERACTIVE MODE
C          GET RESPONSE TO ?---? PROMPT, FROM FILE
	   CLOSE(NIN)

	   OPEN(NIN,FILE=PNAMEC,STATUS='UNKNOWN')
	   DO I = 1, IWHERE
              READ(NIN,90) DUM
           ENDDO

           READ(NIN,2389) FUNCNU
2389       FORMAT(A)
           CLOSE(NIN)

           IWHERE        = IWHERE + 1
	   PSTACK(ISTOP) = IWHERE

           OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')

C          RESET INPUT FILE TO CURRNT LINE 
	   DO K = 1, IPCNT
              READ(NIN,90) DUM
           ENDDO
        ENDIF

C       FIND LAST NON-BLANK            
        NCHAR = lnblnk(FUNCNU)

	IF (FUNCNU(:1) .EQ. 'X' .OR. FUNCNU(:2) .EQ. 'X' .OR.
     &	    FUNCNU(:1) .EQ. 'x' .OR. FUNCNU(:2) .EQ. 'x') THEN
C          ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

	   CALL CHKSTR(FUNCNU,NCHAR,'RE',IDUM,FREGST,7,INUM,IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
             CALL ERRT(101,'#2 ERROR IN REGISTER SUBSTITUTION',NE)
           ENDIF

           ITEMP = MIN(INUM,6)
           WRITE(FUNCNU(1:80),2621) (FREGST(I),I=1,ITEMP)
2621       FORMAT(6(1PG12.5,' '))
           NCHAR            = INUM * 13 + 1
           FUNCNU(NCHAR:80) = ' '

        ELSE
C          MAY WANT TO SUBSTITUTE FOR REGISTERS, SEE IF NEW STYLE SUB.

           CALL CHARINSIDE(FUNCNU(1:NCHAR),'{','}',.TRUE., 
     &                     IGOSUB,IENDSUB,NSUB)

C          ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REGISTER

           IF ((NCHAR .GE. 2 .AND. ISDIGI(FUNCNU(NCHAR:NCHAR))) .AND.
     &         (FUNCNU(NCHAR-1:NCHAR-1) .EQ. 'X'  .OR. 
     &          FUNCNU(NCHAR-1:NCHAR-1) .EQ. 'x')) THEN
C              OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
               FUNCNU = FUNCNU(1:NCHAR-2) // '000{---' // 
     &                     FUNCNU(NCHAR-1:NCHAR) // '}'
               NCHAR  = NCHAR + 8
               NSUB   = 1

           ELSEIF((NCHAR .GE. 3 .AND. ISDIGI(FUNCNU(NCHAR:NCHAR))).AND.
     &            (FUNCNU(NCHAR-2:NCHAR-2) .EQ. 'X'  .OR. 
     &             FUNCNU(NCHAR-2:NCHAR-2) .EQ. 'x') .AND.
     &             ISDIGI(FUNCNU(NCHAR-1:NCHAR-1))) THEN
C              OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
               FUNCNU = FUNCNU(1:NCHAR-3) // '000{---' //
     &                  FUNCNU(NCHAR-2:NCHAR) // '}' 
               NCHAR = NCHAR + 8
               NSUB  = 1
           ENDIF

           IF (NSUB .GT. 0) THEN
C             HAVE OLD/NEW STYLE REGISTER SUBSTITUTION

C             PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C             SUBSTITUTE FOR {+++X??} OR {---X??} IN FUNCNU STRING
C             WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
              CALL FILNAMSUB(FUNCNU,NCHAR,.TRUE.,ISTOP,IRTFLG)
           ENDIF
        ENDIF

        IF ((LENQSTRQ + NCHAR + NQSTRQ + 4) .GE. MAXQSTRQ) THEN
C          OVERUN OF QSTRQ ARRAY, (I ADDED SOME SLOP FOR USE OF NQSTRQ)
	   CALL ERRT(30,'SPIDER',NE)
	   GOTO 3600
	ENDIF

C       PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
        NQSTRQ = NQSTRQ   + 1
        IQGO   = LENQSTRQ + 1

C       FIND START AND END OF PARAMETER STRING IN INPUT (IF ANY)

        ISEMICOL = INDEX(REFUNC(1:NUMCHR),';')
        IF (ISEMICOL .GT. 0) THEN
C          POSSIBLE COMMENT PRESENT, IGNORE COMMENTS AFTER ?....? 
           CALL CHARINSIDE(REFUNC(1:NUMCHR),'?','?',.FALSE.,
     &                     IDUM,IQ2,NDUM)
           IF (ISEMICOL .GT. IQ2) NUMCHR = ISEMICOL - 1
        ENDIF
  
        CALL CHARINSIDE(REFUNC(1:NUMCHR),'<','>',.TRUE.,IP1,IP2,NCM1)

        QSTRQ(IQGO:IQGO) = '#'

        IF (NCM1 .LT. 0) THEN
C          NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRQ
           NCM1 = NUMDIG(NQSTRQ,1) - 1
           WRITE(FMT(3:3),8002) NCM1 + 1
8002       FORMAT(I1)
           WRITE(QSTRQ(IQGO+1:IQGO+NCM1+1),FMT) NQSTRQ
        ELSE
C          <#> AVAILABLE IN QUERY STRING
           NCM1 = NCM1 - 1
           QSTRQ(IQGO+1:IQGO+1+NCM1) = REFUNC(IP1:IP2)
        ENDIF
        QSTRQ(IQGO+NCM1+2:IQGO+NCM1+2)       = '#'
        QSTRQ(IQGO+NCM1+3:IQGO+NCM1+3+NCHAR) = FUNCNU(1:NCHAR)
        LENQSTRQ = LENQSTRQ + NCM1 + 3 + NCHAR + 1
        QSTRQ(LENQSTRQ:LENQSTRQ+1) = '^#'

C       NO SUBSTITUTION -- COPY FROM PROCEDURE FILE
	WRITE(NUNIN,90) FUNCNU(1:NCHAR)
90      FORMAT(A,A)
	GOTO 2200

C ------  END OF ?*******?  PROCEDURE QUESTION EVALUATION SECTION -----



a664 1

d705 22
a726 2
	IBCNT            = PSTACK(ISTOP)
	ISTOP            = ISTOP - 1
d728 6
a734 5

C       TAKE 'X' OUT FOR PRINTING
        ITX = INDEX(BNAME,XNUM)
	WRITE(NDAT,10080) BNAME(1:ITX-1),BNAME(ITX+4:)
10080	FORMAT(/,' END OF: ',A,A/)
a735 1
C       SIGNAL END OF CURRENT PROCEDURE 
d737 3
a739 3
C          NEW BNAME IS NAME AT TOP OF STACK.
           BNAME(1:NNAME) = FSTACK(ISTOP)(1:NNAME)
	   OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')
d742 6
a747 5
C          PROCEDURE CALLED BY THIS PROCEDURE
           IF (IBCNT .EQ. 0) GOTO 5000
	   DO I=1,IBCNT
              READ(NIN, 90) DUM
           ENDDO
a750 6
        IF (BNAME(1:1).EQ.'B' .AND. ISDIGI(BNAME(2:2))) THEN
C          LAST FILE WAS A BATCH FILE, USER FORGOT 'EN'
           CALL ERRT(101,'NO "EN"  ENCOUNTERED. TERMINATION ASSUMED',NE)
           GOTO 9999
        ENDIF

a752 1
C       REDEFINE LUNS IF INTERACTIVE USE
d761 1
a761 3
C       USE APPEND, SINCE WE WANT TO ADD ON TO FROM BEFORE
C       SAVE REGISTERS, GET THE OPTION

d780 1
d782 148
d931 4
a1209 19
C      *********************** SUBCHAR ********** (unused) ********

       SUBROUTINE SUBCHAR(INSERT,ORIGINAL,LOC,IRTFLG)

       CHARACTER *(*) INSERT, ORIGINAL

       LENI = LEN(INSERT)
       LENO = LEN(ORIGINAL)

       LENUSED = LNBLNKN(LENO)
       IF (LENI + LENUSED .GT. LENO) THEN
C         OVERFLOW
          CALL ERRT(101,'STRING OVERFLOW',NDUM)
          IRTFLG = 1
          RETURN
       ENDIF
 
       ORIGINAL(LOC+LENI:) = ORIGINAL(LOC:)
       ORIGINAL(LOC:LOC+LENI-1) = INSERT
a1210 3
       IRTFLG = 0
       RETURN
       END
@


1.155
log
@version up, NTN removed, REFUNC loop rewritten with DO
@
text
@d708 1
a708 1
                 WRITE(NUNIN,2301) TREFUNC
d710 2
a711 2
                 WRITE(NUNIN,2301) REFUNC
2301             FORMAT(A80)
d774 2
a775 1
          WRITE(NUNIN,90) FUNCNU,COMMENTFUNC
@


1.154
log
@merged batches & procedures
@
text
@a53 3
C	MAX. LENGTH OF PROC. NAME PLUS ONE TERMINATING NULL CHARACTER 
	PARAMETER (NTN = 80)     

d99 1
a99 1
        CHARACTER *(NTN)      TNAMEM,TNAME
d139 1
a139 1
        DATA CVERS/'VERSION:  UNIX  6.38  ISSUED: 09/05/2000'/ 
d569 1
a569 1
	IF (FCHAR(2:2) .LT. 'A')  CALL REG_SET(9,0.0,.TRUE.,IRTFLG)
d573 1
a573 1
C       CLOSE THE PREVIOUS PROCEDURE IF IN PROCEDURE MODE,
d576 1
a576 1
1800	IBCNT = 0
d595 16
a610 12
        IF (N_VERBOSE .EQ. 1 .AND. LISTIT) THEN
C          WRITE OUT THE PROCEDURE OPERATIONS
	   IPCARD = 0
	   WRITE(NDAT,*) ' '

2050	   READ(NIN,3950,END=2080) REFUNC
3950       FORMAT(A)
	   IPCARD = IPCARD + 1
	   WRITE(NDAT,3960) IPCARD, REFUNC
3960       FORMAT(3X,I4,4X,A)
	   GOTO 2050
        ENDIF
a611 1
2080	IF (LISTIT) THEN
a623 1
        IF (N_VERBOSE .EQ. 1) WRITE(NDAT,*) ' '
@


1.153
log
@new batch temp (x.) naming scheme
@
text
@d19 1
a19 1
C  LUN ASSIGNMENTS: LUN  USUAL   SOURCE  IN BATCH    SOURCE  SINK      *
d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  6.37  ISSUED: 08/30/2000'/ 
d269 1
a269 1
C       GET DATEXC, START & RESCHEDULE BATCHES
d426 1
a426 1
C          EXPRESSION IS NO GOOD - IF BATCH, TERMINATES
d452 1
a452 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ PROCEDURE OR BATCH START @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d454 2
a455 2
C       COMMAND MUST BE PROCEDURE NAME OR BATCH FILE NAME.
C       SET FLAG FOR BATCH OR INTERACTIVE MODE WHEN PROCEDURE WAS CALLED
a458 17
C       IF THIS IS FIRST PROCEDURE CALL, OR NEW PROCEDURE IS NOT BATCH, 
C       FILE OR CURRENT PROCEDURE IS A BATCH FILE, THEN  WE'RE OK.  
C       OTHERWISE WE HAVE PROCEDURE CALLING BATCH FILE, DON'T ALLOW IT

C       FCHAR(2:2) IS DIGIT FOR BATCH FILE, A LETTER FOR PROCEDURE FILE 
	IF (ISTOP .NE. 0 .AND. 
     &      (FCHAR(1:1) .EQ. 'B' .OR. FCHAR(1:1) .EQ.'b') .AND.
     &      ISDIGI(FCHAR(2:2)) .AND. ISDIGI(FCHAR(2:2))) THEN
           IF (BNAME(1:1) .EQ. 'b' .or. BNAME(1:1) .EQ. 'B') THEN
              CALL ERRT(101,'BATCH FILE CANNOT CALL BATCH FILE',NE)
           ELSE
              CALL ERRT(101,'PROCEDURE FILE CANNOT CALL BATCH FILE',NE)
           ENDIF
C          THIS SHOULD HAVE HALTED IN ERRT!!
           GOTO 9999
        ENDIF

d475 1
a475 1
C       PUT TNAME INTO BNAME, CREATE NAME OF TEMPORARY BATCH OR
d480 1
a480 3
C       IF IT'S A BATCH FILE THE NAME IS CORRECT
C       IF NOT A BATCH FILE TRY USER'S DIRECTORY & PROJECT EXTENSION
C       PROCEDURE FILE
d484 1
a484 6
C         FILE DOESN'T EXIST - IF IT'S BATCH FILE GIVE ERROR MESSAGE
          IF (FCHAR(2:2) .LT. 'A') THEN
             MESG = 'PROCEDURE FILE DOES NOT EXIST: '// TNAME(1:NTNAME)
             CALL ERRT(101,MESG,NE)
             GOTO 5000
          ENDIF
d488 1
a488 1
C         OTHERWISE, TRY AGAIN UNDER 'PROC:*.SYS' IN PROC DIR.
a498 1

d564 1
a564 1
C         WE'RE NOW IN BATCH MODE, WRITE OUT HEADING.
d571 1
a571 1
C       RESET ERROR FLAGS FOR BATCH RUNS ONLY, SET THE LUNS
d574 1
a574 1
C       SET ALL THE LUNS, AND OPEN THE BATCH FILE.
d576 1
a576 1
C       CLOSE THE PREVIOUS BATCH OR PROCEDURE IF BATCH,
d589 8
a596 10
	IF (FCHAR(1:1).NE.'B' .AND. FCHAR(1:1).NE.'b') THEN
C          SEE IF PROCEDURE ALREADY LISTED
	   DO L1 = 1, NUMPRC 
              IF (TNAME .EQ. PROCFL(L1)(:NNAME)) THEN
C               DON'T NEED TO COPY PROC FILE INTO RESULTS FILE
                LISTIT = .FALSE.
                CLOSE(NUNIN)
              ENDIF
           ENDDO
        ENDIF
d599 1
a599 1
C          WRITE OUT THE BATCH  OR PROCEDURE OPERATIONS
d613 5
a617 7
           IF (FCHAR(1:1).NE.'B' .AND. FCHAR(1:1).NE.'b') THEN

              IF (NUMPRC .GT. MAXPRCNAM) THEN
C                TOO MANY PROCEDURE NAMES
	         CALL ERRT(21,'SPIDER',NE)
	         GOTO 5000
	      ENDIF
d619 2
a620 3
              NUMPRC = NUMPRC + 1
              PROCFL(NUMPRC)(:NNAME) = TNAME
           ENDIF
d626 1
a626 1
C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ READING PROCEDURE OR BATCH LINE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d932 1
a932 1
C       TOP OF STACK, WHICH IS CURRENT PROCEDURE OR BATCH FILE.
d979 1
a979 1
10080	FORMAT(/,' END OF: ',A,A)
d981 1
a981 1
C       SIGNAL END OF CURRENT PROCEDURE OR BATCH
d1003 1
a1003 1
C       REOPEN THE LOG FILE, SINCE IT WAS CLOSED FOR BATCH, 
d1252 1
a1252 1
C             USEELSE UNDERFLOW, WILL HALT IN BATCH MODE IN ERRT
d1256 1
a1256 1
C             USEELSE OVERFLOW, WILL HALT IN BATCH MODE IN ERRT
@


1.152
log
@reopend results file so it exists when >1 use & increased version
@
text
@d99 1
a99 1
	LOGICAL   JUMP,EX,ISDIGI,ISCHAR,DELETIT,INTHELOOP
d104 1
a104 1
        CHARACTER *(NNAME)    RESULT,LOG,LOG1,BNAME
d114 1
a114 1
	CHARACTER * 4         LOGM,LABEL,FMT
d294 1
a294 1
        CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT)
d296 1
a296 2
	IF (IER .NE. 0) 
     &     STOP '*** UNABLE TO OPEN RESULTS FILE ***'
d493 2
a494 2
C       PROCEDURE FILE BY PUTTING LETTER 'X' BEFORE PERIOD.
        BNAME = TNAME(1:NTNAME-4) // 'X' // 
d613 10
a622 24
C       IF THIS IS A PROCEDURE WITH NEW NAMING CONVENTION, THEN
C       FOLLOWING TEST FOR BATCH FILES CAN BE BYPASSED.

	IF ((FCHAR(1:1).NE.'@@') .AND.
     &      (.NOT. ISCHAR(FCHAR(1:1)) .OR. 
     &       .NOT. ISCHAR(FCHAR(2:2)) .OR. 
     &       .NOT. ISDIGI(FCHAR(3:3)))) THEN

           IF (N_VERBOSE .EQ. 1) THEN
C             LIST BATCH FILE ON NDAT IF VERBOSE
              WRITE(NDAT,*) ' '
              IBCARD = 0

C             READ EACH LINE AND PUT IN RESULTS FILE
3940          READ(NIN, 3950, END = 3980) REFUNC
3950          FORMAT(A80)
              IBCARD = IBCARD + 1
              WRITE(NDAT,3960) IBCARD,REFUNC
3960          FORMAT(3X,I4,4X,A80)
              GOTO 3940
           ENDIF

3980       REWIND NIN
           GOTO 2100
d625 2
a626 23
        IF (NUMPRC .GT. MAXPRCNAM) THEN
C          TOO MANY PROCEDURE NAMES
	   CALL ERRT(21,'SPIDER',NE)
	   GOTO 5000
	ENDIF
        
	DO L1 = 1, NUMPRC 
          IF (TNAME .EQ. PROCFL(L1)(:NNAME)) THEN
C           DELETE PREVIOUSLY USED "X" VERSION - CREATE NEW "X" VERSION
C           DON'T NEED TO COPY PROC FILE INTO RESULTS FILE

            CLOSE(NUNIN)
            CLOSE(NIN)
            OPEN(NIN,FILE=TNAME,STATUS='OLD')
            GOTO 2100
          ENDIF
        ENDDO

C       CLOSE BATCH FILE AND OPEN PROCEDURE FILE.
	CLOSE(NIN)
	OPEN(NIN,FILE=TNAME,STATUS='OLD')
        IF (N_VERBOSE .EQ. 1) THEN
C          WRITE OUT THE PROCEDURE OPERATIONS, IF VERBOSE
d631 1
d634 1
d638 14
a651 13
2080	NUMPRC = NUMPRC + 1
        PROCFL(NUMPRC)(:NNAME) = TNAME
	REWIND NIN

C       CREATE TEMPORARY PROC FILES--ADD 'X' TO BNAME

C       GENERALIZATION FOR SUBDIRECTORY USE
2100    DO ITX = NNAME,1,-1
          IF (BNAME(ITX:ITX) .EQ. '.') GOTO 2101
        ENDDO
2101    CONTINUE
        BNAME(ITX-1:ITX-1) = 'X'       
	OPEN(NUNIN,FILE=BNAME,STATUS='UNKNOWN')
d653 1
d1007 2
a1008 6
        ITX = INDEX(BNAME,'X.')
	IF (ITX .LE. 0)  ITX = INDEX(BNAME,'x.')
        ITE = INDEX(BNAME,NULL) - 1
        IF (ITE .LE. 0) ITE = LEN(BNAME)

	WRITE(NDAT,10080) BNAME(1:ITX-1),BNAME(ITX+1:ITE)
d1026 2
a1027 2
C       IF LAST FILE WAS A BATCH FILE, THEN USER FORGOT 'EN'
        IF (BNAME(13:13).EQ.'B' .AND. ISDIGI(BNAME(14:14))) THEN
d1341 1
a1341 1
C      *********************** SUBCHAR ********************************
@


1.151
log
@DEFNUMREGS added N
@
text
@d142 1
a142 1
        DATA CVERS/'VERSION:  UNIX  6.36  ISSUED: 08/09/2000'/ 
d313 8
a320 1
 
@


1.150
log
@changed reg_build parameter
@
text
@d46 1
a46 1
	PARAMETER (DEFNUMREGS = 103) 
d227 1
a227 1
        CALL REG_BUILD(DEFNUMREGS,IRTFLG)
@


1.149
log
@changes for reg_set
@
text
@d44 4
d227 3
a229 2
        CALL REG_BUILD(MAXPARAM,IRTFLG)
C       SET ERROR FLAG TO NONE
@


1.148
log
@speeded up searchq for "do lb" search in batch
@
text
@d41 1
a86 3
      
        REAL      PRAMSV(MAXPRC,MAXPARAM),CURPARAM(MAXPARAM)

d138 1
a138 1
        DATA CVERS/'VERSION:  UNIX  6.34  ISSUED: 07/31/2000'/ 
d222 2
d225 1
a225 1
	PARAM(10)  = 0
d537 1
a537 3
	DO I = 1, MAXPARAM
          PRAMSV(ISTOP,I) = PARAM(I)
        ENDDO
d586 1
a586 1
	IF (FCHAR(2:2) .LT. 'A') PARAM(10)  = 0
d707 1
d709 3
a711 1
             PARAM(IARGSREC(I,ISTOP))=PRAMSV(ISTOP,IARGSENT(I,ISTOP))
d806 5
a810 7
	   IF ((REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x').AND.
     &        ((NUMCHR .EQ. 2 .AND. ISDIGI(REFUNC(2:2))) .OR. 
     &         (NUMCHR .EQ. 3 .AND. ISDIGI(REFUNC(2:2)) .AND. 
     &                                 ISDIGI(REFUNC(3:3))))) THEN
C             SYM. PARAMETER & REGISTER SUBSTITUTION ( <??>X? OR <?>X??) 

              FUNCNU(NOCHAR+1:NOCHAR+NUMCHR+5) = 
d812 1
a812 1

d920 1
a920 5
C             PASS THE CURRENT PARAM SET TO FILNAMSUB
	      DO I=1,MAXPARAM
                 CURPARAM(I) = PRAMSV(ISTOP,I)
              ENDDO

d923 1
a923 1
              CALL FILNAMSUB(FUNCNU,NCHAR,.TRUE.,CURPARAM,IRTFLG)
d998 2
a999 1
               ARGSAV(I) = PARAM(IARGSREC(I,ISTOP))
d1004 1
a1004 3
	DO I=1,MAXPARAM
           PARAM(I) = PRAMSV(ISTOP,I)
        ENDDO
d1009 2
a1010 1
              PARAM(IARGSENT(I,ISTOP)) = ARGSAV(I)
d1023 1
a1023 1
	PARAM(LOOPREG+1) = IABSLP 
d1124 2
a1125 1
           READ(FCHAR(ILOCLIM-3:ILOCLIM-2),*,IOSTAT=IERR) LOOPREG
d1147 1
a1147 1
        PARAM(LOOPREG+1) = IABSLP
d1149 1
a1149 1
	PARAM(1)         = IABSLP
d1196 1
a1196 1
	PARAM(1) = IABSLP
d1201 1
a1201 1
             NIN      = LUNDO
d1204 2
a1205 2
          IBCNT               = 0
          PARAM(LOOPREG+1)    = IABSLP
d1240 2
a1241 2
	PARAM(1)         = IABSLP
        PARAM(LOOPREG+1) = IABSLP
d1352 2
a1353 2
	   PARAM(1)         = IABSLP
	   PARAM(LOOPREG+1) = IABSLP
@


1.147
log
@versionn update
,
@
text
@d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.33  ISSUED: 07/17/2000'/ 
a739 1
C                          1234567890123456789012345678901234567890
d752 12
a763 2
              WRITE(NUNIN,2301) REFUNC
2301          FORMAT(A80)
@


1.146
log
@version increased
@
text
@d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.32  ISSUED: 07/05/2000'/ 
@


1.145
log
@new batch calling batch error msg added
@
text
@d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.31  ISSUED: 06/13/2000'/ 
@


1.144
log
@updated version for "FD " fix
@
text
@d443 2
a444 3
C       COMMAND MUST BE OLD PROCEDURE NAME OR BATCH FILE NAME ---------
C       SET FLAG FOR BATCH OR INTERACTIVE MODE WHEN THE PROCEDURE 
C       WAS CALLED
d456 6
a461 2
           CALL ERRT(101,'PROCEDURE FILE CANNOT CALL BATCH FILE',NE)
C          THIS SHOULD ALWAYS HALT IN ERRT!!
@


1.143
log
@version
@
text
@d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.30  ISSUED: 05/26/2000'/ 
@


1.142
log
@DISTIB MAXDI CHANGED
version incremented
@
text
@d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.28  ISSUED: 04/28/2000'/ 
@


1.141
log
@SP_F90 removed
@
text
@a66 2
#ifdef SP_DISTRIB 

d71 6
a76 3
C       BELOW TO DECREASE MEMORY.  (MANY ROUTINES NOW USE RUN-TIME
C       ALLOCATION OF MEMORY WHICH IS INDEPENDENT OF THE COMMON
C       BUFFER SIZE)
a77 15
C       FOR MACHINES WITH 64 MB RAM, REQUEST LESS THAN 64 MB
CC      PARAMETER (MAXDI =15000000)

C       FOR MACHINES WITH 32 MB RAM, REQUEST LESS THAN 32 MB
        PARAMETER (MAXDI = 7000000)

C       FOR MACHINES WITH 16 MB RAM, REQUEST LESS THAN 16 MB
CC      PARAMETER (MAXDI = 3500000)

#else   
C       SPACE RESERVATION USED AT ALBANY, REQUESTS 5 MB. 
C       (MOST MEMORY HUNGRY ROUTINES NOW ALLOCATE THEIR OWN MEMORY 
C       AT RUN-TIME) WE USUALLY HAVE > 80 MB RAM AVAILABLE ON ALBANY 
C       MACHINES

a78 1
#endif
d140 1
a140 1
        DATA CVERS/'VERSION:  UNIX  6.27  ISSUED: 04/10/2000'/ 
@


1.140
log
@version incremented
@
text
@d1077 2
a1078 2
#if defined(SP_F90)
         OPEN(NPROC,FILE=LOG,STATUS='OLD',
a1079 1
#else
a1080 7
#if defined(SP_SUN4)
        OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND')
#else
        OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND',
     &       CARRIAGECONTROL='LIST')
#endif
#endif
@


1.139
log
@nalph needed on filnamsub call in op: if
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.26  ISSUED: 02/18/2000'/ 
@


1.138
log
@used filnamsub in if op
@
text
@d1301 1
a1301 1
10800   CALL FILNAMSUB(FCHAR,NLET,.FALSE.,FDUM,IER)
@


1.137
log
@increased version for bxkcq install
@
text
@d1301 4
a1304 1
10800   CALL LOGIFQ(FCHAR,LABEL,JUMP,IER)
@


1.136
log
@new version number
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.25  ISSUED: 01/10/2000'/ 
@


1.135
log
@version incremented.
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.23   ISSUED: 12/01/99 '/ 
@


1.134
log
@null changed to zero in finlbq call in else
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.22   ISSUED: 11/02/99 '/ 
@


1.133
log
@incremented version number
@
text
@d1286 1
a1286 1
	   CALL FINDLBQ('ENDIF',0,NULL,INTHELOOP,IFLEVEL,IRTFLG)
@


1.132
log
@interactive do-loop processing bugs fixed
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.20   ISSUED: 10/18/99 '/ 
a226 1

@


1.131
log
@frombatch multiply defined
@
text
@d29 1
a29 1
C                   LUNDO  300                                                                    *
a126 1
	CHARACTER * 6         CSEND
a161 1
	DATA CSEND/'SPI***'/
d170 1
a170 1
        DATA NUNIN/7/,NDISK/1/
d177 9
d189 1
a189 2
        NLOOP       = 1
        NDAT        = 3
d225 3
a227 7
C       INITIALIZE LUNS  
	NIN   = 5
	NOUT  = 6
	NECHO = NOUT
	ITI   = NOUT
	ITIN  = NIN
	NPROC = 0
d229 1
a229 1
C       INITIALIZE DO_LOOP STACK
d233 1
a235 4
        LUNDO       = 300

C       TIME TM IS ASSUMED AT BEGINNING OF RUN.  
	T1 = SECNDS(0.0)
d237 1
a237 1
C       ASSUMED MODE IS INTERACTIVE.
d333 1
d335 1
a335 2
        IF (COPT .EQ. 'I' .AND. IDO .EQ. 1 .AND. ILOOP .EQ. 1) THEN
C          MUST COPY LINE TO INTERACTIVE DO LOOP FILE IN RDPR
d337 11
a347 1
        ENDIF
d400 2
a401 2
	IF ((FCHAR(1:2).EQ.'LB' .OR. (FCHAR(1:2).EQ.'lb')) .AND. 
     &       IDO.EQ.1) GOTO 8800
d404 2
a405 2
	IF ((FCHAR(1:2).EQ.'LB' .OR. (FCHAR(1:2).EQ.'lb')) .AND. 
     &       IDO.EQ.0) GOTO 5000
a558 1
	LOOPSV(5,ISTOP) = IDO
a565 1
        IDO     = 0
a1027 1
	IDO              = LOOPSV(5,ISTOP)
d1065 3
a1067 3
C        GO BACK TO INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
C        REOPEN THE LOG FILE, SINCE IT WAS CLOSED FOR BATCH, 
C        REDEFINE LUNS IF INTERACTIVE USE
d1090 2
d1109 1
a1109 1
C NLOOP IS THE NUMBER OF ITERATIONS FOR THE LOOP.  
a1111 2
C IDO=1 WHILE IN A DO LOOP AND IDO=0 WHEN NOT IN A DO LOOP.  THIS 
C ALLOWS THE USE OF A LABEL SUCH AS LB1 EVEN WHEN NOT IN A DO LOOP.
d1117 2
a1118 2
8600    IF (COPT .EQ. 'I' .AND. IDO .EQ. 0) THEN
C          OPEN DOLOOP SCRATCH FILE
d1122 1
a1122 1
              CALL ERRT(13,'SPIDER',NE)
d1127 1
a1129 1
	IDO   = 1
d1153 1
a1153 1
C       LOWER LIMIT PUT IN IABSLP, UPPER LIMIT VALUE IN NLOOP
d1162 1
a1162 1
        NLOOP            = NUML(2) -IABSLP + 1
d1216 1
a1216 2
C            STOP ECHO TO DOLOOP SCRATCH FILE AND USEIT FOR INPUT NOW
             NINSAVE  = NIN
a1217 1
             LUNDONOW = 0
d1245 1
a1245 1
	IF (IDOTOP .LT. 0 .OR. IDOTOP .GT. MAXPRC) THEN
d1259 2
a1260 3
        IF (COPT .EQ. 'I' .AND. IDOTOP .EQ. 1) THEN
C          CLOSE DOLOOP SCRATCH FILE, RESET INPUT UNIT
           CLOSE(LUNDO)
d1262 7
d1271 3
d1331 1
a1331 1
              CALL FINDLBQ('ELSE',IDO,IDOSTK(6,IDOTOP),INTHELOOP,
d1342 1
a1342 1
	CALL FINDLBQ(LABEL,IDO,IDOSTK(6,IDOTOP),INTHELOOP,IFLEVEL,IRT)
a1362 1
	   IF (IDOTOP .EQ. 1) IDO = 0
@


1.130
log
@changed lundo assignment location
@
text
@d112 1
a112 1
	LOGICAL   JUMP,EX,ISDIGI,ISCHAR,DELETIT,INTHELOOP,FROMBATCH
@


1.129
log
@added lundonow
@
text
@d334 5
a355 8
        ENDIF

        LUNDONOW = 0
        IF (COPT .EQ. 'I' .AND. IDO .EQ. 1 .AND. ILOOP .EQ. 1) THEN
C          MUST COPY LINE TO INTERACTIVE DO LOOP FILE
           WRITE(LUNDO,*) FCHAR(1:NALPH)
C          RDPR ALSO NEEDS TO COPY INPUT TO THE DO-LOOP FILE
           LUNDONOW = LUNDO
@


1.128
log
@do lb start output improved
@
text
@d147 2
d353 1
d357 2
d1214 3
a1216 2
             NINSAVE = NIN
             NIN     = LUNDO
@


1.127
log
@interactive do loops
@
text
@d1123 2
a1124 1
C       REMOVE BLANKS FROM FCHAR, ADDS BLANKS AT END
d1177 1
a1177 3
        IF (N_VERBOSE .EQ. 1) WRITE(NOUT, 8861) LBNO,LOOPREG,
     &                        NUML(1),NUML(2),IABSLP
8861    FORMAT(5X,'DO LB',I2,' X',I3,' = ',i9,',',i9,'   / ',I5)
@


1.126
log
@loopreg initialized to zero
@
text
@a27 1
C                   NTERM    5                                         *
d29 1
a30 1
C                                                                      *
d106 2
a107 2
	INTEGER   IDOSTK(5,MAXPRC),NARGSREC(MAXPRC)
	INTEGER   LOOPSV(MAXPRC,6)
d112 1
a112 1
	LOGICAL   JUMP,EX,ISDIGI,ISCHAR,DELETIT
a126 1
        CHARACTER * 7         DOLOOP
d128 3
a130 3
	CHARACTER * 4         LOGM,LOG1M,LABEL,FMT
        CHARACTER * 2         LABLSV(MAXPRC),LDOSTK(MAXPRC)
        CHARACTER * 1         NULL,DUM,TCHAR
d154 1
a154 1
        DATA CVERS/'VERSION:  UNIX  6.19   ISSUED: 10/13/99 '/ 
a164 1
        DATA DOLOOP/'DO LB##'/
d173 1
a173 1
	DATA IDOTOP,IDOFLG,IFLEVEL/1,0,0/
a215 6
C
C       INITIALIZE DO_LOOP STACK
        DO  I=1,5
          IDOSTK(I,1)=1
        ENDDO
        LOOPREG = 0
d225 9
a233 1
C       TIME TM IS ASSUMED AT BEGININNING OF RUN.  
d351 5
d452 1
a452 2
5600    IF (COPT .EQ. 'I') IPROC = 0
	IF (COPT .EQ. 'B') IPROC = 1
d544 7
a550 7
	LOOPSV(ISTOP,1) = ILOOP
	LOOPSV(ISTOP,2) = IABSLP
	LOOPSV(ISTOP,3) = LOOPREG
	LOOPSV(ISTOP,4) = NLOOP
	LOOPSV(ISTOP,5) = IDO
	LOOPSV(ISTOP,6) = IDOTOP
	LABLSV(ISTOP)   = DOLOOP(6:7)
d566 1
a566 1
	LDOSTK(IDOTOP)   = DOLOOP(6:7)
a670 2
C       NOTE: IPROC=0  CAME FROM INTERACTIVE MODE WHILE 
C       IPROC=1 CAME FROM BATCH
d762 1
a762 1
C          '<' AND DIGIT => SYMBOLIC PARAMETER SUBSTITUTION NEEDED ----    ----------------
d831 1
a831 1
	IF (IPROC .EQ. 0) THEN
d849 1
a849 1
             READ(NIN,90) DUM
d1015 7
a1021 7
	ILOOP            = LOOPSV(ISTOP,1)
	IABSLP           = LOOPSV(ISTOP,2)
	LOOPREG          = LOOPSV(ISTOP,3)
	NLOOP            = LOOPSV(ISTOP,4)
	IDO              = LOOPSV(ISTOP,5)
	IDOTOP           = LOOPSV(ISTOP,6)
	DOLOOP(6:7)      = LABLSV(ISTOP)
d1105 1
a1105 1
C DOLOOP(6:7) HOLDS THE # FROM "DO LB#".
d1109 10
a1118 3
8600    IF (COPT .EQ. 'I') THEN
          CALL ERRT(13,'SPIDER',NE)
          GOTO 5000
d1120 2
a1121 2
        ILOOP  = 1
	IDO    = 1
d1126 2
a1127 5
C       FCHAR(5:5) IS THE FIRST DIGIT OF THE LABEL, PUT IT IN DOLOOP
C       IF FCHAR(6:6) IS A DIGIT, MAKE DOLOOP(7:7) = FCHAR(6:6)
C       IF NOT, MAKE DOLOOP(7:7) A BLANK
        DOLOOP(6:7) = FCHAR(5:6)
	IF (.NOT. ISDIGI(DOLOOP(7:7))) DOLOOP(7:7) = ' ' 
d1130 2
a1131 4
        TCHAR   = FCHAR(ILOCLIM-2:ILOCLIM-2)
        IF (.NOT. ISCHAR(TCHAR)) THEN
C          NEW STYLE LOOP INDEX (X11...)
C          GET REGISTER NUMBER FROM TOKEN
d1140 1
a1140 1
           IDUM = INDEXTOREG(TCHAR,LOOPREG)
a1144 1
        ILOCLIM = INDEX(FCHAR,'=') + 1
d1174 1
a1174 1
	LDOSTK(IDOTOP)   = DOLOOP(6:7)
d1176 4
a1179 1
        IF (N_VERBOSE .EQ. 1) WRITE(NOUT, 8860) FCHAR(1:20),IABSLP
d1187 7
a1194 5
8800    IF (COPT .EQ. 'I') GOTO 5000
C       MAKE SURE FCHAR HAS BLANK IF LB IS ONE DIGIT LONG
        LENLA = LNBLNKN(FCHAR(3:4))
        IF (LENLA .EQ. 1) FCHAR(4:4) = ' '
        IF (FCHAR(3:4) .NE. LDOSTK(IDOTOP)) GOTO 5000
d1208 5
d1221 2
a1222 2
C         FIND THE DOLOOP WE'RE WORKING ON, AND CONTINUE
          CALL SEARCHQ(DOLOOP,IER)
d1231 1
a1231 1

a1247 1
	DOLOOP(6:7) = LDOSTK(IDOTOP)
d1252 7
d1272 1
a1272 1
	   CALL FINDLBQ('ENDIF',0,NULL,IDOFLG,IFLEVEL,IRTFLG)
d1316 1
a1316 1
              CALL FINDLBQ('ELSE',IDO,LDOSTK(IDOTOP),IDOFLG,
d1327 1
a1327 1
	CALL FINDLBQ(LABEL,IDO,LDOSTK(IDOTOP),IDOFLG,IFLEVEL,IRTFLG)
d1330 3
a1332 3
C       IF IDOFLG IS 1, WE HAVE PASSED BY CURRENT DO-LOOP LABEL AND
C       WE MUST POP THE DO-LOOP STACK
        IF (IDOFLG .EQ. 1) THEN
a1347 1
	   DOLOOP(6:7) = LDOSTK(IDOTOP)
d1355 2
a1356 2
C       RESET IDOFLG FOR NEXT TIME
	IDOFLG = 0
@


1.125
log
@changed nloop to be number of repitions (needed for rdprinc)
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  6.18   ISSUED: 10/01/99 '/ 
d209 1
a209 1
C  ARGUMENT OF BIT_SIZE HAS TO BE ANY INTEGER VARIABLE
d224 1
d550 5
a554 4
	ILOOP  = 1
	IABSLP = 0
	NLOOP  = 0
	IDO    = 0
@


1.124
log
@IDOSTK(3,IDOTOP) = LOOPREG
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  6.17   ISSUED: 9/30/99  '/ 
d1096 3
a1098 3
C NLOOP IS THE MAXIMUM ITERATION FOR THE LOOP.  
C ILOOP AND NLOOP ARE NEEDED FOR THE READ ROUTINES.
C IABSLP IS THE ACTUAL NUMBER OF THE ITERATION WE'RE DOING.
d1149 1
a1149 1
        NLOOP            = NUML(2)
d1172 1
d1197 1
a1197 1
	IF (IABSLP .LE. NLOOP) THEN
@


1.123
log
@version incremented
@
text
@d1167 1
@


1.122
log
@wrong register in x?? do loop index
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  6.16   ISSUED: 9/17/99  '/ 
@


1.121
log
@2621       FORMAT(6(1PG12.5,' '))
@
text
@a240 2
C       PARAM(100) NO LONGER USED FOR ERROR FLAG BUT KEPT HERE ANYWAY?
	PARAM(100) = 0
d587 1
a587 4
	IF (FCHAR(2:2) .LT. 'A') THEN
           PARAM(100) = 0
           PARAM(10)  = 0
        ENDIF
d1012 10
a1021 10
	ILOOP          = LOOPSV(ISTOP,1)
	IABSLP         = LOOPSV(ISTOP,2)
	LOOPREG        = LOOPSV(ISTOP,3)
	NLOOP          = LOOPSV(ISTOP,4)
	IDO            = LOOPSV(ISTOP,5)
	IDOTOP         = LOOPSV(ISTOP,6)
	DOLOOP(6:7)    = LABLSV(ISTOP)
	IBCNT          = PSTACK(ISTOP)
	ISTOP          = ISTOP - 1
	PARAM(LOOPREG) = IABSLP
d1148 3
a1150 3
        IABSLP         = NUML(1)
        NLOOP          = NUML(2)
        PARAM(LOOPREG) = IABSLP
d1152 1
a1152 1
	PARAM(1)       = IABSLP
d1199 1
a1199 1
          PARAM(LOOPREG)      = IABSLP
d1235 2
a1236 2
	PARAM(1)       = IABSLP
        PARAM(LOOPREG) = IABSLP
d1330 2
a1331 2
	   PARAM(1)       = IABSLP
	   PARAM(LOOPREG) = IABSLP
@


1.120
log
@WRITE(ITI,9041) CHAR(LOOPREG-103+100),IABSLP
@
text
@d156 1
a156 1
        DATA CVERS/'VERSION:  UNIX  6.15   ISSUED: 9/15/99  '/ 
d881 3
a883 2
           WRITE(FUNCNU(1:80),2621) (FREGST(I),I=1,INUM)
2621       FORMAT(7G13.6)
@


1.119
log
@bad fregst definition
@
text
@d347 1
a347 1
                 WRITE(ITI,9041) CHAR(LOOPREG-103),IABSLP
@


1.118
log
@loop index converted to register
@
text
@d102 1
a102 1
C       
d108 2
a109 1
	INTEGER   LOOPSV(MAXPRC,6),FREGST(7)
@


1.117
log
@version icncremented
@
text
@d102 2
a103 1
        REAL      PRAMSV(MAXPRC,103),CURPARAM(103)
d130 2
a131 2
        CHARACTER * 3         LABLSV(MAXPRC),LDOSTK(MAXPRC)
        CHARACTER * 1         NULL,DINDEX,DUM,TCHAR
d139 1
a139 2
C       NUMREP APPEARS UNUSED AUG 99
        COMMON /DRIV1_COM/ NUMREP,T1,DINDEX
d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.15   ISSUED: 9/13/99  '/ 
d297 1
a297 1
     &     STOP '*** SPIDER UNABLE TO OPEN LOG FILE ***'
d341 9
a349 3
	   IF (IABSLP .NE. 0 .AND. DINDEX .NE. NULL .AND. 
     &         DINDEX .NE. ' ') WRITE(ITI,9040) DINDEX,IABSLP
9040       FORMAT(1X,A,' = ',I4)
d536 1
a536 1
	DO I = 1, 103
d541 7
a547 8
	LOOPSV(ISTOP,1)    = ILOOP
	LOOPSV(ISTOP,2)    = IABSLP
	LOOPSV(ISTOP,4)    = NLOOP
	LOOPSV(ISTOP,5)    = IDO
	LOOPSV(ISTOP,6)    = IDOTOP

	LABLSV(ISTOP)(1:2) = DOLOOP(6:7)
	LABLSV(ISTOP)(3:3) = DINDEX
d555 8
a562 8
C       SAVE ALL THE DO-LOOP VALUES IN THE CALLED PROCEURE STACK
        IDOTOP = IDOTOP + 1
	IDOSTK(1,IDOTOP)    = ILOOP
	IDOSTK(2,IDOTOP)    = IABSLP
	IDOSTK(4,IDOTOP)    = NLOOP
	IDOSTK(5,IDOTOP)    = ISTOP
	LDOSTK(IDOTOP)(1:2) = DOLOOP(6:7)
	LDOSTK(IDOTOP)(3:3) = DINDEX
d917 1
a917 1
	      DO I=1,103
d1003 1
a1003 1
	DO I=1,103
a1011 1

d1015 10
a1024 9
	ILOOP       = LOOPSV(ISTOP,1)
	IABSLP      = LOOPSV(ISTOP,2)
	NLOOP       = LOOPSV(ISTOP,4)
	IDO         = LOOPSV(ISTOP,5)
	IDOTOP      = LOOPSV(ISTOP,6)
	DOLOOP(6:7) = LABLSV(ISTOP)(1:2)
	DINDEX      = LABLSV(ISTOP)(3:3)
	IBCNT       = PSTACK(ISTOP)
	ISTOP       = ISTOP - 1
a1026 5
C       MAKE DO LOOP VARIABLE AN INTEGER (E.G. A --> 1) (MAY 97)
	IDXT = ICHAR(DINDEX) - 64
C       IALPHA(LETTER CONVERTED TO NUMBER) CONTAINS IABSLP (MAY 97)
	IALPHA(IDXT) = IABSLP

a1050 7
C        I DO NOT KNOW WHEN THIS WAS CUT OUT, I GUESS IT IS UNEEDED? al
C        IF THIS IS THE FIRST TIME THE FILE IS ACCESSED, THEN GO READ IT
C        AND SET IWHERE BACK TO 0
C        IF (IWHERE .GT. IBCNT) IBCNT = IWHERE
C        IWHERE = 0


d1126 14
a1139 3

C       DINDEX IS THE LOOP VARIABLE (I,J,K...ETC)
        DINDEX = FCHAR(ILOCLIM-2:ILOCLIM-2)
d1151 5
a1155 2
        IABSLP = NUML(1)
        NLOOP  = NUML(2)
a1156 9
C       CONVERT DO LOOP VARIABLE TO AN INTEGER (E.G. A --> 1)
	IDX = ICHAR(DINDEX) - 64

C       IALPHA(LETTER CONVERTED TO NUMBER) CONTAINS IABSLP
	IALPHA(IDX) = IABSLP

C       PUT IABSLP IN REGISTER X0
	PARAM(1) = IABSLP

d1168 5
a1172 6
	IDOSTK(1,IDOTOP)    = ILOOP
	IDOSTK(2,IDOTOP)    = IABSLP
	IDOSTK(4,IDOTOP)    = NLOOP
	IDOSTK(5,IDOTOP)    = ISTOP
	LDOSTK(IDOTOP)(1:2) = DOLOOP(6:7)
	LDOSTK(IDOTOP)(3:3) = DINDEX
d1186 1
a1186 1
        IF (FCHAR(3:4) .NE. LDOSTK(IDOTOP)(1:2)) GOTO 5000
d1202 1
a1202 1
          IALPHA(IDX)         = IABSLP
d1233 1
d1235 1
a1235 4

	DOLOOP(6:7) = LDOSTK(IDOTOP)(1:2)
	DINDEX      = LDOSTK(IDOTOP)(3:3)
	IDX         = ICHAR(DINDEX) - 64
d1237 3
a1239 5
	IF (IDOTOP .EQ. 1) IDO = 0

C       PUT CURRENT IABSLP IN X0
	PARAM(1) = IABSLP

d1297 1
a1297 1
              CALL FINDLBQ('ELSE',IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,
d1308 1
a1308 2
	CALL FINDLBQ(LABEL,IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,
     &               IFLEVEL,IRTFLG)
d1327 1
d1329 1
a1329 5

	   DOLOOP(6:7) = LDOSTK(IDOTOP)(1:2)
	   DINDEX      = LDOSTK(IDOTOP)(3:3)
	   IDX         = ICHAR(DINDEX) - 64

d1332 3
a1334 2
C          PUT CURRENT IABSLP IN X0
	   PARAM(1) = IABSLP
@


1.116
log
@CMLIMIT.INC
@
text
@d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.14   ISSUED: 8/31/99  '/ 
@


1.115
log
@proc.sys not found bug fiexed
@
text
@d37 1
a141 1
        PARAMETER        (NBUFSIZ = 17008)
@


1.114
log
@simplifed arg passing, removed argument interference with op line register list
@
text
@d501 2
a502 1
          TNAME = TNAME(:NCHART) // TNAMEM(:NALPH)// '.sys'// NULL
@


1.113
log
@increased maxprc, reodered lb code, used errt=13
@
text
@d105 2
a106 2
	INTEGER   IDOSTK(5,MAXPRC),NARGSREC(MAXPRC),RDUMS(NPARG)
	INTEGER   LOOPSV(MAXPRC,6),IREGST(2)
d118 2
a119 2
        CHARACTER *160        MESG
        CHARACTER *80         FUNCNU,REFUNC,TREFUNC
d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.13   ISSUED: 8/17/99  '/ 
d290 1
a290 1
	CALL FILCAN(LOG,NLET,NULL,NULL,LOGM,PRJEXC,IER) 
d292 2
a293 1
     &     STOP '*** SPIDER UNABLE TO CONSTRUCT LOG FILE NAME ***'
a294 1
#if defined(SP_SUN4) || defined (SP_F90)
a295 5
#else
	OPEN(NPROC,FILE=LOG,STATUS='UNKNOWN',CARRIAGECONTROL='LIST',
     &       IOSTAT=IER)
#endif

d300 1
a300 1
	CALL FILCAN(RESULT,NRESUL,NULL,NULL,RESULM,PRJEXC,IER)  
d302 1
a302 1
     &     STOP '*** SPIDER UNABLE TO CONSTRUCT RESULTS FILE NAME ***'
d308 1
a308 1
     &     STOP '*** SPIDER UNABLE TO OPEN RESULTS FILE ***'
d365 2
a366 2
C        IF THE OPERATION IS A REGISTER, GOTO EXPRESSION EVALUATOR.
C        (RECOGNIZED BY 'X<DIGIT>' OR 'X<DIGIT><DIGIT>')
d370 8
a385 8
C       CHAR FOLLOWED BY 2 DIGITS IS OLD STYLE BATCH (B01) CALL
	IF (ISCHAR(FCHAR(1:1)) .AND.
     &      ISDIGI(FCHAR(2:2)) .AND. ISDIGI(FCHAR(3:3)) .AND.
     &      NALPH .EQ. 3) GOTO 5600

C       TRANSLATE OPERATION STRING TO UPPER CASE NOW
        CALL SSUPCAS(FCHAR)

d465 2
a466 2
        CALL FROMTOQ(FCHAR(NFSTRT:),NALPH,'[',']',IARGSENT(1,ISTOP+1),
     &               RDUMS,NARGREG,NPARG)
d468 2
a469 6
C       TNAME IS TEMP NAME TO SEE WHERE PROCEDURE EXISTS
C       TNAMEM NEEDS DELIMITER
        IF (FCHAR(:1) .EQ. '@@') NALPH = NALPH - 1
        TNAMEM(1:NALPH+1) = FCHAR(NFSTRT:NFSTRT+NALPH-1) // NULL
        CALL FILCAN(TNAME,NTNAME,NULL,  NULL,TNAMEM,PRJEXC,IER)  
	IF (IER.NE.0) CALL ERRT(101,'FILENAME ??',NE)
d471 3
a512 1
C       PUT IT ON THE STACK
d518 2
a519 2
6170       FORMAT(' *** LOOP NESTING LEVEL (',I3,') EXCEEDED')
           CALL ERRT(101,'LOOP NESTING LEVEL EXCEEDED',NE)
d522 2
d533 1
a533 1
C       SAVE DO-LOOP INFO
d543 1
a543 1
C       RE-SET DO-LOOP INFO FOR PROCEDURE
d549 1
a549 1
C       SAVE ALL THE DO-LOOPVALUES IN THE STACKS
a557 1
C       PUT THE ARGS ON THE STACK
d560 1
a560 1
	IF (ISTOP.GT.1) THEN
d675 2
d680 1
a680 1
C       IWHERE IS POSITION IN LAST PROCEDURE
d682 4
a685 8
	LENQSTRQ = 0
        NQSTRQ   = 0
	IPCNT    = 0
        IF (N_VERBOSE .EQ. 1) WRITE(NDAT,*) ' '

C                        1234567890123456789012345678901234567890
2200    FUNCNU(1:40)  = '                                        '
        FUNCNU(41:80) = '                                        '
d687 1
a688 3
C       FIND LAST NON-BLANK            
        NUMCHR = lnblnk(REFUNC)
	IPCNT  = IPCNT + 1
d690 1
a690 4
C       1/16/85 ----- COPY REGISTER ARGUMENT LIST IF PRESENT ----------

	IF (IPCNT .EQ. 1 )  NARGSREC(ISTOP) = 0
	IF (IPCNT .EQ. 1 .AND. REFUNC(:1) .EQ. '[' .AND. 
d695 3
a697 3
          NLEN = NUMCHR
	  CALL FROMTOQ(REFUNC,NUMCHR,'[',']',IARGSREC(1,ISTOP),RDUMS,
     &                 NARGREG1,NPARG)
d707 1
a707 1
C         UPDATE THIS PROCEDURES REGISTERS FROM CALLING'S REGISTERS
d712 12
a723 3
C         PUT SEMICOLON IN FRONT OF DUMMY ARGUMENT LIST = COMMENT NOW
          REFUNC(1:NLEN+1) = ';' // REFUNC(1:NLEN)
	  NUMCHR           = NLEN + 1
d726 16
d743 9
a751 11
C          NOT PROCEDURE QUESTION, SEE IF SYMBOLIC SUBSTITUTION NEEDED 
           LOCLESS  = INDEX(REFUNC,'<')
           ISEMICOL = INDEX(REFUNC,';')
           IF (LOCLESS .GT. 0 .AND. 
     &        (ISEMICOL .EQ. 0 .OR. LOCLESS .LT. ISEMICOL) .AND. 
     &        ISDIGI(REFUNC(LOCLESS+1:LOCLESS+1))) THEN
C             SYMBOLIC PARAMETER SUBSTITUTION NEEDED
              GOTO 2900
           
           ELSE
C             SUBSTITUTE ENTIRE STRING
d756 64
d828 3
a830 2
           IGO   = INDEX(REFUNC(1:NUMCHR),'?')
           IEND  = INDEX(REFUNC(IGO+1:NUMCHR),'?') + IGO
d836 1
a836 2
C          FIND LAST NON-BLANK            
           NCHAR = lnblnk(FUNCNU)
d838 2
a839 1
C          FIND RESPONSE TO ?---? PROMPT, FROM FILE
a848 3

C          FIND LAST NON-BLANK            
           NCHAR = lnblnk(FUNCNU)
d853 7
d862 2
a863 3
        TCHAR         = FUNCNU(NCHAR:NCHAR)
        CALL CHARINSIDE(FUNCNU(1:NCHAR),'{','}',.TRUE., 
     &                  IGOSUB,IENDSUB,NSUB)
d867 1
a867 4
C          ADDED 11/8/79 FOR CASE WHEN A QUESTION IS ANSWERED 
C          WITH A REGISTER
           IF (FUNCNU(1:1) .EQ. 'x') FUNCNU(1:1) = 'X'
           IF (FUNCNU(2:2) .EQ. 'x') FUNCNU(2:2) = 'X'
d869 2
a870 2
	   CALL CHKSTRQ(FUNCNU,NCHAR,'I',IREGST,FDUM,INUM,IER)
	   IF (IER .NE. 0) THEN
d874 31
a904 14
           IFN1 = ABS(IREGST(1))
           P1   = PRAMSV(ISTOP,IFN1)
           IF (IFN1 .LT. 0) P1 = -P1

           NCHAR = 13
           WRITE(FUNCNU(1:13),2620) P1
2620       FORMAT(2F13.6)

           IF (INUM .NE. 1) THEN
             IFN2  = ABS(IREGST(2))
             P2    = PRAMSV(ISTOP,IFN2)
             IF (IFN2 .LT. 0) P2 = -P2
             NCHAR = 26
             WRITE(FUNCNU(14:26),2620) P2
a905 1
           FUNCNU(NCHAR+1:80) = ' '
a906 1
        ELSE
d908 2
a909 1
C             NEW STYLE ({***??}) SUBTITUTION PATTERN
d914 3
a916 1
C             SUBSTITUTE FOR {***X??} IN THE FUNCNU STRING
a917 41
              TCHAR = FUNCNU(NCHAR:NCHAR)
           ENDIF

           IF (NCHAR .GE. 3 .AND. ISDIGI(TCHAR)) THEN
C             ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REGISTER
              TCHAR = FUNCNU(NCHAR-1:NCHAR-1)
              IGO   = 0
              IF (TCHAR .EQ. 'X' .OR. TCHAR .EQ. 'x') THEN
C                CHANGE TO UPPERCASE, IF NECESSARY
                 IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-1:NCHAR-1) = 'X'
                 IGO = NCHAR

              ELSEIF (ISDIGI(TCHAR)) THEN
                 TCHAR = FUNCNU(NCHAR-2:NCHAR-2)
                 IF (TCHAR .EQ. 'X' .OR. TCHAR .EQ. 'x') THEN
                    IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-2:NCHAR-2) = 'X'
                    IGO = NCHAR - 1
                 ENDIF
              ENDIF

              IF (IGO .GT. 0) THEN
C                HAVE A REGISTER IN FILE NAME
                 READ(FUNCNU(IGO:NCHAR),8001,IOSTAT=IER) IREG
8001             FORMAT(I2)
                 IF (IER .NE. 0) THEN
C                   STOPS IN ERRT
                    CALL ERRT(101,
     &                 '#1 ERROR IN REGISTER SUBSTITUTION',NE)
                 ENDIF
                 IREG = IREG + 1
                 N1   = PRAMSV(ISTOP,IREG) + 0.5
C                PREPARE SUBSTITUTION PATTERN
                 FUNCNU(IGO-1:IGO+1) = '***'
                 NCHAR = IGO+1
                 CALL FILGET(FUNCNU,FUNCNU,NCHAR,N1,IER)
                 IF (IER .NE. 0) THEN
C                   STOPS IN ERRT
                    CALL ERRT(101,
     &                  '#1B ERROR IN REGISTER SUBSTITUTION',NE)
                 ENDIF
              ENDIF
a920 9
	IF (IPROC .NE. 0) THEN
C           DID NOT COME FROM INTERACTIVE MODE
            OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')

	    DO K = 1, IPCNT
               READ(NIN,90) DUM
            ENDDO
        ENDIF

a968 80
C ------  BEGIN SYMBOLIC PARAMETER SUBSTITUTION SECTION ---------------

C       IF FIRST TWO CHARACTERS ARE  '<' AND DIGIT 
C       ASSUME SYMBOLIC PARAMETER SUBSTITIUTION.

2900    TREFUNC = REFUNC
C       FIND START AND END OF PARAMETER STRING IN INPUT 
        CALL CHARINSIDE(TREFUNC(1:NUMCHR),'<','>',.FALSE.,IP1,IP2,NCT)

        IF (IP1 .LT. 1 .OR. IP2 .LE. IP1) THEN
           MESG = 'UNDECIPHERABLE SYMBOLIC PARAMETER IN: ' //
     &            TREFUNC(:NUMCHR)
           CALL ERRT(101,MESG,NE)
           GOTO 9999
        ENDIF

C       SCAN THE QSTRQ ARRAY TO FIND STRING FOR SUBSTITUTION.
        TREFUNC(IP1:IP1) = '#'
        TREFUNC(IP2:IP2) = '#'
        IPQ1             = INDEX(QSTRQ(1:LENQSTRQ),TREFUNC(IP1:IP2))

        IF (IPQ1 .LE. 0) THEN
C          UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER -- NOTIFY USER
           WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES: ',
     &                   QSTRQ(1:LENQSTRQ)

           MESG = 'CAN NOT FIND SYMBOLIC REFERENCE FOR: ' //
     &            REFUNC(IP1:IP2)
           CALL ERRT(101,MESG,NE)
C          STOPS IN ERRT!!
	   GOTO 9999
        ENDIF

C       COPY STRING BEFORE < (IF ANY) INTO REFUNC
        IF (IP1 .GT. 1) FUNCNU(1:IP1-1) = REFUNC(1:IP1-1)

C       FOUND THIS PARAMETER NUMBER IN QSTRQ, COPY QSTRQ VALUE TO FUNCNU
        NGO              = INDEX(QSTRQ(IPQ1+1:LENQSTRQ),'#') + IPQ1 + 1
        NEND             = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 3
        NOCHAR           = NEND - NGO + 1
        FUNCNU(IP1:NOCHAR+IP1) = QSTRQ(NGO:NEND)
        NOCHAR                 = NOCHAR + IP1 - 1

C       STRIP THE PARAMETER STUFF FROM THE INPUT STRING (FOR SIMPLICITY)       
        REFUNC(1:NUMCHR-IP2) = REFUNC(IP2+1:NUMCHR) 
        NUMCHR               = NUMCHR - IP2 

C       IGNORE ANY SEMICOLON DENOTED COMMENT AT END OF REFUNC STRING
        LOCSEMI  = INDEX(REFUNC,';')
        TREFUNC  = ' '
        IF (LOCSEMI .GT. 1) THEN
C          STRIP AND SAVE COMMENT TO APPEND BACK LATER
           NUMOLD   = NUMCHR
           NUMCHR   = LNBLNK(REFUNC(1:LOCSEMI-1))
           TREFUNC  = REFUNC(NUMCHR+1:NUMOLD) // NULL
        ENDIF

	IF ((REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x') .AND.
     &     ((NUMCHR .EQ. 2 .AND. ISDIGI(REFUNC(2:2))) .OR. 
     &      (NUMCHR .EQ. 3 .AND. ISDIGI(REFUNC(2:2)) .AND. 
     &                           ISDIGI(REFUNC(3:3))))) THEN
C          SYM. PARAMETER & 1 DIGIT REGISTER SUBSTITUTION (I.E. <??>X?) 

           FUNCNU(NOCHAR+1:NOCHAR+NUMCHR+5) = '{---' // 
     &            REFUNC(1:NUMCHR) // '}' // TREFUNC
           WRITE(NUNIN,90) FUNCNU

        ELSEIF (ISCHAR(REFUNC(NUMCHR:NUMCHR)) .AND.
     &         (NUMCHR .EQ. 1 .OR. ISDIGI(REFUNC(1:1)))) THEN 
C          SYMBOLIC PARAM. & LOOP INDEX SUBSTITUTION 
C         (E.G. <??>i OR <??>0I OR <??>0?I OR <??>0*I )
          FUNCNU(NOCHAR+1:NOCHAR+6) = '{---' //REFUNC(NUMCHR:NUMCHR) //
     &                                '}' // TREFUNC
          WRITE(NUNIN,90) FUNCNU

        ELSE
C          IF NONE OF THE ABOVE, COPY WHOLE STRING
           WRITE(NUNIN,90) FUNCNU(1:NOCHAR),REFUNC(1:NUMCHR)
	ENDIF 
	GOTO 2200
d1009 1
a1009 1
C       RETRIEVE DO-LOOP INFO
d1018 1
a1018 1
	ISTOP       = ISTOP-1
a1119 2
	IABSLP = 0 
	NLOOP  = 0
d1122 1
a1122 1
C       REMOVE BLANKS FROM FCHAR
d1126 15
a1140 26
	DOLOOP(6:6) = FCHAR(5:5)

C       IS FCHAR(6:6) A DIGIT?  IF NOT, MAKE DOLOOP(7:7) A BLANK
C       IF YES, MAKE DOLOOP(7:7) = FCHAR(6:6)

	IF (ISDIGI(FCHAR(6:6))) THEN
	   DOLOOP(7:7) = FCHAR(6:6)
	   IWH = 9
	ELSE
	   DOLOOP(7:7) = ' '
	   IWH = 8
	ENDIF

C       DINDEX IS THE LOOP VARIABLE
        DINDEX = FCHAR(IWH-2:IWH-2)
        CALL SSUPCAS(DINDEX)

C       CONVERT DO LOOP VARIABLE TO AN INTEGER (E.G. A --> 1)
	IDX = ICHAR(DINDEX) - 64

C       IWH POINTS TO LOWER LIMIT NOW, PARSE OUT LOWER LIMIT OF DO LOOP
C       LOWER LIMIT PUT IN IABSLP
C       IF THE LOWER LIMIT IS A REGISTER, PUT REGISTER VALUE IN IABLSP
C       PUT THE UPPER LIMIT VALUE IN NLOOP
        NC = NLET-IWH+1
        CALL CHKSTR(FCHAR(IWH:NLET),NC,'I',NUML,FDUM,2,NVAL,IRTFLG)
d1149 3
d1161 3
a1163 3
C          NESTING LEVEL IS MAXPRC.  IF EXCEEDED, LET THE USER KNOW.
C          HALTS IN ERRT
           WRITE(NOUT,6170) MAXPRC
d1376 22
@


1.112
log
@added trap for idostk overflow
@
text
@d41 1
a41 1
	PARAMETER (MAXPRC    = 12) 
d44 1
a44 1
	PARAMETER (MAXPRCNAM = 25) 
d525 2
a526 2
6170       FORMAT(' *** PROCEDURE NESTING LEVEL (',I3,') EXCEEDED')
           CALL ERRT(101,'PROCEDURE NESTING LEVEL EXCEEDED',NE)
d1016 1
a1016 1
           CALL ERRT(101,'OPERATION NOT ALLOWED IN INTERACTIVE MODE',NE)
d1153 1
a1153 1
          CALL ERRT(101,'OPERATION NOT ALLOWED IN INTERACTIVE MODE',NE)
d1211 1
a1211 1
           CALL ERRT(101,'PROCEDURE NESTING LEVEL EXCEEDED',NE)
d1253 1
a1253 1
C         SAVE CHANGED VALUES IN THE DO-LOOP STACK
d1274 4
a1277 5
8820    IDOTOP      = IDOTOP-1
	IF (IDOTOP .GT. MAXPRC) THEN
C          NESTING LEVEL IS MAXPRC.  IF EXCEEDED, LET THE USER KNOW.
C          HALTS IN ERRT
           CALL ERRT(101,'PROCEDURE NESTING LEVEL EXCEEDED',NE)
a1292 4
C       IF POPPING THE STACK BECAUSE OF A LOGICAL IF JUMPING OUT OF
C       THE CURRENT DO-LOOP, GO BACK TO LOGICAL IF PROCESING.
	IF (IDOFLG .EQ. 1) GOTO 10870

d1369 1
a1369 2
              CALL ERRT(101,
     &           'OPERATION NOT ALLOWED IN INTERACTIVE MODE',NE)
d1372 19
a1390 1
           GOTO 8820
a1392 1
10870	CONTINUE
d1400 3
@


1.111
log
@loop stack hndling bug fixed, used chkstr in do-loop parsing, removed numrep
@
text
@d1275 6
@


1.110
log
@symbolic parameter sub. anywhere on input line now
@
text
@d108 1
d137 1
d155 1
a155 1
        DATA CVERS/'VERSION:  UNIX  6.12   ISSUED: 8/09/99  '/ 
a180 1
        NUMREP      = 1
a540 1
	LOOPSV(ISTOP,3)    = NUMREP
a551 1
	NUMREP = 1
d554 9
d565 1
a565 1
	PSTACK(ISTOP)=IBCNT
a1048 1
	NUMREP      = LOOPSV(ISTOP,3)
d1141 3
a1143 3
C ILOOP COUNTS THE NUMBER OF TIMES WE'VE BEEN THRU THE LOOP
C NUMREP IS THE NUMBER OF REPETITIONS OF THE DO-LOOP.
C		ILOOP AND NUMREP ARE NEEDED FOR THE READ ROUTINES.
d1145 3
a1147 4
C NLOOP IS THE MAXIMUM ITERATION FOR THE LOOP  IDO=1 WHILE IN A DO LOOP 
C AND IDO=0 WHEN NOT IN A DO LOOP.  THIS ALLOWS THE USE OF A LABEL SUCH 
C AS LB1 EVEN WHEN NOT IN A DO LOOP.
C
d1161 1
d1163 2
a1166 1
C       FCHAR(5:5) IS THE FIRST DIGIT OF THE LABEL, PUT IT IN DOLOOP
d1172 1
a1172 1
	   IWH = 8
d1175 1
a1175 1
	   IWH = 7
a1176 2
        DINDEX = FCHAR(IWH-1:IWH-1)
        CALL SSUPCAS(DINDEX)
a1177 1
C       IWH POINTS TO THE EQUALS SIGN, AND IS USED AS AN OFFSET; 
d1179 2
a1180 1
C       PARSE OUT THE LOWER LIMIT OF THE DO LOOP
d1182 2
a1183 15
	DO 8700 I = 1, 5
          IF ((FCHAR(I+IWH:I+IWH) .EQ. 'X')
     &        .OR. (FCHAR(I+IWH:I+IWH) .EQ. 'x'))  GOTO 8700
          IF (.NOT. ISDIGI(FCHAR(I+IWH:I+IWH))) GOTO 8720
          INEXT = I
          READ(FCHAR(I+IWH:I+IWH),8660) ITEMP
8660      FORMAT(I1)
          IABSLP = IABSLP*10+ITEMP
8700	CONTINUE

C       IF ITS A REGISTER, SKIP FIRST CHARACTER
C       IS CHARACTER A DIGIT?
C       YES.  KEEP TRACK OF WHERE WE ARE IN STRING WITH INEXT, AND
C       DECODE THE DIGIT.  KEEP GOING UNTIL CHARACTER IS NOT A DIGIT.
C       LOWER LIMIT PUT IN IABSLP, SINCE THAT'S WHERE WE'LL START
d1185 2
d1188 10
a1197 23

C       SKIP THE COMMA, PARSE THE UPPER LIMIT OF THE DO LOOP
8720	IF ((FCHAR(IWH+1:IWH+1) .EQ. 'X')
     &      .OR. (FCHAR(IWH+1:IWH+1) .EQ. 'x')) IABSLP=PARAM(IABSLP+1)
	INEXT = INEXT + 1
	DO I = INEXT+1, INEXT+5
C         SAME AS ABOVE
          IF ((FCHAR(I+IWH:I+IWH) .NE. 'X')
     &        .AND. (FCHAR(I+IWH:I+IWH) .NE. 'x')) THEN
             IF (.NOT. ISDIGI(FCHAR(I+IWH:I+IWH))) GOTO 8760
             READ(FCHAR(I+IWH:I+IWH),8660) ITEMP
C            THE UPPER LIMIT IS PUT IN NLOOP
             NLOOP = NLOOP*10 + ITEMP
          ENDIF
 	END DO

C       IF THE UPPER LIMIT IS A REGISTER, PUT THE VALUE IN NLOOP
8760	IF ((FCHAR(IWH+INEXT+1:IWH+INEXT+1) .EQ. 'X')
     &      .OR. (FCHAR(IWH+INEXT+1:IWH+INEXT+1) .EQ. 'x'))
     &      NLOOP = PARAM(NLOOP+1)

C       NUMREP IS THE NUMBER OF TIMES THE LOOP IS PERFORMED
	NUMREP = NLOOP - IABSLP + 1
a1198 3
C       MAKE DO LOOP VARIABLE AN INTEGER (E.G. A --> 1)
	IDX = ICHAR(DINDEX) - 64

d1202 1
a1202 1
C       PUT IABSLP IN X0
d1205 1
a1205 1
C       ADD THIS DO LOOP TO THE TOP OF THE STACK
a1217 1
	IDOSTK(3,IDOTOP)    = NUMREP
d1245 1
a1245 1
C       UPDATE X0
d1248 1
a1248 1
C         WE'RE NOT DONE YET
a1251 6
          IDOSTK(1,IDOTOP)    = ILOOP
          IDOSTK(2,IDOTOP)    = IABSLP
          IDOSTK(3,IDOTOP)    = NUMREP
          IDOSTK(4,IDOTOP)    = NLOOP
          IDOSTK(5,IDOTOP)    = ISTOP
          LDOSTK(IDOTOP)(1:2) = DOLOOP(6:7)
d1253 4
d1271 2
a1272 6
C       WE'RE DONE, RESET VALUES

8820	NUMREP = 1
	ILOOP  = 1

C       POP THE STACK, GET ALL THE VALUES BACK
d1274 2
a1275 2
	IDOTOP      = IDOTOP-1
	ILOOP       = IDOSTK(1,IDOTOP)
a1276 1
	NUMREP      = IDOSTK(3,IDOTOP)
d1282 2
a1283 1
	IF (IDOTOP.EQ.1)IDO=0
d1285 1
a1285 1
C       PUT IABSLP IN X0
@


1.109
log
@version incremented, CDATT print now only 11 char
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  6.11   ISSUED: 7/19/99  '/ 
d722 16
a737 9
        IF (REFUNC(1:1) .EQ. '<' .AND. ISDIGI(REFUNC(2:2))) THEN
C          SYMBOLIC PARAMETER SUBSTITUTION NEEDED
           GOTO 2900

        ELSEIF (REFUNC(1:1) .NE. '?') THEN
C          NOT PROCEDURE QUESTION, SUBSTITUTE ENTIRE STRING
           WRITE(NUNIN,2301) REFUNC
2301       FORMAT(A80)
           GOTO 2200
a926 2
        IP1     = INDEX(TREFUNC(1:NUMCHR),'<') 
        IP2     = INDEX(TREFUNC(1:NUMCHR),'>') 
d951 3
d958 2
a959 1
        FUNCNU(1:NOCHAR) = QSTRQ(NGO:NEND)
d1412 21
@


1.108
log
@ran
@
text
@d153 1
a153 1
        DATA CVERS/'VERSION:  UNIX  6.1    ISSUED: 6/23/99  '/ 
d271 1
a271 1
	WRITE(NOUT,9094)CDATT,CTIM
@


1.107
log
@version incremented
@
text
@d146 3
a148 5
C       COMMON TO PASS VALUE FOR RANDOM NUMBER GENERATOR SEED
#ifdef SP_F90
	INTEGER  ISEEDVAL(1)
#endif
        COMMON /RNDMSEED/ ISEEDVAL
d206 4
d211 4
a214 3
#ifdef SP_F90
        ISEEDVAL(1) = MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &       1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
d216 2
a217 4
#else
        ISEEDVAL = MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))+
     &       1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
#endif
@


1.106
log
@buf renamed in common /IOBUF/
@
text
@d154 2
a155 2
CHERE               123456789 123456789 123456789 123456789 
        DATA CVERS/'VERSION:  UNIX  6.02   ISSUED: 5/13/99'/ 
@


1.105
log
@merged with inilun.f to avoid common block initialization in data statements
@
text
@d140 1
a140 1
        COMMON /IOBUF/   BUF(NBUFSIZ)
@


1.104
log
@increased version to 6.02
@
text
@d20 1
a20 1
C                   NIN      5    NTERM         1     NDISK  B* FILE   *
d23 1
a23 1
C                   NOUT     6    ITI           3     NDAT   OUTPUT    *
d25 1
a25 1
C                   NECHO    6    ITI           3     NDAT   ECHO      *
d67 30
d122 1
d152 1
a152 2

C$$$$$$$$$$$$$$$$$$$$$$$$ VERSION INITIALIZATION $$$$$$$$$$$$$$$$$$$$$$$
a153 1
        ONUNIX = .TRUE.
d155 1
a155 8
        DATA CVERS/'VERSION:  UNIX  6.01   ISSUED: 4/20/99'/ 
#ifndef __osf__
        ONSGI = .TRUE.
        ONOSF = .FALSE.
#else
        ONSGI = .FALSE.
        ONOSF = .TRUE.
#endif
d165 2
a166 3
	DATA NFILE/0/,IFILE/0/
	DATA ISTOP/0/,IBCNT/0/
	DATA DOLOOP/'DO LB##'/,NUMREP/1/,ILOOP/1/,NLOOP/1/ 
d172 1
a172 1
	DATA NDAT/3/,NTERM/5/,NUNIN/7/,NDISK/1/,IFOUND/1/
d174 1
a175 2
	DATA NTRACE/0/,N_VERBOSE/1/,N_MOSAIC/0/,SILENT/.FALSE./
        DATA ONSUN/.FALSE./
d179 24
d222 6
a227 5
C       INITIALIZE LUNS.  
C       TO CREATE BATCH DRIVER ON VAX (DRIVERX) LINK WITH INILUNB, 
C       TO CREATE INTERACTIVE DRIVER (DRIVER) LINK WITH INILUNI.

	CALL INILUN(NIN,NOUT,NECHO,ITI,ITIN,NTERM,NDAT,MAXDIM)
d254 1
a254 1
        CALL DATE(CDAT)
d270 2
a271 2
	WRITE(NOUT,9094)CDAT,CTIM
9094    FORMAT('   /     \\          DATE:     ',A,'    AT  ',A,//)
d278 2
a279 2
C       ONUNIX CAN GET DATEXC, START & RESCHEDULE BATCHES
        IF (ONUNIX) CALL INITUNIX(NUMARG,FCHAR,NALPH)
d307 3
a309 7
C       ON UNIX --- INCREMENT THE RESULTS FILE VERSION IF EXISTING
        IF (ONUNIX) THEN
           CALL NEXTVERSION(RESULT(1:11),RESULT,NDAT)
           OPEN(NDAT,FILE=RESULT,STATUS='UNKNOWN',IOSTAT=IER)
        ELSE
           OPEN(NDAT,FILE=RESULT,STATUS='NEW',IOSTAT=IER)
        ENDIF
d318 1
a318 1
	WRITE(NDAT,9094)CDAT,CTIM
d473 1
a473 1
        IF (ONUNIX .AND. FCHAR(:1) .EQ. '@@') NALPH = NALPH - 1
d502 4
a505 9
          IF (ONUNIX) THEN
             CALL MYGETENV('SPPROC_DIR',TNAME,NCHART,
     &                     'dir-for-proc-files',IER)
             IF (IER .NE. 0) CALL ERRT(101,'NO ENVIRONMENT VAR',NE)
             TNAME = TNAME(:NCHART) // TNAMEM(:NALPH)// '.sys'// NULL
          ELSE 
             CALL FILCAN(TNAME,NTNAME,'PROC',NULL,TNAMEM,'SYS',IER)
          ENDIF
          IF (IER .NE. 0) CALL ERRT(101,'BAD FILENAME',NE)
d1089 3
a1091 9
	NIN   = NTERM
        IF (ONUNIX) THEN
           NOUT  = 6
           NECHO = NOUT
        ELSE
	   NOUT  = NTERM
	   NECHO = NTERM
        ENDIF

@


1.103
log
@changed version number to 6.0
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  6.00   ISSUED: 4/12/99'/ 
@


1.102
log
@random for f90
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.20   ISSUED: 3/02/99'/ 
@


1.101
log
@filename substituion using aprameters bug fixed
@
text
@d116 3
d165 5
d172 1
a172 1

@


1.100
log
@copyright change
@
text
@d909 1
a909 1
        NUMCHR               = NUMCHR - IP2
a928 1
c           IF (LOCSEMI .GT. 1) FUNCNU(NOCHAR+NUMCHR+6:) = TREFUNC
a936 1
c          IF (LOCSEMI .GT. 1) FUNCNU(NOCHAR+7:) = TREFUNC
d941 1
a941 1
           WRITE(NUNIN,90) FUNCNU(1:NOCHAR)
@


1.99
log
@removed USEINLN
removed initinln call
@
text
@d7 6
a12 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
@


1.98
log
@lenla added after label: 8800 for lb check
@
text
@a226 2
C       SET SIZE FOR INILINE BUFFER ON VAX
        CALL INITINLN(.FALSE.,IRTFLG)
@


1.97
log
@version incremented
@
text
@d123 1
a123 1
        DATA CVERS/'VERSION:  UNIX  5.19   ISSUED: 2/19/99'/ 
d1210 3
@


1.96
log
@ removed VMS specific code.
@
text
@d123 1
a123 1
        DATA CVERS/'VERSION:  UNIX  5.17   ISSUED: 1/11/99'/ 
@


1.95
log
@version incremented
@
text
@d78 1
a78 3
#ifdef SP_VMS
	INTEGER   SYS$SETPRN
#endif
a120 1
#ifdef SP_UNIX
a130 7
#else
        ONUNIX = .FALSE.
        ONOSF  = .FALSE.
        ONSGI  = .FALSE.
C                   123456789 123456789 123456789 123456789 
        DATA CVERS/'VERSION:  VMS  16.0    ISSUED: 02/03/98  '/ 
#endif
a234 7

#ifdef SP_VMS
C       IF  LOG FILE EXISTS WITH SAME EXTENSION, ANOTHER PROCESS MAY
C       BE  RUNNING UNDER SAME PROJECT AND DATA EXTENSION - DON'T LET IT.
        CSEND(4:6) = PRJEXC(1:3)
        ISET = SYS$SETPRN(CSEND)
#endif
@


1.94
log
@changed version to 5.16 on 1 dec 98
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.16   ISSUED: 12/01/98'/ 
@


1.93
log
@changed interactive binding time for registers in proceedures
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.14   ISSUED: 10/27/98'/ 
@


1.92
log
@if.. bugs
@
text
@d712 28
a739 11
C           CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS PROMPT
            IGO   = INDEX(REFUNC(1:NUMCHR),'?')
            IEND  = INDEX(REFUNC(IGO+1:NUMCHR),'?') + IGO
	    WRITE(ITI,2330)  REFUNC(IGO:IEND)
2330	    FORMAT('$',A)
C           INPUT RESPONSE TO ?---? PROMPT

            READ(ITIN,2389) FUNCNU
C           FIND LAST NON-BLANK            
            NCHAR = lnblnk(FUNCNU)
	    GO TO 2820
a740 15
	CLOSE(NIN)

	OPEN(NIN,FILE=PNAMEC,STATUS='UNKNOWN')
	DO I = 1, IWHERE
          READ(NIN,90) DUM
        ENDDO

	IWHERE        = IWHERE + 1
	PSTACK(ISTOP) = IWHERE

        READ(NIN,2389) FUNCNU
2389    FORMAT(A)
C       FIND LAST NON-BLANK            
        NCHAR = lnblnk(FUNCNU)
        CLOSE(NIN)
d742 1
a742 1
        TCHAR = FUNCNU(NCHAR:NCHAR)
d828 8
a835 5
        OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN')

	DO K = 1, IPCNT
           READ(NIN,90) DUM
        ENDDO
d837 1
a837 1
2820	IF ((LENQSTRQ + NCHAR + NQSTRQ + 4) .GE. MAXQSTRQ) THEN
@


1.91
log
@added error traps for iflevel
@
text
@d494 1
a494 1
        ISTOP=ISTOP+1
d1295 1
a1295 1
        IF (IFLEVEL .GT. 0 .AND. .NOT. USEELSE(IFLEVEL)) THEN
d1299 1
d1317 1
a1317 2
	ELSEIF (LABEL(1:4) .NE. 'ELSE' .AND.
     &         IER .EQ. 0 .AND. .NOT. JUMP) THEN
d1320 4
d1339 4
a1342 5
           IF (.NOT. JUMP) GOTO 5000

C          'IF' IS FALSE JUMP TO CORRESPONDING ELSE OR ENDIF
C          DECREMENTS IFLEVEL ALSO
           CALL FINDLBQ('ELSE',IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,
d1344 1
d1348 1
a1348 6
C       IF FIRST LABEL ELEMENT BLANK, LOGIFQ JUST SETS AN ARITHMETIC 
C       EXPRESSION.  NO NEED TO JUMP TO ANY LABEL.
        IF (LABEL(1:1) .EQ. ' ') GOTO 5000

	IF (LABEL(1:4) .NE. 'ELSE' .AND.
     &     .NOT. ISDIGI(LABEL(4:4))) LABEL(4:4) = ' '
d1351 2
a1352 1
C       KEEP READING INPUT LINES TILL LABEL IS FOUND
@


1.90
log
@version incremented
@
text
@d1292 3
d1325 5
a1329 1
           IF (IFLEVEL .GT. MAXPRC) THEN
@


1.89
log
@changed version
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.13   ISSUED: 10/20/98'/ 
@


1.88
log
@changed version
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.12   ISSUED: 09/14/98'/ 
@


1.87
log
@changed version #
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.11   ISSUED: 08/18/98'/ 
@


1.86
log
@removed old-fashioned parameter substitution (P1) recognition.
@
text
@d126 1
a126 1
        DATA CVERS/'VERSION:  UNIX  5.0    ISSUED: 02/03/98'/ 
@


1.85
log
@added ISEEDVAL setter
@
text
@a693 1
        
d696 1
a696 2
        IF ((REFUNC(1:1) .EQ. 'P' .OR. REFUNC(1:1) .EQ. '<' .OR.
     &       REFUNC(1:1) .EQ. 'p') .AND. ISDIGI(REFUNC(2:2))) THEN
d882 1
a882 1
C       IF FIRST TWO CHARACTERS ARE 'P' AND DIGIT OR '<' AND DIGIT 
d885 1
a885 11
2900    IF (REFUNC(1:1) .EQ. 'P' .OR. REFUNC(1:1) .EQ. 'p') THEN
C          OLD STYLE 'P#' PARAMETER SUBSTITUTION
           WRITE(NOUT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
           WRITE(NDAT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
           MESG =  'OFFENDING INPUT: ' // REFUNC
           CALL ERRT(101,MESG,NE)
C          STOPS IN ERRT
           GOTO 9999
        ENDIF

        TREFUNC = REFUNC
@


1.84
log
@replaced f90 specific dat-and_time call with date & time calls
@
text
@d94 1
d117 4
d166 8
a173 3
        NULL = CHAR(0)
	RESULM(8:8)=CHAR(0)
	LOGM(4:4)=CHAR(0)
@


1.83
log
@initialized qstrq in loop not in data statement (for f90)
@
text
@a200 3
#ifdef SP_F90
	CALL DATE_AND_TIME(CDAT)
#else
a202 1
#endif
@


1.82
log
@removed IPRTT initialization (unused)
@
text
@a142 2
	DATA (QSTRQ(I:I),I=1,MAXQSTRQ)/MAXQSTRQ*'@@'/,NSTART/1/

d194 5
@


1.81
log
@procedure substituion name changes
@
text
@d158 1
a158 1
	DATA NTRACE/0/,N_VERBOSE/1/,N_MOSAIC/0/,IPRTT/0/,SILENT/.FALSE./
@


1.80
log
@iprtt no longer initialized
@
text
@d18 14
a31 14
C  
C  LUN ASSIGNMENTS: LUN  USUAL   SOURCE  IN BATCH    SOURCE  SINK
C                   NIN      5    NTERM         1     NDISK  B* FILE 
C                   NUNIN    7                               B*X FILE
C                   NDISK    1
C                   NOUT     6    ITI           3     NDAT   OUTPUT
C                   NDAT     3                               RESULT
C                   NECHO    6    ITI           3     NDAT   ECHO
C                   ITI      6                               OUTPUT
C                   ITIN     5                               INPUT
C                   NTERM    5
C                   NPROC    1   NDISK          0     ?      NDISK
C
C                                                               *
d42 2
d158 1
a158 1
	DATA NTRACE/0/,N_VERBOSE/1/,N_MOSAIC/0/,SILENT/.FALSE./
d919 38
a956 52
        NGO        = INDEX(QSTRQ(IPQ1+1:LENQSTRQ),'#') + IPQ1 + 1
        NEND       = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 3
        FUNCNU(1:) = QSTRQ(NGO:NEND) // NULL
        NOCHAR     = NEND - NGO + 1

C       REMOVE THE PARAMETER FROM THE INPUT STRING (FOR SIMPLICITY)       
        REFUNC(1:NUMCHR-IP2+1) = REFUNC(IP2+1:NUMCHR) // NULL
        NUMCHR                 = NUMCHR - IP2

	IF (NUMCHR .GT. 0 .AND. 
     &     (REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x')) THEN
C          CASE OF SYMBOLIC PARAMETER PLUS REGISTER SUBSTITUTION
C          (E.G.  <**>X**) CAN WANT A  FILENAME LIKE 
C          TST000,TST999,TST***,TST****,STX0,TST0X0,TSTX11, OR TST0X11

C          DETERMINE AMOUNT OF FUNCNU TO CHOP AWAY
           IX = 3

C          KLUDGE FOR FUNCNU INPUT LIKE TSTX0  AND TST0X0
           IF (ISDIGI(FUNCNU(NOCHAR:NOCHAR)) .AND.
     &        (FUNCNU(NOCHAR-1:NOCHAR-1) .EQ. 'X' .OR.
     &         FUNCNU(NOCHAR-1:NOCHAR-1) .EQ. 'x')) IX = 2

C          KLUDGE FOR FUNCNU INPUT LIKE: IMA99001 AND
C                     REFUNC INPUT LIKE: X0 (Altered Nov 92 al)
           IF (NUMCHR .EQ. 2 .AND. ISDIGI(REFUNC(2:2)) .AND.
     &        (REFUNC(1:1) .EQ. 'X' .OR. REFUNC(1:1) .EQ. 'x')) THEN
              REFUNC(3:3) = REFUNC(2:2)
              REFUNC(NUMCHR:NUMCHR) = '0'
              NUMCHR = 3
           ENDIF

           WRITE(NUNIN,90) FUNCNU(1:NOCHAR-IX),REFUNC(1:NUMCHR)

        ELSEIF (ISCHAR(REFUNC(NUMCHR:NUMCHR))) THEN 
C          DETERMINE IF OLD-STYLE LOOP INDEX SUBSTITUTION WANTED
C          NOTE: THIS FAILS WITH * BUT I AM NOT SURE OF SIDE-EFFECTS
C                SO I WILL LEAVE IT HERE! al
           IX = 0
           DO I = 1,(NUMCHR-1)
             IF ((REFUNC(I:I) .EQ. '0' .OR. REFUNC(I:I) .EQ. '*').AND. 
     &            ISCHAR(REFUNC(I+1:I+1))) IX = I + 1
           ENDDO

           IF (IX .GT. 0) THEN
C             SYMBOLIC PARAM. & LOOP INDEX SUBSTITUTION (E.G. '<*>**I')
              IF (NOCHAR .EQ. 3) IX = 0
C             DO NOT CHOP ANYTHING IF ONLY A SERIES PREFIX!
              WRITE(NUNIN,90) FUNCNU(1:NOCHAR-IX),REFUNC(1:NUMCHR)
           ELSE
              WRITE(NUNIN,90) FUNCNU(1:NOCHAR)
           ENDIF
d959 1
a959 1
C          IF NEITHER OF THE ABOVE, COPY WHOLE STRING
@


1.79
log
@bad numprcnam typo fixed
@
text
@d156 1
a156 1
	DATA NTRACE/0/,N_VERBOSE/1/,N_MOSAIC/0/,IPRTT/0/,SILENT/.FALSE./
@


1.78
log
@trap for <5>{***x21} added
@
text
@d594 1
a594 1
	DO L1 = 1, NUMPRCNAM 
@


1.77
log
@goto lb1 does not interfere with do loops form previous level now
created maxprcnam for proc. name storage insted of maxprc
@
text
@d951 4
a954 2
	ELSE
C          FIND OUT LOOP INDEX SUBSTITUTION WANTED
d962 1
a962 2
C             CASE OF SYMBOLIC PARAMETER PLUS LOOP INDEX SUBSTITUTION 
C             (E.G. '<*>**I'
a965 1

a966 1
C             IF NEITHER OF THE ABOVE, COPY SUBSTITUTED STRING ONLY
d969 4
@


1.76
log
@findlbq needed iflevel for label
@
text
@d41 2
a42 1
	PARAMETER (MAXPRC = 12) 
d73 1
a73 1
	INTEGER   IDOSTK(4,MAXPRC),NARGSREC(MAXPRC),RDUMS(NPARG)
d83 1
a83 1
        CHARACTER *(NNAME)    PROCFL(MAXPRC)
d119 1
a119 1
        DATA CVERS/'VERSION:  UNIX  4.9    ISSUED: 01/26/98'/ 
d132 1
a132 1
        DATA CVERS/'VERSION:  VMS  15.7    ISSUED: 01/26/98  '/ 
d166 1
a166 1
        DO  I=1,4
d190 1
a190 1
	DO L1=1,MAXPRC
d588 2
a589 2
        IF (NUMPRC .GT. MAXPRC) THEN
C          TOO MANY PROCEDURE LEVELS
d594 1
a594 1
	DO L1 = 1, NUMPRC 
a595 1

d620 1
a620 1
2080	NUMPRC = NUMPRC+1
d1221 1
d1235 2
d1255 1
@


1.75
log
@defined common commun here also
@
text
@d1316 1
a1316 1
C LOGICAL IF ------------------------------------------------------ IF
d1354 2
a1355 1
	CALL FINDLBQ(LABEL,IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,IDUM,IRTFLG)
@


1.74
log
@new version # , included iobuf common sizing
@
text
@d105 1
a105 1
C       MAKE SURE FIRST SIZING OF IOBUF IS LARGEST
d108 4
@


1.73
log
@modified ifdef for f90 compatibility
@
text
@d105 3
d114 1
a114 1
        DATA CVERS/'VERSION:  UNIX  4.8    ISSUED: 11/13/97'/ 
d127 1
a127 1
        DATA CVERS/'VERSION:  VMS  15.6    ISSUED: 9/19/97  '/ 
@


1.72
log
@used pramxv for updateing proc. registers instead of param
@
text
@d1079 3
a1081 2
#if defined(SP_SUN4) || defined (SP_F90)
	OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND')      
d1083 7
a1089 2
	OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND',
     &       CARRIAGECONTROL='LIST')      
@


1.71
log
@more register passing bugs
@
text
@d670 1
a670 1
             PARAM(IARGSREC(I,ISTOP)) = PARAM(IARGSENT(I,ISTOP))
@


1.70
log
@FILNAMSUB could occur with old register sub alos
@
text
@d757 11
a767 1
        ELSEIF (NCHAR .GE. 3 .AND. ISDIGI(TCHAR)) THEN
d769 8
a776 8
C          ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REGISTER
           TCHAR = FUNCNU(NCHAR-1:NCHAR-1)
           IGO   = 0

           IF (TCHAR .EQ. 'X' .OR. TCHAR .EQ. 'x') THEN
C             CHANGE TO UPPERCASE, IF NECESSARY
              IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-1:NCHAR-1) = 'X'
              IGO = NCHAR
d778 6
a783 5
           ELSEIF (ISDIGI(TCHAR)) THEN
              TCHAR = FUNCNU(NCHAR-2:NCHAR-2)
              IF (TCHAR .EQ. 'X' .OR. TCHAR .EQ. 'x') THEN
                 IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-2:NCHAR-2) = 'X'
                 IGO = NCHAR - 1
a784 1
           ENDIF
d786 20
a805 17
           IF (IGO .GT. 0) THEN
C             HAVE A REGISTER IN FILE NAME
              READ(FUNCNU(IGO:NCHAR),8001,IOSTAT=IER) IREG
8001          FORMAT(I2)
              IF (IER .NE. 0) THEN
C                STOPS IN ERRT
                 CALL ERRT(101,'#1 ERROR IN REGISTER SUBSTITUTION',NE)
              ENDIF
              IREG = IREG + 1
              N1   = PRAMSV(ISTOP,IREG) + 0.5
C             PREPARE SUBSTITUTION PATTERN
              FUNCNU(IGO-1:IGO+1) = '***'
              NCHAR = IGO+1
              CALL FILGET(FUNCNU,FUNCNU,NCHAR,N1,IER)
              IF (IER .NE. 0) THEN
C                STOPS IN ERRT
                 CALL ERRT(101,'#1B ERROR IN REGISTER SUBSTITUTION',NE)
a807 9
        ENDIF
        IF (NSUB .GT. 0) THEN
C          NEW STYLE ({***??}) SUBTITUTION PATTERN
C          PASS THE CURRENT PARAM SET TO FILNAMSUB
	   DO I=1,103
              CURPARAM(I) = PRAMSV(ISTOP,I)
           ENDDO
C          SUBSTITUTE FOR {***X??} IN THE FUNCNU STRING
           CALL FILNAMSUB(FUNCNU,NCHAR,.TRUE.,CURPARAM,IRTFLG)
@


1.69
log
@increased MAXPRC
@
text
@d795 2
a796 1
        ELSEIF (NSUB .GT. 0) THEN
@


1.68
log
@used filnamsub for {***x11} into proceedure, fixed trace, changed proceedure start **   to -- string
@
text
@d41 1
a41 1
	PARAMETER (MAXPRC = 10) 
@


1.67
log
@fixed ERROR: IF..ELSE NESTING LEVEL EXCEEDED
@
text
@d68 1
a68 1
        REAL      PRAMSV(MAXPRC,103)
d295 2
a296 1
	   IF (IABSLP .NE. 0) WRITE(ITI,9040) DINDEX,IABSLP
d468 1
a468 1
            CALL ERRT(101,'MESG',NE)
d489 1
a489 1
          PRAMSV(ISTOP,I)=PARAM(I)
d532 1
a532 1
6380	FORMAT(/,' ** START OF: ',A,'    **')
d797 6
a802 12
           ILOCX = INDEX(FUNCNU(IGOSUB:IENDSUB),'X') 
           IF (ILOCX .LE. 0) ILOCX = INDEX(FUNCNU(IGOSUB:IENDSUB),'x')
           IF (ILOCX .GT. 0) THEN
C             NEW STYLE {***X??} SUBSTITUTION NEEDED, (NOT FOR {***I})
              READ(FUNCNU(ILOCX+1:IENDSUB),8001,IOSTAT=IER) IREG
              IF (IER .NE. 0) THEN
C                ALWAYS STOPS IN ERRT IN BATCH MODE
                 CALL ERRT(101,'#2 ERROR IN REGISTER SUBSTITUTION',NE)
              ENDIF
              IVALT = PRAMSV(ISTOP,IREG) + 0.5
              CALL FILNAMSUB(FUNCNU,NCHAR,.TRUE.,IVAL,IRTFLG)
          ENDIF
d866 1
a866 1
           WRITE(6,*)    '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
d1160 1
a1160 1
	DO 8740 I = INEXT+1, INEXT+5
d1162 8
a1169 7
          IF ((FCHAR(I+IWH:I+IWH) .EQ. 'X')
     &        .OR. (FCHAR(I+IWH:I+IWH) .EQ. 'x')) GOTO 8740
          IF (.NOT. ISDIGI(FCHAR(I+IWH:I+IWH))) GOTO 8760
          READ(FCHAR(I+IWH:I+IWH),8660) ITEMP
C         THE UPPER LIMIT IS PUT IN NLOOP
          NLOOP = NLOOP*10 + ITEMP
8740	CONTINUE
a1176 1

@


1.66
log
@fixed {***x45} substitution into ?xxxx? binding time
@
text
@d1290 1
a1290 2
	   CALL FINDLBQ('ENDIF',0,NULL,IDOFLG,IRTFLG)
           IFLEVEL = IFLEVEL - 1
d1325 4
a1328 2
C          'IF' IS FALSE JUMP TO CORRESPONDING ELSE
           CALL FINDLBQ('ELSE',IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,IRTFLG)
d1341 1
a1341 1
	CALL FINDLBQ(LABEL,IDO,LDOSTK(IDOTOP)(1:2),IDOFLG,IRTFLG)
@


1.65
log
@changed version #
@
text
@d724 2
d794 14
@


1.64
log
@changed DATE_AND_TIME call inorder to test f90
@
text
@d111 1
a111 1
        DATA CVERS/'VERSION:  UNIX  4.7    ISSUED: 9/19/97 '/ 
@


1.63
log
@ifdef f90 for date_and_time
@
text
@d189 1
a189 1
	CALL DATE_AND_TIME(CDAT,CTIM)
@


1.62
log
@changed iffile
@
text
@d188 1
d190 4
@


1.61
log
@modified intrinsic function call for f90 compatibility
@
text
@d1270 1
a1270 1
           IFLEVEL = IFLEVEL + 1
@


1.60
log
@ifdef for F90 for carriage-control
@
text
@d188 1
a188 2
	CALL DATE(CDAT)
	CALL TIME(CTIM)
@


1.59
log
@ifdef F90 for carriagecontrols.
@
text
@d223 1
a223 1
#ifndef SP_UNIX
d235 1
a235 1
#ifdef SP_SUN4
a237 3
#ifdef SP_F90
	OPEN(NPROC,FILE=LOG,STATUS='UNKNOWN',IOSTAT=IER)
#else
a240 1
#endif
d1059 1
a1059 1
#ifdef SP_SUN4
a1061 3
#ifdef SP_F90
	OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND')
#else      
a1063 1
#endif
@


1.58
log
@ifdev VMS around $named variable
@
text
@d238 3
d244 2
d1066 3
d1072 2
@


1.57
log
@*** empty log message ***
@
text
@d75 3
a77 1
	INTEGER   ISET,SYS$SETPRN
@


1.56
log
@*** empty log message ***
@
text
@a786 1
#ifdef SP_SUN4
a787 3
#else
        OPEN(NIN,FILE=TNAME,STATUS='UNKNOWN',READONLY)
#endif
@


1.55
log
@added ifile setting
@
text
@d139 2
a140 2
	DATA RESULM(1:7),RESULM(8:8)/'results',0/
	DATA LOGM(1:3),LOGM(4:4)/'LOG',0/
d152 2
@


1.54
log
@if..else added, error handling improved
@
text
@d281 1
a281 1
        IF (NALPH  .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5000 
d1269 1
d1336 2
a1337 3
C       IF NULL OPERATION READ ANOTHER, OTHERWISE PROCESS THE OPERATION
	IF (NALPH .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5000   
	GOTO 5300
@


1.53
log
@added common block size, fixed procedure tags = content bug
@
text
@d18 14
a31 1
C                                                                      *
d40 1
a40 1
C	MAXIMUM NESTING FOR PROCEDURES & DO LOOPS
d70 2
d76 1
a76 1
	LOGICAL   JUMP,EX,ISDIGI,ISCHAR
d84 1
d109 1
a109 1
        DATA CVERS/'VERSION:  UNIX  4.5    ISSUED: 7/25/97 '/ 
d119 2
a120 2
        ONOSF = .FALSE.
        ONSGI = .FALSE.
d122 1
a122 1
        DATA CVERS/'VERSION:  VMS  15.4    ISSUED: 7/25/97  '/ 
d143 1
a143 1
	DATA INFLUN/2/,NDAT/3/,NTERM/5/,NUNIN/7/,NDISK/1/,IFOUND/1/
d145 1
a145 1
	DATA IDOTOP/1/
d203 4
d214 1
a214 1
C          GET THE PROJECT AND DATA CODE FROM USER
d221 1
a221 1
C       BE  RUNNING UNDER SAME PROJECT AND DATA CODE - DON'T LET IT.
d262 2
a263 2
	WRITE(NDAT,1790) PRJEXC(1:3),DATEXC(1:3)
1790	FORMAT(/' PROJECT CODE: ',A3,'   DATA CODE: ',A3)
d265 1
a265 3
        MAXDIMMB = MAXDIM / 1000000
        WRITE(NDAT,1791) MAXDIM
1791    FORMAT(' YOU HAVE           ',I5,' MB OF COMMON BLOCK MEMORY')
d267 2
a268 2
        IF (MEMALLOCABLE .GT. 0) WRITE(NDAT,1792) MEMALLOCABLE
1792    FORMAT(' YOU HAVE REQUESTED ',I5,' MB OF RUN_TIME MEMORY'/)
d272 1
a272 1
	GOTO 5200
d277 1
a277 1
5200	IRTFLG = -999
d281 1
a281 1
        IF (NALPH  .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5200 
d334 1
a334 1
           GOTO 5200
d339 4
d345 1
a345 1
C           CARRY OUT THE OPERATION EN, DO, LB, EX, RE, IF, GO
d353 4
a356 7
	IF (IFLAG .EQ. 0) GOTO 5000

C       EXPRESSION IS NO GOOD - IF BATCH, TERMINATE
6850	WRITE (NOUT, *) '*** UNDEFINED EXPRESSION:',FCHAR
	IF (COPT .EQ. 'B') THEN
	   WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED EXPRESSION'
           GOTO 9999
d361 2
a362 2
9999    CALL ENDIT(INFLUN)
	STOP '**** FATAL ERROR DURING PROCEDURE RUN'
d378 1
a378 15

5000	IF (COPT .EQ. 'B') THEN
C         IN BATCH MODE
          IF (N_VERBOSE .EQ. 1)  WRITE(NDAT,*) ' '

          IF (PARAM(10) .NE. 0.0) THEN
C           ERROR FLAG SWITCHED ON, TERMINATE IMMEDIATELY
            WRITE (ITI,  5050)
            WRITE (NOUT, 5050)
5050        FORMAT(' *** FATAL ERROR IN BATCH RUN')
            GOTO 9999
          ENDIF
        ENDIF
        GOTO 5200

a379 2


d397 2
a398 1
           WRITE(NOUT,*) '*** PROCEDURE FILE CANNOT CALL BATCH FILE'
d417 1
a417 1
	IF (IER.NE.0) GOTO 9999
d425 1
a425 1
C       IF NOT A BATCH FILE TRY USER'S DIRECTORY & PROJECT CODE
d432 3
a434 5
            WRITE(NOUT,5820) TNAME(1:NTNAME) 
5820        FORMAT(' *** PROCEDURE FILE DOES NOT EXIST: ',A) 
            IF (COPT .EQ. 'I') GOTO 5000
C           IF BATCH RUN, TERMINATE 
            GOTO 9999
d446 1
a446 1
             IF (IER .NE. 0) GOTO 9999
d451 1
a451 1
          IF (IER .NE. 0) GOTO 9999
d457 3
a459 5
5800        WRITE(NOUT,5821) TNAME 
5821        FORMAT(' *** PROCEDURE FILE.SYS DOES NOT EXIST: ',A) 
            IF (COPT .EQ. 'I') GOTO 5000
C           IF BATCH RUN, TERMINATE 
            GOTO 9999
d470 1
a470 1
           GOTO 9999
d653 1
a653 1
	     GOTO 9999
d725 1
a725 2
             WRITE(NOUT,*) '*** #2 ERROR IN REGISTER SUBSTITUTION'
             GOTO 9999
d769 2
a770 2
                WRITE(NOUT,*) '*** #1 ERROR IN REGISTER SUBSTITUTION'
                GOTO 9999
d779 2
a780 2
                WRITE(NOUT,*) '*** #1B ERROR IN REGISTER SUBSTITUTION'
                GOTO 9999
d850 6
a855 7
           WRITE(NOUT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
           WRITE(NOUT,*) '*** OFFENDING INPUT: ',REFUNC
           IF (NOUT .NE. NDAT) THEN
              WRITE(NDAT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
              WRITE(NDAT,*) '*** OFFENDING INPUT: ',REFUNC
              GOTO 9999
           ENDIF
d865 3
a867 2
           WRITE(NDAT,*)'*** UNDECIPHERABLE SYMBOLIC PARAMETER IN: ',
     &                  TREFUNC(:NUMCHR)
a877 3
	   WRITE(NDAT,3120) REFUNC(IP1:IP2)
    	   IF (NDAT .NE. NOUT) WRITE(NOUT,3120) REFUNC(IP1:IP2)
3120	   FORMAT(' *** CAN NOT FIND SYMBOLIC REFERENCE FOR: ',A)
d880 5
d954 1
a954 1
           WRITE(NOUT,*)'*** OPERATION NOT ALLOWED IN INTERACTIVE MODE'
d957 2
a958 2
C          TOO MANY RETURNS
           WRITE(NDAT,*) '*** TOO MANY PROCEDURE RETURNS GIVEN '
d1035 2
a1036 3
            WRITE(NDAT,10130)
10130       FORMAT(' *** NO "EN"  ENCOUNTERED. TERMINATION ASSUMED')
            GOTO 9999
d1069 1
a1069 1
C       END SPIDER. ------------------------------------------- EX,EN
d1072 2
a1073 3
8400	CLOSE(NIN)
        CALL ENDIT(INFLUN)
	CLOSE(NDISK)
d1078 1
a1078 1
C START OF DO LOOP ----------------------------------------------- DO
d1092 2
a1093 2
           WRITE(NOUT,*)'*** OPERATION NOT ALLOWED IN INTERACTIVE MODE'
           GOTO 5000
d1175 1
d1177 1
d1192 4
a1195 4
C END OF DO LOOP ------------------------------------------------- LB
C IF # IN LB# IS THE SAME AS CURRENT DO-LOOP, CONTINUE AS
C USUAL AT THE END OF A DO-LOOP.  OTHERWISE, IGNORE THE LABEL
C AND GO BACK TO OPERATION AND READ IN THE NEXT LINE.
d1197 1
a1197 4
8800    IF (COPT .EQ. 'I') THEN
           WRITE(NOUT,*)'*** OPERATION NOT ALLOWED IN INTERACTIVE MODE'
           GOTO 5000
        ENDIF
d1222 2
a1223 1
             WRITE(ITI,*) '*** END-OF-FILE DURING READ IN SEARCHQ'
d1255 3
a1257 2
C       THE CURRENT DO-LOOP, GO BACK TO LOGICAL IF.
	IF (IDOFLG.EQ.1) GOTO 10870
d1263 17
d1281 8
a1288 4

C LOGICAL IF ---------------------------------------------------- IF
10800   IF (COPT .EQ. 'I') THEN
           WRITE(NOUT,*)'*** OPERATION NOT ALLOWED IN INTERACTIVE MODE'
d1291 14
a1304 7
        CALL LOGIFQ(FCHAR,LABEL,JUMP,IER)
        IF (IER .NE. 0) THEN
C          ERROR DETECTED, CAN NOT JUMP
           PARAM(10) = 1.0
           GOTO 5000
	ELSEIF (IER .EQ. 0 .AND. .NOT. JUMP) THEN
C          NO ERROR AND DO NOT WANT TO JUMP
d1308 3
a1310 3
C       IF FIRST LABEL ELEMENT IS BLANK, THIS IS ARITHMETIC EXPRESSION.
C       DO NOT JUMP
        IF (LABEL(1:1).EQ.' ') GOTO 5000
d1312 2
a1313 1
	IF (.NOT. ISDIGI(LABEL(4:4))) LABEL(4:4) = ' '
d1316 11
a1326 6
	IF (IDO .NE. 1) THEN
           CALL SEARCHQ(LABEL,IER)
           IF (IER.NE.0) THEN
             WRITE(NOUT,10860) LABEL(1:4)
10860        FORMAT(' *** LABEL NOT FOUND: ',A4)
             GOTO 9999
d1328 1
a1328 1
           GOTO 10870
d1331 3
a1333 5
	CALL FINDLBQ(LABEL,LDOSTK(IDOTOP)(1:1),IDOFLG,IER)
	IF (IER.NE.0)THEN
          WRITE(NOUT,10860)
          GOTO 9999
        ENDIF
d1335 2
a1336 10
C       IDOFLG=1 IMPLIES WE HAVE PASSED BY THE CURRENT DO-LOOP LABEL,
C       SO WE MUST POP THE DO-LOOP STACK
        IF (IDOFLG.NE.0) GOTO 8820
10870	FCHAR(1:4) = LABEL(1:4)

C       SIMULATE ECHO OF OPERATION TO RESULTS FILE
	WRITE(NDAT,10880) FCHAR(1:4)
10880	FORMAT(' .OPERATION:',5X,A)
	IDOFLG = 0
	IF (NALPH .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5200   
@


1.52
log
@changed version #
@
text
@d242 2
a243 2
	WRITE(NDAT,1750) PRJEXC(1:3),DATEXC(1:3)
1750	FORMAT(/' PROJECT CODE: ',A3,'   DATA CODE: ',A3)
d245 6
a250 2
        IF (MEMALLOCABLE .GT. 0) WRITE(NDAT,1751) MEMALLOCABLE
1751    FORMAT(' YOU HAVE REQUESTED ',I5,' MB OF RUN_TIME MEMORY'/)
d796 1
a796 1
2820	IF ((LENQSTRQ + NCHAR + NQSTRQ + 3) .GE. MAXQSTRQ) THEN
d833 2
a834 2
        LENQSTRQ = LENQSTRQ + NCM1 + 3 + NCHAR
        QSTRQ(LENQSTRQ+1:) = '#'
d889 1
a889 1
        NEND       = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 2
@


1.51
log
@comments after ?...? caused problem, also <1> after ?...? were wrong
@
text
@d93 1
a93 1
        DATA CVERS/'VERSION:  UNIX  4.4    ISSUED: 5/13/97 '/ 
d106 1
a106 1
        DATA CVERS/'VERSION:  VMS  15.3    ISSUED: 5/13/97  '/ 
@


1.50
log
@typo in NQSTRQ in line 792
@
text
@d803 9
a812 3
CC        IP1    = INDEX(REFUNC(1:NUMCHR),'<') + 1
CC        IP2    = INDEX(REFUNC(1:NUMCHR),'>') - 1
CC        NCM1   = IP2 - IP1
d824 1
@


1.49
log
@cosmetic & used charinside
@
text
@d792 1
a792 1
2820	IF ((LENQSTRQ + NCHAR + NOSTRQ + 3) .GE. MAXQSTRQ) THEN
@


1.48
log
@parameter numbering put back in
@
text
@d3 3
a5 3
C
C MAIN SPIDER SUBROUTINE
C
d19 2
a20 2
C        0         2         3         4         5         6         7
C2345678901235678901234567890123456789012345678901234567890123456789012
d619 1
a619 1
C       LENQSTRQ IS THE INDEX FOR THE TEMPORARY ARRAY
d670 1
a670 3
        ELSEIF ((REFUNC(1:1) .NE. '?' .AND. REFUNC(1:1) .NE. '<') .OR. 
     &          (REFUNC(NUMCHR:NUMCHR) .NE. '?' .AND.
     &           REFUNC(NUMCHR:NUMCHR) .NE. '>')) THEN
d801 6
a806 3
        IP1    = INDEX(REFUNC(1:NUMCHR),'<') + 1
        IP2    = INDEX(REFUNC(1:NUMCHR),'>') - 1
        NCM1   = IP2 - IP1
d812 2
a813 2
           NC = NUMDIG(NQSTRQ,1) 
           WRITE(FMT(3:3),8002) NC
d815 1
a815 4
           WRITE(QSTRQ(IQGO+1:IQGO+NC),FMT) NQSTRQ
           QSTRQ(IQGO+NC+1:IQGO+NC+1)       = '#'
           QSTRQ(IQGO+NC+2:IQGO+NC+1+NCHAR) = FUNCNU(1:NCHAR)
           LENQSTRQ = LENQSTRQ + NC + 2 + NCHAR
d818 1
a818 4
           QSTRQ(IQGO+1:IQGO+1+NCM1)            = REFUNC(IP1:IP2)
           QSTRQ(IQGO+NCM1+2:IQGO+NCM1+2)       = '#'
           QSTRQ(IQGO+NCM1+3:IQGO+NCM1+3+NCHAR) = FUNCNU(1:NCHAR)
           LENQSTRQ = LENQSTRQ + NCM1 + 3 + NCHAR
d820 3
d850 3
d857 1
a857 1
     &                  REFUNC(:NUMCHR)
a861 1

d876 1
a876 3
C       SUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER 

C       FOUND THE STRING IN QSTRQ, COPY STRING TO FUNCNU
d882 1
a882 1
C       REMOVE THE PARAMETER FROM THE INPUT STRING        
@


1.47
log
@reverted to revision 1.46
@
text
@d16 2
a17 2
C  PLEASE UPDATE FIRST DATA STATEMENT (MARKED BY $S) EVERY TIME        *
C  THE PROGRAM IS CHANGED!                                             *
d20 1
a20 1
C23456789012345678901234567890123456789012345678901234567890123456789012
d37 1
a37 1
	PARAMETER (MAXTMP=2000)  
a48 1
        INTEGER   NNAME
d63 1
a63 1
	CHARACTER *(MAXTMP)   TMPARY
d69 1
a69 1
        CHARACTER *80         FUNCNU,REFUNC
d92 2
a93 2
C                   123456789 123456789 123456789 123456789 
        DATA CVERS/'VERSION:  UNIX  4.3    ISSUED: 4/11/97 '/ 
d106 1
a106 1
        DATA CVERS/'VERSION:  VMS  15.3    ISSUED: 4/11/97  '/ 
d115 1
a115 1
	DATA (TMPARY(I:I),I=1,MAXTMP)/MAXTMP*'@@'/,NSTART/1/
a154 3
C       INITIALIZE TAPE RECORD COUNT TO NEGATIVE VALUE
        IRECT = -1

d330 1
a330 1
6850	WRITE (NOUT, *) '*** EXPRESSION NOT DEFINED:',FCHAR
d332 2
a333 2
	   WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED OPERATION'
           GOTO 7199
d338 1
a338 2
7199    CALL PDATES('TERMINATED',-1)
7200	CALL ENDIT(INFLUN)
d348 3
a350 3
 	IF (IDXTMP .GE. 1) THEN
	   DO I = 1, IDXTMP
            TMPARY(I:I) = '@@'
d353 2
a354 1
	IDXTMP=0
d365 1
a365 3
            CALL PDATES('TERMINATED',-1)
            CALL ENDIT(INFLUN)
	    STOP 
d391 1
a391 1
           GOTO 7199
d409 1
a409 1
	IF (IER.NE.0) GOTO 7200
d428 1
a428 1
            GOTO 7199
d440 1
a440 1
             IF (IER .NE. 0) GOTO 7200
d445 1
a445 1
          IF (IER .NE. 0) GOTO 7200
d455 1
a455 1
            GOTO 7199
d466 1
a466 1
           GOTO 7199
d599 1
a599 1
2080	NUMPRC=NUMPRC+1
d619 4
a622 3
C       IDXTMP IS THE INDEX FOR THE TEMPORARY ARRAY
	IDXTMP = 0
	IPCNT  = 0
d629 4
a632 10
        IF (ONUNIX) THEN
C          UNIX DOES NOT SUPPORT Q FORMAT CORRECTLY ON SOME SYSTEMS
           READ(NIN,2389,END=3600) REFUNC
C          FIND LAST NON-BLANK            
           NUMCHR = lnblnk(REFUNC)
        ELSE
           READ(NIN, 2391, END = 3600) NUMCHR, REFUNC
2391	   FORMAT(Q,A80)
        ENDIF
	IPCNT = IPCNT + 1
d649 1
a649 1
	     GOTO 7200
d661 1
a661 1
	  NUMCHR = NLEN + 1
a667 1
           IF (REFUNC(1:1) .EQ. 'p') REFUNC(1:1) = 'P' 
d670 4
a673 3
        ELSEIF (REFUNC(1:1) .NE. '?') THEN
C          NOT PROCEDURE QUESTION OR SYMBOLIC PARAMETER,
C          SUBSTITUTE ENTIRE STRING
d681 1
a681 1
	NUMCHR = NUMCHR + 1
d685 3
a687 1
	    WRITE(ITI,2330)  REFUNC(1:NUMCHR)
d691 3
a693 8
            IF (ONUNIX) THEN
C              UNIX DOES NOT USE Q FORMAT CORRECTLY ON SOME SYSTEMS
               READ(ITIN,2389) FUNCNU
C              FIND LAST NON-BLANK            
               NCHAR = lnblnk(FUNCNU)
            ELSE
	       READ(ITIN,2390) NCHAR,FUNCNU(1:NCHAR)
            ENDIF
d703 1
a703 1
	IWHERE = IWHERE + 1
d706 4
a709 10
        IF (ONUNIX) THEN
C          UNIX DOES NOT SUPPORT Q FORMAT CORRECTLY ON SOME SYSTEMS
           READ(NIN,2389) FUNCNU
2389       FORMAT(A)
C          FIND LAST NON-BLANK            
           NCHAR = lnblnk(FUNCNU)
        ELSE
	   READ(NIN,2390) NCHAR,FUNCNU(:NCHAR)
2390       FORMAT(Q,A80)
        ENDIF
a711 6
C       FIND LAST NON-BLANK CHARACTER IN THE LINE
        DO K=NCHAR,1,-1
          IF (FUNCNU(K:K) .NE. ' ') GOTO 2393
        ENDDO

2393    NCHAR = K
d724 1
a724 1
             GOTO 7199
d736 1
a736 1
             IFN2   = ABS(IREGST(2))
d746 1
a746 1
C          ADDED 6/02/83 FOR A FILENAME CONTAINING A REGISTER
d750 3
a752 7
           IF (TCHAR .EQ. 'X') THEN
              IGO = NCHAR

           ELSEIF (TCHAR .EQ. 'x') THEN
C             CHANGE TO UPPERCASE
              TCHAR = 'X'
              FUNCNU(NCHAR-1:NCHAR-1) = TCHAR
d758 2
a759 3
                 TCHAR = 'X'
                 IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-2:NCHAR-2) = TCHAR
                 IGO = NCHAR -1
d769 1
a769 1
                GOTO 7199
d779 1
a779 1
                GOTO 7199
a780 6

C             FIND LAST NON-BLANK CHARACTER
              DO K = 80, 1,-1
                 IF (FUNCNU(K:K) .NE. ' ') GOTO 2720
              ENDDO
2720          CONTINUE
d791 1
a791 1
          READ(NIN,90) DUM
d794 2
a795 1
2820	IF (IDXTMP+NCHAR .GT. MAXTMP) THEN
d800 26
a825 2
        TMPARY(IDXTMP+1:IDXTMP+NCHAR+1) = FUNCNU(1:NCHAR) // ';'
	IDXTMP = IDXTMP + NCHAR + 1
d835 1
a835 1
C ------   SYMBOLIC PARAMETER SUBSTITUTION SECTION --------------------
d837 2
a838 2
C IF FIRST TWO CHARACTERS ARE 'P' AND DIGIT OR '<' AND DIGIT -- ASSUME 
C SYMBOLIC PARAMETER SUBSTITIUTION.
d840 9
a848 28
C       INTERPRET THE FIRST DIGIT AS PART OF SYMBOLIC PARAMETER COUNT
2900    IDIG = 1
        IF (ISDIGI(REFUNC(3:3))) IDIG = 2

        IF (REFUNC(1:1) .EQ. 'P' .OR. REFUNC(1:1) .EQ. 'p') THEN
C          OLD STYLE 'P' PARAMETER SUBSTITUTION
           WRITE(NOUT,*) '*** PLEASE CONVERT TO <*> SYMBOLIC PARAMETERS'
C          FOR OLD STYLE SYMBOLIC PARAMETER REFERENCE (P*) THE
C          THIRD CHARACTER CAN BE 'X' OF A REGISTER, AS IN 'P1X10' OR
C          IF A '00' SEQUENCE AS IN 'P100I' IS FOUND -- DO NOT ATTEMPT 
C          TO INTERPRET FIRST '0' AS PART OF SYMBOLIC PARAMETER COUNT

C          ALTERED JAN 90 TO AVOID BUG WITH P1000I
           IF (REFUNC(3:5) .EQ. '000' .AND. ISCHAR(REFUNC(6:6))) IDIG=2
           IGO = IDIG + 2

        ELSE
           IF (ISDIGI(REFUNC(3:3)) .AND. ISDIGI(REFUNC(4:4))) IDIG = 3
           IGO = IDIG + 3
        ENDIF

C       INTERPRET THE PARAMETER NUMBER -- ISYM
        WRITE(FMT(3:3),2902) IDIG
2902    FORMAT(I1)
        READ(REFUNC(2:IDIG+1), FMT,IOSTAT=IER) ISYM
        IF (IER .NE. 0) THEN
            WRITE(NDAT,*) ISYM,' : ',REFUNC(2:IDIG+1)
            GOTO 3119
d851 36
a886 34
C       SCAN THE TEMPORARY ARRAY TO FIND ISYM-TH STRING WHICH IS USED 
C       FOR SUBSTITUTION.  STRINGS ARE SEPARATED BY SEMICOLONS.

        ICNT   = 0
	ISEMSV = 0

	DO ISEMI = 1, IDXTMP
          IF (TMPARY(ISEMI:ISEMI) .EQ. ';') THEN
            ICNT = ICNT + 1
            IF (ICNT .GE. ISYM) GOTO 3200
            ISEMSV = ISEMI
          ENDIF
        ENDDO

C       UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER -- NOTIFY USER
        WRITE(NDAT,*) 'ISEMI,ICNT,ISYM:',ISEMI,ICNT,ISYM
        WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES:',TMPARY

3119	IF (NDAT .NE. NOUT) WRITE(NOUT,3120)
	WRITE(NDAT,3120) ISYM
3120	FORMAT(' *** UNRESOLVED SYMBOLIC REFERENCE, PARAMETER:',I5,
     &         ' NOT FOUND.')
	GOTO 7199

C SUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER 
C COPY FROM TEMPORARY ARRAY ACCORDING TO SYMBOLIC PARAMETER COUNT
C NEEDED INFO IS IN TMPARY BETWEEN THE SEMICOLONS.

3200	NOCHAR = ISEMI - ISEMSV - 1
        FUNCNU(1:NOCHAR+1) = TMPARY(ISEMSV+1:ISEMSV+NOCHAR) // NULL

C       REMOVE THE PARAMETER FROM THE STRING        
        REFUNC(1:NUMCHR-IGO+2) = REFUNC(IGO:NUMCHR) // NULL
        NUMCHR = NUMCHR - IGO + 1
d891 2
a892 3
C          (E.G. P*X**  OR  P**X**  OR  <**>X**)
C          P COULD BE A FILENAME LIKE TST000, TST999, TST*** ,TST****,
C          TSTX0, TST0X0, TSTX11, OR TST0X11
d923 1
a923 1
C             (E.G. 'P*00I' OR '<*>**I'
d949 1
a949 1
           GOTO 7199
d987 5
d995 3
a997 6
        ITE = INDEX(BNAME,NULL)
        IF (ITE .LE. 1) THEN
           ITE = LEN(BNAME)
        ELSE
           ITE = ITE -1
        ENDIF
d1003 1
d1006 4
d1016 1
a1016 1
C       NEW BNAME IS NAME AT TOP OF STACK.
d1018 4
a1021 10
C        IF (IBCNT.EQ.0) GOTO 5000
C        OTHERWISE, OFFSET IT FOR SOLICITATIONS THAT WERE DONE BY
C        PROCEDURE CALLED BY THIS PROCEDURE, AND SET IWHERE BACK TO 0
C        IF (IWHERE.GT.IBCNT) IBCNT=IWHERE
C        IWHERE=0
C        GET US TO WHERE WE SHOULD START, THEN GO READ

C        IF WE ARE NOW EMPTY, AND LAST FILE WAS A PROCEDURE, THEN GO
C        BACK TO INTERACTIVE MODE.  IF LAST FILE WAS A BATCH FILE,
C        THEN USER FORGOT TO 'EN', AND LET HIM KNOW.
d1023 1
d1027 1
a1027 1
            GOTO 7199
d1168 1
a1168 1
           GOTO 7199
d1216 1
a1216 1
             GOTO 7199
d1283 1
a1283 1
             GOTO 7199
d1291 1
a1291 1
          GOTO 7199
@


1.46
log
@changed ?jajdfj?<1> recognition
@
text
@d16 2
a17 2
C  PLEASE UPDATE VERSION STATEMENT (MARKED BY CHERE) EVERY TIME        *
C  THE VERSION IS CHANGED!                                             *
d20 1
a20 1
C2345678901235678901234567890123456789012345678901234567890123456789012
d37 1
a37 1
	PARAMETER (MAXQSTRQ=2000)  
d49 1
d64 1
a64 1
	CHARACTER *(MAXQSTRQ) QSTRQ
d70 1
a70 1
        CHARACTER *80         FUNCNU,REFUNC,TREFUNC
d93 2
a94 2
CHERE               123456789 123456789 123456789 123456789 
        DATA CVERS/'VERSION:  UNIX  4.4    ISSUED: 5/13/97 '/ 
d107 1
a107 1
        DATA CVERS/'VERSION:  VMS  15.3    ISSUED: 5/13/97  '/ 
d116 1
a116 1
	DATA (QSTRQ(I:I),I=1,MAXQSTRQ)/MAXQSTRQ*'@@'/,NSTART/1/
d156 3
d334 1
a334 1
6850	WRITE (NOUT, *) '*** UNDEFINED EXPRESSION:',FCHAR
d336 2
a337 2
	   WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED EXPRESSION'
           GOTO 9999
d342 2
a343 1
9999    CALL ENDIT(INFLUN)
d353 3
a355 3
 	IF (LENQSTRQ .GE. 1) THEN
	   DO I = 1, LENQSTRQ
              QSTRQ(I:I) = '@@'
d358 1
a358 2
	LENQSTRQ = 0
        NQSTRQ   = 0
d369 3
a371 1
            GOTO 9999
d397 1
a397 1
           GOTO 9999
d415 1
a415 1
	IF (IER.NE.0) GOTO 9999
d434 1
a434 1
            GOTO 9999
d446 1
a446 1
             IF (IER .NE. 0) GOTO 9999
d451 1
a451 1
          IF (IER .NE. 0) GOTO 9999
d461 1
a461 1
            GOTO 9999
d472 1
a472 1
           GOTO 9999
d625 3
a627 4
C       LENQSTRQ IS THE INDEX FOR THE TEMPORARY ARRAY
	LENQSTRQ = 0
        NQSTRQ   = 0
	IPCNT    = 0
d634 10
a643 4
        READ(NIN,2389,END=3600) REFUNC
C       FIND LAST NON-BLANK            
        NUMCHR = lnblnk(REFUNC)
	IPCNT  = IPCNT + 1
d660 1
a660 1
	     GOTO 9999
d679 1
d682 3
a684 4
        ELSEIF ((REFUNC(1:1) .NE. '?' .AND. REFUNC(1:1) .NE. '<') .OR. 
     &          (REFUNC(NUMCHR:NUMCHR) .NE. '?' .AND.
     &           REFUNC(NUMCHR:NUMCHR) .NE. '>')) THEN
C          NOT PROCEDURE QUESTION, SUBSTITUTE ENTIRE STRING
d696 1
a696 3
            IGO   = INDEX(REFUNC(1:NUMCHR),'?')
            IEND  = INDEX(REFUNC(IGO+1:NUMCHR),'?') + IGO
	    WRITE(ITI,2330)  REFUNC(IGO:IEND)
d700 8
a707 3
            READ(ITIN,2389) FUNCNU
C           FIND LAST NON-BLANK            
            NCHAR = lnblnk(FUNCNU)
d717 1
a717 1
	IWHERE        = IWHERE + 1
d720 10
a729 4
        READ(NIN,2389) FUNCNU
2389    FORMAT(A)
C       FIND LAST NON-BLANK            
        NCHAR = lnblnk(FUNCNU)
d732 6
d750 1
a750 1
             GOTO 9999
d762 1
a762 1
             IFN2  = ABS(IREGST(2))
d772 1
a772 1
C          ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REGISTER
d776 7
a782 3
           IF (TCHAR .EQ. 'X' .OR. TCHAR .EQ. 'x') THEN
C             CHANGE TO UPPERCASE, IF NECESSARY
              IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-1:NCHAR-1) = 'X'
d788 3
a790 2
                 IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-2:NCHAR-2) = 'X'
                 IGO = NCHAR - 1
d800 1
a800 1
                GOTO 9999
d810 1
a810 1
                GOTO 9999
d812 6
d828 1
a828 1
           READ(NIN,90) DUM
d831 1
a831 2
2820	IF ((LENQSTRQ + NCHAR + NOSTRQ + 3) .GE. MAXQSTRQ) THEN
C          OVERUN OF QSTRQ ARRAY, (I ADDED SOME SLOP FOR USE OF NQSTRQ)
d836 2
a837 26
C       PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
        NQSTRQ = NQSTRQ   + 1
        IQGO   = LENQSTRQ + 1
        IP1    = INDEX(REFUNC(1:NUMCHR),'<') + 1
        IP2    = INDEX(REFUNC(1:NUMCHR),'>') - 1
        NCM1   = IP2 - IP1

        QSTRQ(IQGO:IQGO) = '#'

        IF (NCM1 .LT. 0) THEN
C          NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRQ
           NC = NUMDIG(NQSTRQ,1) 
           WRITE(FMT(3:3),8002) NC
8002       FORMAT(I1)
           WRITE(QSTRQ(IQGO+1:IQGO+NC),FMT) NQSTRQ
           QSTRQ(IQGO+NC+1:IQGO+NC+1)       = '#'
           QSTRQ(IQGO+NC+2:IQGO+NC+1+NCHAR) = FUNCNU(1:NCHAR)
           LENQSTRQ = LENQSTRQ + NC + 2 + NCHAR
        ELSE
C          <#> AVAILABLE IN QUERY STRING
           QSTRQ(IQGO+1:IQGO+1+NCM1)            = REFUNC(IP1:IP2)
           QSTRQ(IQGO+NCM1+2:IQGO+NCM1+2)       = '#'
           QSTRQ(IQGO+NCM1+3:IQGO+NCM1+3+NCHAR) = FUNCNU(1:NCHAR)
           LENQSTRQ = LENQSTRQ + NCM1 + 3 + NCHAR
        ENDIF
        QSTRQ(LENQSTRQ+1:) = '#'
d847 1
a847 1
C ------  BEGIN SYMBOLIC PARAMETER SUBSTITUTION SECTION ---------------
d849 2
a850 2
C       IF FIRST TWO CHARACTERS ARE 'P' AND DIGIT OR '<' AND DIGIT 
C       ASSUME SYMBOLIC PARAMETER SUBSTITIUTION.
d852 28
a879 9
2900    IF (REFUNC(1:1) .EQ. 'P' .OR. REFUNC(1:1) .EQ. 'p') THEN
C          OLD STYLE 'P#' PARAMETER SUBSTITUTION
           WRITE(NOUT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
           WRITE(NOUT,*) '*** OFFENDING INPUT: ',REFUNC
           IF (NOUT .NE. NDAT) THEN
              WRITE(NDAT,*) '*** CONVERT TO <#> SYMBOLIC PARAMETERS'
              WRITE(NDAT,*) '*** OFFENDING INPUT: ',REFUNC
              GOTO 9999
           ENDIF
d882 13
a894 30
        TREFUNC = REFUNC
        IP1     = INDEX(TREFUNC(1:NUMCHR),'<') 
        IP2     = INDEX(TREFUNC(1:NUMCHR),'>') 
        IF (IP1 .LT. 1 .OR. IP2 .LE. IP1) THEN
           WRITE(NDAT,*)'*** UNDECIPHERABLE SYMBOLIC PARAMETER IN: ',
     &                  REFUNC(:NUMCHR)
           GOTO 9999
        ENDIF

C       SCAN THE QSTRQ ARRAY TO FIND STRING FOR SUBSTITUTION.

        TREFUNC(IP1:IP1) = '#'
        TREFUNC(IP2:IP2) = '#'
        IPQ1   = INDEX(QSTRQ(1:LENQSTRQ),TREFUNC(IP1:IP2))

        IF (IPQ1 .LE. 0) THEN
C          UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER -- NOTIFY USER
	   WRITE(NDAT,3120) REFUNC(IP1:IP2)
    	   IF (NDAT .NE. NOUT) WRITE(NOUT,3120) REFUNC(IP1:IP2)
3120	   FORMAT(' *** CAN NOT FIND SYMBOLIC REFERENCE FOR: ',A)
           WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES: ',
     &                   QSTRQ(1:LENQSTRQ)
	   GOTO 9999
        ENDIF

C       FOUND THE STRING IN QSTRQ 
        NGO        = INDEX(QSTRQ(IPQ1+1:LENQSTRQ),'#') + IPQ1 + 1
        NEND       = INDEX(QSTRQ(NGO:LENQSTRQ+1),'#')  + NGO - 2
        FUNCNU(1:) = QSTRQ(NGO:NEND) // NULL
        NOCHAR     = NEND - NGO + 1
d896 20
a915 1
C       SUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER 
d920 3
a922 2
C          (E.G.  <**>X**) CAN WANT A  FILENAME LIKE 
C          TST000,TST999,TST***,TST****,STX0,TST0X0,TSTX11, OR TST0X11
d953 1
a953 1
C             (E.G. '<*>**I'
d979 1
a979 1
           GOTO 9999
a1016 5
C       MAKE DO LOOP VARIABLE AN INTEGER (E.G. A --> 1) (MAY 97)
	IDXT = ICHAR(DINDEX) - 64
C       IALPHA(LETTER CONVERTED TO NUMBER) CONTAINS IABSLP (MAY 97)
	IALPHA(IDXT) = IABSLP

d1020 6
a1025 3
        ITE = INDEX(BNAME,NULL) - 1
        IF (ITE .LE. 0) ITE = LEN(BNAME)

a1030 1
C          NEW BNAME IS NAME AT TOP OF STACK.
a1032 4

C          OFFSET INPUT FOR SOLICITATIONS THAT WERE DONE BY
C          PROCEDURE CALLED BY THIS PROCEDURE
           IF (IBCNT .EQ. 0) GOTO 5000
d1039 1
a1039 1
C        I DO NOT KNOW WHEN THIS WAS CUT OUT, I GUESS IT IS UNEEDED? al
d1041 10
a1050 4
C        AND SET IWHERE BACK TO 0
C        IF (IWHERE .GT. IBCNT) IBCNT = IWHERE
C        IWHERE = 0

a1051 1
C       IF LAST FILE WAS A BATCH FILE, THEN USER FORGOT 'EN'
d1055 1
a1055 1
            GOTO 9999
d1196 1
a1196 1
           GOTO 9999
d1244 1
a1244 1
             GOTO 9999
d1311 1
a1311 1
             GOTO 9999
d1319 1
a1319 1
          GOTO 9999
@


1.45
log
@added parameter input line labels, reset 00i, other clean up of code
@
text
@d670 3
a672 2
        ELSEIF (REFUNC(1:1) .NE. '?' .AND. 
     &          REFUNC(NUMCHR:NUMCHR) .NE. '?') THEN
@


1.44
log
@MAXIMUM NUMBER OF PROCEDURE REGISTER ARGUMENTS increased to 12
@
text
@d16 2
a17 2
C  PLEASE UPDATE FIRST DATA STATEMENT (MARKED BY $S) EVERY TIME        *
C  THE PROGRAM IS CHANGED!                                             *
d20 1
a20 1
C23456789012345678901234567890123456789012345678901234567890123456789012
d37 1
a37 1
	PARAMETER (MAXTMP=2000)  
a48 1
        INTEGER   NNAME
d63 1
a63 1
	CHARACTER *(MAXTMP)   TMPARY
d69 1
a69 1
        CHARACTER *80         FUNCNU,REFUNC
d92 2
a93 2
C                   123456789 123456789 123456789 123456789 
        DATA CVERS/'VERSION:  UNIX  4.3    ISSUED: 4/11/97 '/ 
d106 1
a106 1
        DATA CVERS/'VERSION:  VMS  15.3    ISSUED: 4/11/97  '/ 
d115 1
a115 1
	DATA (TMPARY(I:I),I=1,MAXTMP)/MAXTMP*'@@'/,NSTART/1/
a154 3
C       INITIALIZE TAPE RECORD COUNT TO NEGATIVE VALUE
        IRECT = -1

d330 1
a330 1
6850	WRITE (NOUT, *) '*** EXPRESSION NOT DEFINED:',FCHAR
d332 2
a333 2
	   WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED OPERATION'
           GOTO 7199
d338 1
a338 2
7199    CALL PDATES('TERMINATED',-1)
7200	CALL ENDIT(INFLUN)
d348 3
a350 3
 	IF (IDXTMP .GE. 1) THEN
	   DO I = 1, IDXTMP
            TMPARY(I:I) = '@@'
d353 2
a354 1
	IDXTMP=0
d365 1
a365 3
            CALL PDATES('TERMINATED',-1)
            CALL ENDIT(INFLUN)
	    STOP 
d391 1
a391 1
           GOTO 7199
d409 1
a409 1
	IF (IER.NE.0) GOTO 7200
d428 1
a428 1
            GOTO 7199
d440 1
a440 1
             IF (IER .NE. 0) GOTO 7200
d445 1
a445 1
          IF (IER .NE. 0) GOTO 7200
d455 1
a455 1
            GOTO 7199
d466 1
a466 1
           GOTO 7199
d619 4
a622 3
C       IDXTMP IS THE INDEX FOR THE TEMPORARY ARRAY
	IDXTMP = 0
	IPCNT  = 0
d629 4
a632 10
        IF (ONUNIX) THEN
C          UNIX DOES NOT SUPPORT Q FORMAT CORRECTLY ON SOME SYSTEMS
           READ(NIN,2389,END=3600) REFUNC
C          FIND LAST NON-BLANK            
           NUMCHR = lnblnk(REFUNC)
        ELSE
           READ(NIN, 2391, END = 3600) NUMCHR, REFUNC
2391	   FORMAT(Q,A80)
        ENDIF
	IPCNT = IPCNT + 1
d649 1
a649 1
	     GOTO 7200
a667 1
           IF (REFUNC(1:1) .EQ. 'p') REFUNC(1:1) = 'P' 
d670 3
a672 3
        ELSEIF (REFUNC(1:1) .NE. '?') THEN
C          NOT PROCEDURE QUESTION OR SYMBOLIC PARAMETER,
C          SUBSTITUTE ENTIRE STRING
d684 3
a686 1
	    WRITE(ITI,2330)  REFUNC(1:NUMCHR)
d690 3
a692 8
            IF (ONUNIX) THEN
C              UNIX DOES NOT USE Q FORMAT CORRECTLY ON SOME SYSTEMS
               READ(ITIN,2389) FUNCNU
C              FIND LAST NON-BLANK            
               NCHAR = lnblnk(FUNCNU)
            ELSE
	       READ(ITIN,2390) NCHAR,FUNCNU(1:NCHAR)
            ENDIF
d702 1
a702 1
	IWHERE = IWHERE + 1
d705 4
a708 10
        IF (ONUNIX) THEN
C          UNIX DOES NOT SUPPORT Q FORMAT CORRECTLY ON SOME SYSTEMS
           READ(NIN,2389) FUNCNU
2389       FORMAT(A)
C          FIND LAST NON-BLANK            
           NCHAR = lnblnk(FUNCNU)
        ELSE
	   READ(NIN,2390) NCHAR,FUNCNU(:NCHAR)
2390       FORMAT(Q,A80)
        ENDIF
a710 6
C       FIND LAST NON-BLANK CHARACTER IN THE LINE
        DO K=NCHAR,1,-1
          IF (FUNCNU(K:K) .NE. ' ') GOTO 2393
        ENDDO

2393    NCHAR = K
d723 1
a723 1
             GOTO 7199
d735 1
a735 1
             IFN2   = ABS(IREGST(2))
d745 1
a745 1
C          ADDED 6/02/83 FOR A FILENAME CONTAINING A REGISTER
d749 3
a751 7
           IF (TCHAR .EQ. 'X') THEN
              IGO = NCHAR

           ELSEIF (TCHAR .EQ. 'x') THEN
C             CHANGE TO UPPERCASE
              TCHAR = 'X'
              FUNCNU(NCHAR-1:NCHAR-1) = TCHAR
d757 2
a758 3
                 TCHAR = 'X'
                 IF (TCHAR .EQ. 'x') FUNCNU(NCHAR-2:NCHAR-2) = TCHAR
                 IGO = NCHAR -1
d768 1
a768 1
                GOTO 7199
d778 1
a778 1
                GOTO 7199
a779 6

C             FIND LAST NON-BLANK CHARACTER
              DO K = 80, 1,-1
                 IF (FUNCNU(K:K) .NE. ' ') GOTO 2720
              ENDDO
2720          CONTINUE
d790 1
a790 1
          READ(NIN,90) DUM
d793 2
a794 1
2820	IF (IDXTMP+NCHAR .GT. MAXTMP) THEN
d799 26
a824 2
        TMPARY(IDXTMP+1:IDXTMP+NCHAR+1) = FUNCNU(1:NCHAR) // ';'
	IDXTMP = IDXTMP + NCHAR + 1
d834 1
a834 1
C ------   SYMBOLIC PARAMETER SUBSTITUTION SECTION --------------------
d836 2
a837 2
C IF FIRST TWO CHARACTERS ARE 'P' AND DIGIT OR '<' AND DIGIT -- ASSUME 
C SYMBOLIC PARAMETER SUBSTITIUTION.
d839 9
a847 28
C       INTERPRET THE FIRST DIGIT AS PART OF SYMBOLIC PARAMETER COUNT
2900    IDIG = 1
        IF (ISDIGI(REFUNC(3:3))) IDIG = 2

        IF (REFUNC(1:1) .EQ. 'P' .OR. REFUNC(1:1) .EQ. 'p') THEN
C          OLD STYLE 'P' PARAMETER SUBSTITUTION
           WRITE(NOUT,*) '*** PLEASE CONVERT TO <*> SYMBOLIC PARAMETERS'
C          FOR OLD STYLE SYMBOLIC PARAMETER REFERENCE (P*) THE
C          THIRD CHARACTER CAN BE 'X' OF A REGISTER, AS IN 'P1X10' OR
C          IF A '00' SEQUENCE AS IN 'P100I' IS FOUND -- DO NOT ATTEMPT 
C          TO INTERPRET FIRST '0' AS PART OF SYMBOLIC PARAMETER COUNT

C          ALTERED JAN 90 TO AVOID BUG WITH P1000I
           IF (REFUNC(3:5) .EQ. '000' .AND. ISCHAR(REFUNC(6:6))) IDIG=2
           IGO = IDIG + 2

        ELSE
           IF (ISDIGI(REFUNC(3:3)) .AND. ISDIGI(REFUNC(4:4))) IDIG = 3
           IGO = IDIG + 3
        ENDIF

C       INTERPRET THE PARAMETER NUMBER -- ISYM
        WRITE(FMT(3:3),2902) IDIG
2902    FORMAT(I1)
        READ(REFUNC(2:IDIG+1), FMT,IOSTAT=IER) ISYM
        IF (IER .NE. 0) THEN
            WRITE(NDAT,*) ISYM,' : ',REFUNC(2:IDIG+1)
            GOTO 3119
d850 30
a879 13
C       SCAN THE TEMPORARY ARRAY TO FIND ISYM-TH STRING WHICH IS USED 
C       FOR SUBSTITUTION.  STRINGS ARE SEPARATED BY SEMICOLONS.

        ICNT   = 0
	ISEMSV = 0

	DO ISEMI = 1, IDXTMP
          IF (TMPARY(ISEMI:ISEMI) .EQ. ';') THEN
            ICNT = ICNT + 1
            IF (ICNT .GE. ISYM) GOTO 3200
            ISEMSV = ISEMI
          ENDIF
        ENDDO
d881 1
a881 20
C       UNSUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER -- NOTIFY USER
        WRITE(NDAT,*) 'ISEMI,ICNT,ISYM:',ISEMI,ICNT,ISYM
        WRITE(NDAT,*) 'STORED SYMBOLIC REFERENCES:',TMPARY

3119	IF (NDAT .NE. NOUT) WRITE(NOUT,3120)
	WRITE(NDAT,3120) ISYM
3120	FORMAT(' *** UNRESOLVED SYMBOLIC REFERENCE, PARAMETER:',I5,
     &         ' NOT FOUND.')
	GOTO 7199

C SUCCESSFUL SEARCH FOR THIS PARAMETER NUMBER 
C COPY FROM TEMPORARY ARRAY ACCORDING TO SYMBOLIC PARAMETER COUNT
C NEEDED INFO IS IN TMPARY BETWEEN THE SEMICOLONS.

3200	NOCHAR = ISEMI - ISEMSV - 1
        FUNCNU(1:NOCHAR+1) = TMPARY(ISEMSV+1:ISEMSV+NOCHAR) // NULL

C       REMOVE THE PARAMETER FROM THE STRING        
        REFUNC(1:NUMCHR-IGO+2) = REFUNC(IGO:NUMCHR) // NULL
        NUMCHR = NUMCHR - IGO + 1
d886 2
a887 3
C          (E.G. P*X**  OR  P**X**  OR  <**>X**)
C          P COULD BE A FILENAME LIKE TST000, TST999, TST*** ,TST****,
C          TSTX0, TST0X0, TSTX11, OR TST0X11
d918 1
a918 1
C             (E.G. 'P*00I' OR '<*>**I'
d944 1
a944 1
           GOTO 7199
d982 5
d990 3
a992 6
        ITE = INDEX(BNAME,NULL)
        IF (ITE .LE. 1) THEN
           ITE = LEN(BNAME)
        ELSE
           ITE = ITE -1
        ENDIF
d998 1
d1001 4
d1011 1
a1011 1
C       NEW BNAME IS NAME AT TOP OF STACK.
d1013 4
a1016 10
C        IF (IBCNT.EQ.0) GOTO 5000
C        OTHERWISE, OFFSET IT FOR SOLICITATIONS THAT WERE DONE BY
C        PROCEDURE CALLED BY THIS PROCEDURE, AND SET IWHERE BACK TO 0
C        IF (IWHERE.GT.IBCNT) IBCNT=IWHERE
C        IWHERE=0
C        GET US TO WHERE WE SHOULD START, THEN GO READ

C        IF WE ARE NOW EMPTY, AND LAST FILE WAS A PROCEDURE, THEN GO
C        BACK TO INTERACTIVE MODE.  IF LAST FILE WAS A BATCH FILE,
C        THEN USER FORGOT TO 'EN', AND LET HIM KNOW.
d1018 1
d1022 1
a1022 1
            GOTO 7199
d1163 1
a1163 1
           GOTO 7199
d1211 1
a1211 1
             GOTO 7199
d1278 1
a1278 1
             GOTO 7199
d1286 1
a1286 1
          GOTO 7199
@


1.43
log
@changed version & cosmetic
@
text
@d46 1
a46 1
	PARAMETER (NPARG=6)     
@


1.42
log
@lost code for loop limits in do loop (for 99999) rewritten
@
text
@d94 1
a94 1
        DATA CVERS/'VERSION:  UNIX  4.2    ISSUED: 1/14/97 '/ 
d107 1
a107 1
        DATA CVERS/'VERSION:  VMS  15.2    ISSUED: 1/14/97  '/ 
d251 1
a251 2


d1232 1
a1232 1
          IBCNT=0
d1255 2
a1256 2
8820	NUMREP=1
	ILOOP=1
d1281 1
a1281 3



@


1.41
log
@removed "Ex" actully same as "en" code, changed endit paramaters
@
text
@d1142 1
a1142 1
	DO 8700 I = 1, 4
d1164 1
a1164 1
	DO 8740 I = INEXT+1, INEXT+4
@


1.40
log
@changed version
@
text
@d344 2
a345 2
7200	CALL ENDIT(INFLUN,NFNAME,LOG,NLOG,IDUM)
	STOP '**** UNEXPECTED ERROR DURING PROCEDURE RUN'
d371 1
a371 1
            CALL ENDIT(INFLUN,NFNAME,LOG,NLOG,IDUM)
d1089 1
a1089 1
C       CLOSE AND DELETE THE LOG FILE. --------------------------- EN
d1091 1
d1093 3
a1095 2
	INQUIRE(FILE=BNAME,EXIST=EX)
        CALL ENDIT(INFLUN,NFNAME,LOG,NLOG,IDUM)
a1096 4
C       IF BATCH, NPROC=0, SO MAKE NPROC=1 EVEN IF INTERACTIVE.
	NPROC = NDISK
	CLOSE(NPROC)
	STOP '**** SPIDER NORMAL STOP ****'
a1282 18
C       CLOSE THE LOG FILE, THEN RENAME IT AND STOP.--------------- EX
8900    IF (COPT .EQ. 'B') THEN
C          IN BATCH MODE, AND USER TRIED 'EX', ASSUME HE WANTED 'EN'
           WRITE(NOUT,*) '*** ATTEMPTED TERMINATION ASSUMED'
           CALL PDATES('COMPLETED',-1)
        ELSE
           WRITE(NOUT,8920)
8920	   FORMAT(1X,$'.NEW NAME FOR LOG FILE: ')
           READ(NIN,8940) LOG1M(1:3)
8940	   FORMAT(A3)
           LOG1M(4:4) = NULL
           CALL FILCAN(LOG1,NLOG1,NULL,NULL,LOG1M,PRJEXC,IER)  
           WRITE(NECHO,8941) LOG1(1:NLOG1)
8941       FORMAT(5X,A)
        ENDIF

	CALL ENDIT(INFLUN,NFNAME,LOG,NLOG,IDUM)
	STOP '**** SPIDER STOP ****'
@


1.39
log
@added memallocable output message
@
text
@d94 1
a94 1
        DATA CVERS/'VERSION:  UNIX  4.1    ISSUED: 9/18/96 '/ 
d107 1
a107 1
        DATA CVERS/'VERSION:  VMS  15.1    ISSUED: 9/18/96  '/ 
@


1.38
log
@CHANGED COMMON OPSYS
@
text
@d249 4
@


1.37
log
@register arguments not passed to called proc. correct
@
text
@a79 3
	COMMON /SUBDAT/MENU

C       COMMON OPSYS IS UNIX VS VMS FLAG
d81 1
a81 1
        COMMON /OPSYS/ ONSUN,ONUNIX,ONSGI,ONOSF
@


1.36
log
@put ifdef around SET$PRN use
@
text
@d667 1
a667 1
             PARAM(IARGSREC(I,ISTOP)) = IARGSENT(I,ISTOP-1)
@


1.35
log
@added goto operation code
@
text
@d206 6
a211 6
        IF (.NOT. ONUNIX) THEN
C          IF  LOG FILE EXISTS WITH SAME EXTENSION, ANOTHER PROCESS MAY
C          BE  RUNNING UNDER SAME PROJECT AND DATA CODE - DON'T LET IT.
           CSEND(4:6) = PRJEXC(1:3)
           ISET = SYS$SETPRN(CSEND)
        ENDIF
@


1.34
log
@added new banner
@
text
@d31 1
a31 1
	PARAMETER (NMENU1 = 6) 
d121 1
a121 1
	DATA MENU1/'EN','DO','LB','EX','RE','IF'/
d250 1
a250 1
1750	FORMAT(/' *** PROJECT CODE: ',A3,2X,' DATA CODE: ',A3,' ***')
d323 2
a324 2
C           CARRY OUT THE OPERATION EN, DO, LB, EX, RE, IF
            GOTO  (8400,  8600,  8800,  8900,  10000, 10800), IFUNC
@


1.33
log
@changed some doc file stuff
@
text
@a32 3
C	MAX. NUMBER OF DOCUMENT FILES ALLOWED IN SAVDOCQ
	PARAMETER (NDOCFL = 20) 

d71 1
a71 2
	CHARACTER *14         CVERS
	CHARACTER *16         CRELS
a87 2
        CHARACTER *81 DCFILE
        COMMON /DOC_DCF/ DCFILE(NDOCFL)
d91 1
d96 2
a97 1
        DATA CVERS/'V04.0  9/10/96'/ 
a100 1
        DATA CRELS/'/(ALBANY   UNIX)'/ 
a103 1
        DATA CRELS/'/(ALBANY    OSF)'/ 
d109 2
a110 2
        DATA CVERS/'V15.0  9/10/96'/ 
        DATA CRELS/'/(ALBANY   VMS)'/ 
d134 2
a135 2
	DATA NTRACE/0/,N_VERBOSE/1/,N_MOSAIC/0/,IPRTT/0/
        DATA LABAH/.TRUE./,ONSUN/.FALSE./,WIDGETS/.FALSE./
d154 1
a154 1
	T1    = SECNDS(0.)
d157 1
a157 1
	COPT  = 'I'
d160 1
a160 1
        IRECT      = -1
d172 1
a172 9
	NUMPRC=0

C       INITIALIZE DCFILE AND NUMFIL FOR SAVE DOCUMENT OPERATION.
	DO L1 = 1,NDOCFL
	  DO L2 = 1,81
	    DCFILE(L1)(L2:L2)= ' '
          ENDDO
        ENDDO
	NUMFIL = 0
a173 4
	WRITE(NOUT,9090)
9090    FORMAT(/' SPIDER  --  COPYRIGHT 1993,  HEALTH RESEARCH INC., ',
     &          'ALBANY, NY'/)

d179 11
a189 2
	WRITE(NOUT,1650) CVERS,CRELS,CDAT,CTIM
1650	FORMAT(' SPIDER      ',A14,A16,' ON ',A9,' AT ',A8/)
d191 3
d242 6
a247 2
	WRITE(NDAT,*) ' '
	WRITE(NDAT,1650) CVERS,CRELS,CDAT,CTIM
d335 5
a339 3
	IF (COPT .NE. 'B') GOTO 5000
	WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED OPERATION'
        GOTO 7199
d362 1
a362 1
          WRITE(NDAT,*) ' '
d628 2
a629 1
	WRITE(NDAT,*) ' '
d1244 6
a1249 1
          WRITE(NOUT, 8860) FCHAR(1:20),IABSLP
d1251 2
a1252 3
          IF (IER .EQ. 0) GOTO 5000
          WRITE(ITI,*) '*** END-OF-FILE DURING READ IN SEARCH'
          GOTO 7199
@


1.32
log
@fixed 1st level argument return
@
text
@d33 1
a33 1
C	MAX. NUMBER OF DOCUMENT FILES ALLOWED
d90 1
a90 2
C       DBUF = DOCUMENT BUFFER FOR DOCUMENT CORE IMAGE 
        COMMON /DOC_DIMS/MAXKEY1,MAXREG1,NKEY,NREG
d94 1
d101 1
a101 1
        DATA CVERS/'V03.7  7/20/96'/ 
d115 1
a115 1
        DATA CVERS/'V14.8  7/20/96'/ 
a145 5

C       PUT DOCFILE UNSAVE PARAMETERS INTO COMMON:
        MAXKEY1 = MAXKEY
        MAXREG1 = MAXREG
        NDOCFL1 = NDOCFL
@


1.31
log
@removed debug output let in by mistake
@
text
@d412 1
a412 1
        CALL FROMTOQ(FCHAR(NFSTRT:),NALPH,'[',']',IARGSENT(1,ISTOP),
d1003 1
a1003 1
              PARAM(IARGSENT(I,ISTOP-1)) = ARGSAV(I)
@


1.30
log
@changed for multi-level register argument passing
reordered layout of sections
many cosmetic changes
new version number
@
text
@d267 1
a267 1
        CALL RDPRMC(FCHAR,NALPH,.TRUE.,'OPERATION$',NULL,IRTFLG)
a678 6

        IF (IPCNT .EQ. 1 ) write(6,*) 'received: ',NARGSREC(ISTOP), 
     &             ' registers at level:',istop



@


1.29
log
@changed version #
@
text
@d7 6
a12 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK        *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY,     *
C *             NY 12201                                               *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH         *
C *    RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS             *
C *    OR USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN        *
C *    APPROVAL OF HEALTH RESEARCH INC.                                *
d15 3
a17 3
C  DRIVER OF SPIDER IMAGE PROCESSING SYSTEM. J.FRANK                   *
C  IMPORTANT : PLEASE UPDATE FIRST DATA STATEMENT (MARKED BY $S)       *
C  EVERY TIME THE PROGRAM IS CHANGED!                                  *
a22 1
#ifdef SP_UNIX
d24 2
a25 3
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
a26 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@ P A R A M E T E R  I N I T I A L I Z A T I O N @@@@@@@@@@@@@@@@@@
d30 1
a30 1
C	NUMBER OF OPERATIONS IN DRIVER-SUBMENU
d42 1
a42 1
C	MAXIMUM NUMBER OF REGISTERS PER KEY IN 'UD IC'
d48 1
a48 1
C	MAXIMUM NUMBER OF DUMMY PROCEDURE ARGUMENTS
d55 1
a55 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d57 1
a57 1
	REAL      RLIST(NPARG),RLIST1(NPARG),ARGSAV(NPARG)
d61 1
a61 1
	INTEGER   IDOSTK(4,MAXPRC)
d63 1
a63 1
	INTEGER   IPLIST(NPARG),IPLIST1(NPARG)
a85 8
C       COMMON VMSCALL USED BY INPUT ROUTINES FOR SPIDER VS STERECON
	LOGICAL          OKVMS,SERSEC,LABAH
        COMMON /VMSCALL/ OKVMS,SERSEC,LABAH  

C       COMMON XWINDOWS INDICATES IF A X-WINDOWS GRAPHICS WINDOW IS OPEN
        LOGICAL WIDGETS
        COMMON /XWINDOWS/IDISPL,IWIN,ISCREEN,MAP,ICONTX,IMAGSAV,WIDGETS

d97 1
a97 1

a98 3
C$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C	** V E R S I O N  ******* R E L E A S E  *****

d101 1
a101 1
        DATA CVERS/'V03.7  5/15/96'/ 
d115 1
a115 1
        DATA CVERS/'V14.8  2/08/96'/ 
d119 1
a119 2
#
C$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
d136 2
a137 3
C LOGICAL UNIT NUMBERS DEFINED HERE
	DATA INFLUN/2/,NDAT/3/,NTERM/5/,IFOUND/1/
	DATA NUNIN/7/,NDISK/1/
d143 2
d147 1
a147 1
C       PUT REGISTER UNSAVE PARAMETERS INTO COMMON:
d263 273
a535 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d537 1
a537 1
C       START BATCH MODE.  SET ALL THE LUNS, AND OPEN THE BATCH FILE.
d557 19
a575 1
     &       .NOT. ISDIGI(FCHAR(3:3)))) GOTO 3900
d578 1
d599 10
a608 6
	IPCARD = 0
	WRITE(NDAT,*) ' '
2050	READ(NIN,3950,END=2080) REFUNC
	IPCARD = IPCARD + 1
	WRITE(NDAT,3960) IPCARD, REFUNC
	GOTO 2050
d614 2
a615 2
C CREATE TEMPORARY PROC FILES--ADD 'X' TO BNAME
C NOTE: IPROC=0  CAME FROM INTERACTIVE MODE WHILE 
d626 2
d649 1
a649 2
C       1/16/86 ----- COPY ARGUMENT LIST IF PRESENT --------------------
C       TRANSFER REGISTER CONTENTS FROM CALLING LEVEL TO CALLED LEVEL
d651 1
a656 1
C         1/16/85 ----- COPY ARGUMENT LIST/ END
d658 6
a663 5
	  CALL FROMTOQ(REFUNC,NUMCHR,'[',']',IPLIST1,RLIST1,
     &                 NLIST1,NPARG)
	  IF (NLIST .NE. NLIST1) THEN
	     WRITE(NOUT,*) '*** ARGUMENTS TO PROCEDURE:',NLIST,
     &                     ' <> ARGUMENTS FROM:',NLIST1
d666 2
d669 3
a671 2
  	  DO I = 1, NLIST
             PARAM(IPLIST1(I)) = RLIST(I)
d677 1
d680 5
d763 2
a764 2
           IFN1   = ABS(IREGST(1))
           P1    = PRAMSV(ISTOP,IFN1)
a830 1

d840 1
d842 1
a842 1
	   CALL ERRT(30,'DRIVER',NE)
d975 1
d977 1
a977 3
C*******************************************************************
C*******************************************************************
C*******************************************************************
a978 4
3600	REWIND NUNIN
	CLOSE(NIN)
	CLOSE(NUNIN)
	OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')
d980 2
a981 7
 	IF (IDXTMP .GE. 1) THEN
	   DO I = 1, IDXTMP
            TMPARY(I:I) = '@@'
           ENDDO
        ENDIF
	IDXTMP=0
	GOTO 5000
d983 8
a990 1
C LIST BATCH FILE 
d992 1
a992 2
3900  IBCARD = 0
      WRITE(NDAT,*) ' '
d994 6
a999 6
3940  READ(NIN, 3950, END = 3980) REFUNC
3950    FORMAT(A80)
        IBCARD = IBCARD+1
        WRITE(NDAT,3960) IBCARD,REFUNC
3960    FORMAT(3X,I4,4X,A80)
      GOTO 3940
d1001 3
a1003 92
3980  REWIND NIN
      GOTO 2100

C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C
C END HANDLING PROCEDURE
C
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

5000	IF (COPT .EQ. 'B') THEN
          WRITE(NDAT,*) ' '

          IF (PARAM(10) .NE. 0.0) THEN
C           ERROR FLAG SWITCHED ON, TERMINATE IMMEDIATELY
            WRITE (ITI,  5050)
            WRITE (NOUT, 5050)
5050        FORMAT(' *** FATAL ERROR IN BATCH RUN')
            GO TO 7199
          ENDIF
        ENDIF

C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ O P E R A T I O N @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C       GET THE OPERATION
5200	IRTFLG = -999
        CALL RDPRMC(FCHAR,NALPH,.TRUE.,'OPERATION$',NULL,IRTFLG)

C       IF OPERATION IS A COMMENT OR NULL, IGNORE IT.
        IF (NALPH  .LT. 1 .OR. FCHAR(:1) .EQ. ';') GOTO 5200 

5300	IF (NTRACE .GT. 0) THEN
           WRITE(ITI,9020) FCHAR(1:NALPH)
9020       FORMAT(1X,A)
	   IF (IABSLP .NE. 0) WRITE(ITI,9040) DINDEX,IABSLP
9040       FORMAT(1X,A,' = ',I4)
        ENDIF

C       IF THE FIRST CHARACTER IS '@@', GOTO PROCEDURE EVALUATION
	IF (FCHAR(:1) .EQ. '@@') GOTO 5600

C       IF THE FIRST OR SECOND CHARACTER IS NEITHER A 
C       LETTER NOR A DIGIT, CONSIDER OPERATION AN EXPRESSION

	IF(((.NOT. ISCHAR(FCHAR(1:1)))   .AND.
     &      (.NOT. ISDIGI(FCHAR(1:1))))   .OR.
     &     ((.NOT. ISCHAR(FCHAR(2:2)))   .AND.
     &      (.NOT. ISDIGI(FCHAR(2:2))))) GOTO 6800

C       IF THE FIRST THREE CHARACTERS ARE LETTERS AND THE FORTH IS '('
C       THEN IT MUST BE AN ON-LINE FUNCTION CALL. GOTO EXPRESSION EVAL.
C       FCHAR(5:5) ALLOWS MIS-TYPING SQRT(...) FOR SQR(...)

        IF ((ISCHAR(FCHAR(1:1))) .AND. (ISCHAR(FCHAR(2:2))) .AND. 
     &      (ISCHAR(FCHAR(3:3))) .AND.
     &	    (FCHAR(4:4).EQ.'('   .OR. FCHAR(5:5).EQ.'(' )) GOTO 6800

C        IF THE OPERATION IS A REGISTER, GOTO EXPRESSION EVALUATOR.
C        (RECOGNIZED BY 'X<DIGIT>' OR 'X<DIGIT><DIGIT>')
        IF ((FCHAR(1:1) .EQ. 'X' .OR. FCHAR(1:1) .EQ. 'x') .AND.
     &      (ISDIGI(FCHAR(2:2)))) GOTO 6800

C       IF A LABEL 'LB<DIGIT> IS FOUND, AND A DO-LOOP IS IN EFFECT ...
	IF ((FCHAR(1:2).EQ.'LB' .OR. (FCHAR(1:2).EQ.'lb')) .AND. 
     &       IDO.EQ.1) GOTO 8800

C       IF A LABEL IS FOUND, AND NO DO-LOOP IS IN EFFECT ...
	IF ((FCHAR(1:2).EQ.'LB' .OR. (FCHAR(1:2).EQ.'lb')) .AND. 
     &       IDO.EQ.0) GOTO 5000

C       CHAR FOLLOWED BY 2 DIGITS IS OLD STYLE BATCH (B01) CALL
	IF (ISCHAR(FCHAR(1:1)) .AND.
     &      ISDIGI(FCHAR(2:2)) .AND. ISDIGI(FCHAR(3:3)) .AND.
     &      NALPH .EQ. 3) GOTO 5600

C       TRANSLATE OPERATION STRING TO UPPER CASE NOW
        CALL SSUPCAS(FCHAR)

C       TSWITCH IS MAIN SELECTION PROGRAM FOR OPERATIONS OUTSIDE DRIVER
        CALL TSWITCH(IWHICH,ICOM,MAXDIM,IRTFLG)
	IF (IRTFLG .EQ. 0) THEN
C          OPERATION FOUND OUTSIDE OF DRIVER, GET NEXT OPERATION
           GOTO 5200
        ENDIF

C       OPERATION IS NOT IN OUTSIDE MENU. SEARCH DRIVER SUBMENU FOR
C       SPECIFIC LOOPING, IF, EN, ETC OPERATIONS
	DO IFUNC = 1, NMENU1
          IF (FCHAR(1:2) .EQ. MENU1(IFUNC)(1:2)) THEN
C           CARRY OUT THE OPERATION EN, DO, LB, EX, RE, IF
            GOTO  (8400,  8600,  8800,  8900,  10000, 10800), IFUNC
          ENDIF
d1006 5
a1010 4
C       ANY REMAINING OPERATION IS ASSUMED TO BE ARITHMETIC EXPRESSION
6800	CALL SSUPCAS(FCHAR)
        CALL ARASQ(FCHAR,NALPH,IFLAG)
	IF (IFLAG .EQ. 0) GOTO 5000
d1012 1
a1012 4
C       EXPRESSION IS NO GOOD - IF BATCH, TERMINATE
6850	WRITE (NOUT, *) '*** EXPRESSION NOT DEFINED:',FCHAR
	IF (COPT .NE. 'B') GOTO 5000
	WRITE(NDAT,*)' *** TERMINATED -- UNDEFINED OPERATION'
d1014 12
a1025 4
C       COMMON TERMINATE ON ERROR SEQUENCE
7199    CALL PDATES('TERMINATED',0)
7200	CALL ENDIT(INFLUN,NFNAME,LOG,NLOG,IDUM)
	STOP '**** UNEXPECTED ERROR DURING PROCEDURE RUN'
d1027 8
a1034 19


C       COMMAND MUST BE OLD PROCEDURE NAME OR BATCH FILE NAME ---------
C       SET FLAG FOR BATCH OR INTERACTIVE MODE WHEN THE PROCEDURE 
C       WAS CALLED

5600    IF (COPT .EQ. 'I') IPROC = 0
	IF (COPT .EQ. 'B') IPROC = 1

C       IF THIS IS FIRST PROCEDURE CALL, OR NEW PROCEDURE IS NOT BATCH, 
C       FILE OR CURRENT PROCEDURE IS A BATCH FILE, THEN  WE'RE OK.  
C       OTHERWISE WE HAVE PROCEDURE CALLING BATCH FILE, DON'T ALLOW IT

C       FCHAR(2:2) IS DIGIT FOR BATCH FILE, A LETTER FOR PROCEDURE FILE 
	IF (ISTOP .NE. 0 .AND. 
     &      (FCHAR(1:1) .EQ. 'B' .OR. FCHAR(1:1) .EQ.'b') .AND.
     &      ISDIGI(FCHAR(2:2)) .AND. ISDIGI(FCHAR(2:2))) THEN
           WRITE(NOUT,*) '*** PROCEDURE FILE CANNOT CALL BATCH FILE'
           GOTO 7199
d1036 12
a1047 4

C       FIND FIRST POSSIBLE CHARACTER IN FILENAME
	NFSTRT = 1
	IF (FCHAR(:1) .EQ. '@@') NFSTRT = 2
d1049 12
a1060 3
C       COPY ARGUMENT LIST IF PRESENT -------------------------------
        CALL FROMTOQ(FCHAR(NFSTRT:),NALPH,'[',']',IPLIST,
     &               RLIST,NLIST,NPARG)
d1062 3
a1064 57
C       IF REGISTERS ARE FOUND, THEN NLIST > 0, CONTENTS ARE STORED
C       IN RLIST. LATER RLIST IS COPIED INTO PROCEDURE REGISTERS 
C       ACCORDING TO DUMMY  ARG. LIST


C       TNAME IS TEMP NAME TO SEE WHERE PROCEDURE EXISTS
C       TNAMEM NEEDS DELIMITER
        IF (ONUNIX .AND. FCHAR(:1) .EQ. '@@') NALPH = NALPH - 1
        TNAMEM(1:NALPH+1) = FCHAR(NFSTRT:NFSTRT+NALPH-1) // NULL
        CALL FILCAN(TNAME,NTNAME,NULL,  NULL,TNAMEM,PRJEXC,IER)  
	IF (IER.NE.0) GOTO 7200

C       PUT TNAME INTO BNAME, CREATE NAME OF TEMPORARY BATCH OR
C       PROCEDURE FILE BY PUTTING LETTER 'X' BEFORE PERIOD.
        BNAME = TNAME(1:NTNAME-4) // 'X' // 
     &          TNAME(NTNAME-3:NTNAME) // NULL

C       IF IT'S A BATCH FILE THE NAME IS CORRECT
C       IF NOT A BATCH FILE TRY USER'S DIRECTORY & PROJECT CODE
C       PROCEDURE FILE

	INQUIRE(FILE=TNAME,EXIST=EX)
        IF (.NOT. EX) THEN
C         FILE DOESN'T EXIST - IF IT'S BATCH FILE GIVE ERROR MESSAGE
          IF (FCHAR(2:2) .LT. 'A') THEN
            WRITE(NOUT,5820) TNAME(1:NTNAME) 
5820        FORMAT(' *** PROCEDURE FILE DOES NOT EXIST: ',A) 
            IF (COPT .EQ. 'I') GOTO 5000
C           IF BATCH RUN, TERMINATE 
            GOTO 7199
          ENDIF
c*********************
            WRITE(NOUT,9045) TNAME 
9045        FORMAT(' NO LOCAL PROCEDURE FILE: ',A) 
c*********************
C         OTHERWISE, TRY AGAIN UNDER 'PROC:*.SYS' IN PROC DIR.
C         SET FLAG INDICATING THAT WE DO HAVE A 'SYS' EXTENSION
C         7/10/88 PROC IS LOGICAL FOR DIRECTORY WHERE *.SYS FILES ARE al

          IF (ONUNIX) THEN
             CALL MYGETENV('SPPROC_DIR',TNAME,NCHART,
     &                     'dir-for-proc-files',IER)
             IF (IER .NE. 0) GOTO 7200
             TNAME = TNAME(:NCHART) // TNAMEM(:NALPH)// '.sys'// NULL
          ELSE 
             CALL FILCAN(TNAME,NTNAME,'PROC',NULL,TNAMEM,'SYS',IER)
          ENDIF
          IF (IER .NE. 0) GOTO 7200

          INQUIRE(FILE=TNAME,EXIST=EX)

          IF (.NOT. EX) THEN
C           THE *.SYS FILE DOES NOT EXIST. NOTIFY USER
5800        WRITE(NOUT,5821) TNAME 
5821        FORMAT(' *** PROCEDURE FILE.SYS DOES NOT EXIST: ',A) 
            IF (COPT .EQ. 'I') GOTO 5000
C           IF BATCH RUN, TERMINATE 
a1065 1
          ENDIF
d1068 3
a1070 8
C       PUT IT ON THE STACK
        ISTOP=ISTOP+1
	IF (ISTOP .GT. MAXPRC) THEN
C          LIMIT IS MAXPRC PROCEDURES !! LET USER KNOW 
           WRITE(NOUT,6170) MAXPRC
6170       FORMAT(' *** PROCEDURE NESTING LEVEL (',I3,') EXCEEDED')
           GOTO 7199
        ENDIF
d1072 9
a1080 36
C       OK- PNAMEC IS LAST USED PROCEDURE FILE-NEEDED FOR SOLICITATIONS.  
C       PUT THE NEW PROCEDURE FILE ON THE STACK
6200    FSTACK(ISTOP) = BNAME

C       SAVE THE REGISTERS
	DO I = 1, 103
          PRAMSV(ISTOP,I)=PARAM(I)
        ENDDO

C       SAVE DO-LOOP INFO
	LOOPSV(ISTOP,1)    = ILOOP
	LOOPSV(ISTOP,2)    = IABSLP
	LOOPSV(ISTOP,3)    = NUMREP
	LOOPSV(ISTOP,4)    = NLOOP
	LOOPSV(ISTOP,5)    = IDO
	LOOPSV(ISTOP,6)    = IDOTOP

	LABLSV(ISTOP)(1:2) = DOLOOP(6:7)
	LABLSV(ISTOP)(3:3) = DINDEX

C       RE-SET DO-LOOP INFO FOR PROCEDURE
	ILOOP  = 1
	IABSLP = 0
	NLOOP  = 0
	NUMREP = 1
	IDO    = 0

C       PUT THE ARGS ON THE STACK
C       PUT IBCNT ON STACK, IF IT ISN'T FIRST CALL, STACK OFFSET
	PSTACK(ISTOP)=IBCNT
	IF (ISTOP.GT.1) THEN
          PNAMEC(:NNAME) = FSTACK(ISTOP-1)(:NNAME)

C         OFFSET NOW EQUAL TO POINTER
C         WRITE IT, SINCE NOT ECHOED IN RESULTS FILE IN INTERACTIVE MODE
          IWHERE = IBCNT
d1083 1
a1083 5
        IF (COPT .EQ. 'I') THEN
          WRITE(NDAT, 6320)
6320	  FORMAT(/,' .OPERATION:')
          WRITE(NDAT, 6340) FCHAR(1:80)
6340      FORMAT(5X,A)
d1085 9
a1093 3
C         WE'RE NOW IN BATCH MODE, WRITE OUT HEADING.
          COPT = 'B'
        ENDIF
d1095 1
a1095 4
	WRITE(NDAT, 6380) TNAME(1:NTNAME)
6380	FORMAT(/,' ** START OF: ',A)
	WRITE(NDAT, 6390)
6390	FORMAT('+',43X,'**')
a1096 6
C       RESET ERROR FLAGS FOR BATCH RUNS ONLY, SET THE LUNS
	IF (FCHAR(2:2) .LT. 'A') THEN
           PARAM(100) = 0
           PARAM(10)  = 0
        ENDIF
	GOTO 1800
d1221 1
d1294 1
a1294 1
           CALL PDATES('COMPLETED',0)
a1309 122
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C
C RETURN FROM PROCEDURE------------------------------------------- RE
C
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

C ISTOP TELLS US HOW DEEPLY NESTED WE ARE.  POINTS TO CURRENT
C TOP OF STACK, WHICH IS CURRENT PROCEDURE OR BATCH FILE.
C TOO MANY RETURNS

10000   IF (COPT .EQ. 'I') THEN
           WRITE(NOUT,*)'*** OPERATION NOT ALLOWED IN INTERACTIVE MODE'
           GOTO 5000
        ELSEIF (ISTOP .LE. 0) THEN
           WRITE(NDAT,*) '*** TOO MANY RETURNS SPECIFIED '
           GOTO 7199
	ENDIF

C       TAKE IT OFF THE STACK, AND CLOSE IT UP
C       RETRIEVE REGISTER VALUES

C       ------ COPY ARGUMENT LIST ----------------------------
C       FIRST SAVE REGISTER VALUES SPECIFIED IN DUMMY ARGUMENT LIST

	IF (NLIST.NE.0) THEN
	  DO I=1,NLIST
            ARGSAV(I) = PARAM(IPLIST1(I))
          ENDDO
	ENDIF

	DO I=1,103
          PARAM(I)=PRAMSV(ISTOP,I)
        ENDDO

C       NOW OVERWRITE REGISTERS PASSED ON TO PROCEDURE
	IF (NLIST.NE.0) THEN
	   DO I=1,NLIST
              PARAM(IPLIST(I))=ARGSAV(I)
           ENDDO
	ENDIF
C       ------ COPY ARGUMENT LIST /END

C       RETRIEVE DO-LOOP INFO
	ILOOP       = LOOPSV(ISTOP,1)
	IABSLP      = LOOPSV(ISTOP,2)
	NUMREP      = LOOPSV(ISTOP,3)
	NLOOP       = LOOPSV(ISTOP,4)
	IDO         = LOOPSV(ISTOP,5)
	IDOTOP      = LOOPSV(ISTOP,6)
	DOLOOP(6:7) = LABLSV(ISTOP)(1:2)
	DINDEX      = LABLSV(ISTOP)(3:3)
	IBCNT       = PSTACK(ISTOP)
	ISTOP       = ISTOP-1
	CLOSE(NIN)

C       TAKE 'X' OUT FOR PRINTING
        ITX = INDEX(BNAME,'X.')
	IF (ITX .LE. 0)  ITX = INDEX(BNAME,'x.')
        ITE = INDEX(BNAME,NULL)
        IF (ITE .LE. 1) THEN
           ITE = LEN(BNAME)
        ELSE
           ITE = ITE -1
        ENDIF
	WRITE(NDAT,10080) BNAME(1:ITX-1),BNAME(ITX+1:ITE)
10080	FORMAT(/,' ** END OF: ',A,A)
          
C       SIGNAL END OF CURRENT PROCEDURE OR BATCH
	IF (ISTOP .GT. 0) THEN
           BNAME(1:NNAME) = FSTACK(ISTOP)(1:NNAME)
	   OPEN(NIN,FILE=BNAME,STATUS='UNKNOWN')
	   DO I=1,IBCNT
              READ(NIN, 90) DUM
           ENDDO
	   GOTO 5000
	ENDIF

C NEW BNAME IS NAME AT TOP OF STACK.
C IF THIS IS THE FIRST TIME THE FILE IS ACCESSED, THEN GO READ IT
C IF (IBCNT.EQ.0) GOTO 5000
C OTHERWISE, OFFSET IT FOR SOLICITATIONS THAT WERE DONE BY
C PROCEDURE CALLED BY THIS PROCEDURE, AND SET IWHERE BACK TO 0
C IF (IWHERE.GT.IBCNT) IBCNT=IWHERE
C IWHERE=0
C GET US TO WHERE WE SHOULD START, THEN GO READ

C IF WE ARE NOW EMPTY, AND LAST FILE WAS A PROCEDURE, THEN GO
C BACK TO INTERACTIVE MODE.  IF LAST FILE WAS A BATCH FILE,
C THEN USER FORGOT TO 'EN', AND LET HIM KNOW.

        IF (BNAME(13:13).EQ.'B' .AND. ISDIGI(BNAME(14:14))) THEN
            WRITE(NDAT,10130)
10130       FORMAT(' *** NO "EN"  ENCOUNTERED. TERMINATION ASSUMED')
            GOTO 7199
        ENDIF

C GO BACK TO INTERACTIVE MODE.  PUT ALL THE LUN'S BACK, AND
C REOPEN THE LOG FILE, SINCE IT WAS CLOSED FOR BATCH, 
C REDEFINE LUNS IF INTERACTIVE USE

	COPT  = 'I'
	IBCNT = 0
	NIN   = NTERM
        IF (ONUNIX) THEN
           NOUT  = 6
           NECHO = NOUT
        ELSE
	   NOUT  = NTERM
	   NECHO = NTERM
        ENDIF

	NPROC = NDISK

C       USE APPEND, SINCE WE WANT TO ADD ON TO FROM BEFORE
C       SAVE REGISTERS, GET THE OPTION
#ifdef SP_SUN4
	OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND')      
#else
	OPEN(NPROC,FILE=LOG,STATUS='OLD',ACCESS='APPEND',
     &       CARRIAGECONTROL='LIST')      
#endif
	GOTO 5000
@


1.28
log
@changed copyright data
@
text
@d116 1
a116 1
        DATA CVERS/'V03.6  2/08/96'/ 
@


1.27
log
@changed copyright notice
@
text
@d8 2
a9 1
C *  COPYRIGHT (C)1985, HEALTH RESEARCH INCORPORATED, ALBANY, NY 12201 *
@


1.26
log
@FN1 and FN2 not correct use
@
text
@d8 3
a10 4
C *  COPYRIGHT (C)    , WADSWORTH CENTER FOR LABORATORIES AND          *
C *    RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201 *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS *
d12 1
a12 1
C *    APPROVAL OF THE CENTER FOR LABORATORIES AND RESEARCH.           *
d115 1
a115 1
        DATA CVERS/'V03.5  8/11/95'/ 
d129 1
a129 1
        DATA CVERS/'V14.7  8/11/95'/ 
d208 2
a209 2
9090    FORMAT(/' SPIDER  --  COPYRIGHT 1993,  WADSWORTH CENTER, ',/,
     &  '             NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY'/)
@


1.25
log
@inline buffer stuff removed
@
text
@d474 1
a474 1
           IF (FN1 .LT. 0) P1 = -P1
d483 1
a483 1
             IF (FN2 .LT. 0) P2 = -P2
@


1.24
log
@added call to initinln, removed old inline buffer stuff
@
text
@a161 7
C	FOR INLINED BUFFER BUFF.
C	LET SPLIT FBUF IN 2, CHANGE IT IN SETMODE ROUTINE.
	ISZBUF0 = ISZBUF
	INLNSIZE = ISZBUF / 2
	INLNAM1 = '___1' // NULL
	INLNAM2 = '___2' // NULL

@


1.23
log
@did not transfer sym. parameters to second proc due to Q format read
@
text
@a107 57
C
C	MANY COMMANDS IN SPIDER READ A FILE, MANIPULATE THE DATA, AND
C	WRITE THE RESULTS INTO A FILE, ONLY TO HAVE THE NEXT COMMAND
C	READ THE DATA BACK AGAIN IN CORE TO MANIPULATE IT AND STORE
C	IT BACK TO A FILE THEN START THE CYCLE AGAIN...
C	TO SPEED UP THE PROCESS, THE USER HAS THE ABILITY TO HAVE THAT 
C	DATA KEPT IN INCORE MEMORY UNTIL HE DECIDES THAT HE WANTS IT IN
C	A FILE. FOR THAT, SPIDER OFFERS AN INCORE MEMORY IN A COMMON BLOCK
C       BUFFER:
C		PARAMETER (ISZBUF = 500000)
C		COMMON/SPI_FILEB/FBUF(ISZBUF)
C	note:  ISZBUF0=ISZBUF
C
C	THIS BUFFER CAN BE SUBDIVIDED INTO TWO PART TO HOLD TWO FILES, 
C	CALLED INFILES.
C	BY DEFAULT, THE INFILES ARE CALLED ___1 AND ___2. THE USER
C	CAN RENAME THEM, WITH THE MD COMMAND (SETMODE.FOR ROUTINES).
C	THE USER NAMES ARE STORED AS INLNAM1 AND INLNAM2.
C		CHARACTER * 80 INLNAM1,INLNAM2
C		COMMON/CINLN_NAMES/INLNAM1,INLNAM2
C
C	THE SIZES OF THESE BUFFERS ARE INLNSIZE AND (ISZBUF0 - INLNSIZE).
C		INTEGER INLNSIZE, ISZBUF0
C		COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
C
C	A DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN 
C	DISK FILE (I.E: A HEADER FOLLOWED BY NROWS OF DATA OF LENGTH NSAMS
C	REPEATED NSLICE TIMES).
C	SPIDER OPENS A FILE TWICE. FIRST TO READ/WRITE THE HEADER WITH
C	A (COMPUTED) RECORD SIZE REC1, THEN A SECOND TIME, TO  READ/WRITE
C	THE IMAGE DATE ITSELF WITH A  (COMPUTED) RECORD SIZE REC2.
C	THE RECORD SIZES, REC1 AND REC2 ARE STORED IN RECLN0* AND RECLN1*
C       RESPECTIVELY FOR EACH INLINED BUFFER.
C		INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
C		COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
C	where INLUN* is the unit associated with each inlined buffer (90,91)
C
C	WE WANT TO ADD 2 BUFFERS OF VARIABLE SIZE IN WHICH THE USER
C	CAN STORE DOCUMENT FILES IN CORE.
C	1 FILE IN FBUF(1,..,INLN1), 2 FILE IN FBUF(INLN1+1,500000)
C
C	TO BE ABLE TO CHOOSE, IN REDLIN AND WRITLIN, WHICH OF A FILE OR 
C	AN INLINED BUFFER WE ARE DEALING WITH, OPENF & OPENFB SET LUNARA(LUN)
C	OR LUNIRI(LUN) TO A POSITIVE NUMBER WHILE THE OTHER IS SET TO 0.
C	I.E; LUNINI(LUN) > 0 AND LUNARA(LUN) =0 WHEN USING INLINED BUFFER.
C
C	FBUF WILL BE DIVIDED INTO TWO ARRAYS (we have iszbuf0 = iszbuf)
	PARAMETER (ISZBUF = 500000)
	COMMON/SPI_FILEB/FBUF(ISZBUF)
C	INLNAM 1&2 ARE THE NAME ASSIGNED TO EACH INLINED ARRAY
	CHARACTER * 80 INLNAM1,INLNAM2
	COMMON/CINLN_NAMES/INLNAM1,INLNAM2
C	DEFAULT VALUE OF INLNSIZE = ISZBUF/2 
	INTEGER INLNSIZE, ISZBUF0
	COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
	INTEGER ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	COMMON/LUNYP/ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
d116 1
a116 1
        DATA CVERS/'V03.4  2/ 6/95'/ 
d130 1
a130 1
        DATA CVERS/'V14.6  2/ 6/95'/ 
d230 2
@


1.22
log
@fixed for sun
@
text
@a423 1

a483 1
2389           FORMAT(A)
a485 1

d500 11
a510 2
	READ(NIN,2390) NCHAR,FUNCNU(:NCHAR)
2390    FORMAT(Q,A80)
@


1.21
log
@allow use of inlined buff 1 and 2 simultaneously
@
text
@d306 3
d311 1
d528 2
a529 2
           FN1   = IREGST(1)
           P1    = PRAMSV(ISTOP,ABS(FN1))
d537 2
a538 2
             FN2   = IREGST(2)
             P2    = PRAMSV(ISTOP,ABS(FN2))
d597 3
d601 2
d1364 3
d1369 1
@


1.20
log
@n_verbose set to 1
@
text
@d163 2
a164 2
	INTEGER ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
	COMMON/LUNYP/ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
@


1.19
log
@changes for inlined buff by adding lunini array
@
text
@d214 1
a214 1
	DATA NTRACE/0/,N_VERBOSE/0/,N_MOSAIC/0/,IPRTT/0/
@


1.18
log
@add C for commented line
@
text
@d149 5
d163 2
a164 3
C	FORTRAN UNIT ASSOCIATED WITH EACH FILENAME
	INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
	COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
a215 4

C	IF AN INLINED BUFF IS USED, INLUNi WILL BE NOT(0).
        DATA INLUN1/90/,RECLN01/1024/,RECLN11/0/,INLUN2/91/
        DATA RECLN02/1024/,RECLN12/0/
@


1.17
log
@added comments for inlined buffers
@
text
@d144 2
a145 1
	WE WANT TO ADD 2 BUFFERS OF VARIABLE SIZE IN WHICH THE USER
@


1.16
log
@delete second def of variable iprtt and n_verbose
@
text
@d108 37
a144 2

C	WE WANT TO ADD 2 BUFFERS OF VARIABLE SIZE IN WHICH THE USER
a146 1
C	INLUN1(2) IS THE UNIT THAT READ FILE 1(2)
@


1.15
log
@increased MAXTMP
@
text
@a164 1
	DATA IPRTT/0/,N_VERBOSE/1/
@


1.14
log
@added an inlined buffer
@
text
@d44 1
a44 1
	PARAMETER (MAXTMP=300)  
@


1.13
log
@fixed procedure file string
@
text
@d109 20
d176 1
a176 1
	DATA NTRACE/0/
d179 4
d184 7
@


1.12
log
@bug on output line of first command
@
text
@d16 3
a18 3
C       DRIVER OF SPIDER IMAGE PROCESSING SYSTEM. J.FRANK              *
C       IMPORTANT : PLEASE UPDATE FIRST DATA STATEMENT (MARKED BY $S)  *
C       EVERY TIME THE PROGRAM IS CHANGED!                             *
d57 1
a57 1
        PARAMETER (NNAME=30)
d114 1
a114 1
        DATA CVERS/'V03.3 12/ 6/94'/ 
d128 1
a128 1
        DATA CVERS/'V14.5 12/ 6/94'/ 
d866 2
a867 3
            IF (ONUNIX) NTNAME = NTNAME - 1
            WRITE(NOUT,9045) TNAME(1:NTNAME) 
9045        FORMAT(' *** LOCAL PROCEDURE FILE DOES NOT EXIST: ',A) 
d877 1
a877 1
             TNAME = TNAME(:NCHART) // TNAMEM// '.sys'// NULL
@


1.11
log
@renamed RESULTS -> results
@
text
@d225 1
a225 1
           FCHAR(1:2) = 'NC'
a266 10
C       WRITE OUT WELCOME NOTE
C	WRITE(ITI,1770)
C1770	FORMAT('     WELCOME    '
C     1     /' +%%%   TO    %%%'
C     2     /' ++++  THE    +++'
C     3     /' +...  WORLD  ...'
C     4     /' +      OF       '
C     5     /' +*** SPIDER  ***'/)


d721 2
a722 3
5200	IF (IDISPL .GT. 0) CALL WIEXPOS(.FALSE.)
        IRTFLG = -999
        CALL RDPRMC(FCHAR,NALPH,.TRUE.,'OPERATION',NULL,IRTFLG)
d841 1
d865 5
a869 1

d878 1
a878 1
             TNAME = TNAME(:NCHART) // TNAMEM(:NALPH)// '.sys'// NULL
@


1.10
log
@changed argument handling for procedures
@
text
@d148 1
a148 1
	DATA RESULM(1:7),RESULM(8:8)/'RESULTS',0/
@


1.9
log
@changed ipcnt  to transfer registers from proc to proc
@
text
@d114 1
a114 1
        DATA CVERS/'V03.2 11/14/94'/ 
d128 1
a128 1
        DATA CVERS/'V14.4 11/14/94'/ 
d281 1
a281 1
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
d371 1
a371 1
C 1/16/86 ----- COPY ARGUMENT LIST IF PRESENT -------------------------
d380 1
d384 2
a385 1
	     WRITE(NOUT,*) '*** ARGUMENT MISMATCH IN PROCEDURE'
d393 3
a395 3
C         PUT SEMICOLON IN FRONT OF DUMMY ARGUMENT LIST
          REFUNC(1:NUMCHR+1) = ';' // REFUNC(1:NUMCHR)
	  NUMCHR = NUMCHR+1
d745 2
a746 5
C       IF THE FIRST CHARACTER IS '@@' THEN WE HAVE A PROCEDURE WITH NEW
C       NAMING CONVENTION.  ELIMINATE '@@' AND GOTO PROCEDURE EVALUATION
	NFSTRT = 1
	IF (FCHAR(:1) .EQ. '@@') THEN
	  NFSTRT = 2
a747 7
C         DETERMINE FIRST CONTIGUOUS STRING
          NAL = INDEX(FCHAR(2:NALPH),' ') -1
          IF (NAL .LE. 0) NAL = NALPH - 1
          NALPH = NAL
	  GOTO 5600
	ENDIF

d817 1
d837 4
d843 1
a843 1
     &              RLIST,NLIST,NPARG)
a848 6
C       FIRST CHECK FOR MAXIMUM ARGUMENT COUNT
	IF (NLIST .GT. NPARG) THEN
	   WRITE(NOUT,*) '*** TOO MANY ARGUMENTS IN PROCEDURE'
	   GOTO 7200
	ENDIF
C       END OF COPY ARGUMENT LIST /END --------------------------------
@


1.8
log
@needed onsgi = .false. for vax
@
text
@d369 1
d372 1
a372 2
C TRANSFER REGISTER CONTENTS FROM CALLING LEVEL TO CALLED LEVEL
C PUT SEMICOLON IN FRONT OF DUMMY ARGUMENT LIST
d375 2
a376 2
     &    (REFUNC(2:2) .EQ. 'X' .OR. REFUNC(2:2) .EQ. 'x') .AND.
     &    ISDIGI(REFUNC(3:3))) THEN
d378 2
d390 2
a395 2
C       1/16/85 ----- COPY ARGUMENT LIST/ END
	IPCNT = IPCNT + 1
@


1.7
log
@set ONSGI and ONOSF
@
text
@d126 2
@


1.6
log
@fixed common block dcfile(20)
@
text
@d15 1
a15 1
C
d99 2
a100 2
	LOGICAL        ONSUN,ONUNIX
        COMMON /OPSYS/ ONSUN,ONUNIX
d114 4
a117 1
        DATA CVERS/'V03.1 09/14/94'/ 
d120 5
d126 1
a126 1
        DATA CVERS/'V14.3 09/14/94'/ 
d130 1
@


1.5
log
@changed dindex to uppercase the index if necessary
@
text
@d103 1
a103 1
        COMMON /DOC_DIMS/MAXKEY1,MAXREG1,NKEY,NREG,NDOCFL1
a106 1

@


1.4
log
@changed version, added mygetenv call for *.sys on unix, removed welcome
@
text
@d115 1
a115 1
        DATA CVERS/'V03.0 09/14/94'/ 
d119 1
a119 1
        DATA CVERS/'V14.2 09/14/94'/ 
d1017 1
@


1.3
log
@alignment off on driv1_com
@
text
@d72 1
a72 1
        CHARACTER *(NTN)      TNAMEM
d74 1
a74 1
        CHARACTER *(NNAME)    RESULT,LOG,LOG1,BNAME,TNAME
d111 1
a111 2
C	** V E R S I O N  *****
C       ** R E L E A S E  *****
d115 1
a115 1
        DATA CVERS/'V02.0 05/13/94'/ 
d119 2
a120 2
        DATA CVERS/'V14.0 05/12/94'/ 
        DATA CRELS/'/(ALBANY   6210)'/ 
a196 1
C23456789012345678901234567890123456789012345678901234567890123456789012
d198 2
a199 4
9090    FORMAT(/' SPIDER  --  COPYRIGHT 1993, ',
     &  'WADSWORTH CENTER FOR LABORATORIES AND RESEARCH, ',/,
     &  '             NEW YORK STATE DEPARTMENT OF HEALTH, '
     &  'ALBANY, NY',/)
d207 1
a207 1
1650	FORMAT(' SPIDER ',A14,A16,' ON ',A9,' AT ',A8/)
d258 7
a264 7
	WRITE(ITI,1770)
1770	FORMAT('     WELCOME    '
     1     /'+%%%   TO    %%%'
     2     /'++++  THE    +++'
     3     /'+...  WORLD  ...'
     4     /'+      OF       '
     5     /'+*** SPIDER  ***'/)
d878 4
a881 2
C            UNIX DOES NOT USE *.SYS FILES YET
             CALL FILCAN(TNAME,NTNAME,NULL,  NULL,TNAMEM,PRJEXC,IER)
d885 2
a886 2
 
          IF (IER.NE.0) GOTO 7200
d890 3
a892 2
C           .SYS FILE DOES NOT EXIST. NOTIFY USER
5800        WRITE(NOUT,5820) TNAME(1:NTNAME) 
@


1.2
log
@added numrep to driv1_com
@
text
@d108 1
a108 1
        COMMON /DRIV1_COM/ T1,DINDEX,NUMREP
@


1.1
log
@cpp_lines_added
@
text
@d108 1
a108 1
        COMMON /DRIV1_COM/ T1,DINDEX
@
